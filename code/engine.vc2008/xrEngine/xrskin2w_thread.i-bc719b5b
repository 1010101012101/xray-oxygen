# 1 "c:\\games\\stalker\\oxygen\\xray-oxygen\\code\\engine.vc2008\\xrengine\\cpu\\xrskin2w_thread.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 356 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "c:\\games\\stalker\\oxygen\\xray-oxygen\\code\\engine.vc2008\\xrengine\\cpu\\xrskin2w_thread.cpp" 2
# 1 ".\\stdafx.h" 1
# 11 ".\\stdafx.h"
# 1 "./../xrCore/xrCore.h" 1







#pragma warning(disable: 4530)


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\exception" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstddef" 1 3




# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 1 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xkeycheck.h" 1 3
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\crtdefs.h" 1 3








# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\sal.h" 1 3
# 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\sal.h" 3
extern "C" {
# 2967 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\sal.h" 3
}



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\ConcurrencySal.h" 1 3
# 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\ConcurrencySal.h" 3
extern "C" {
# 354 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\ConcurrencySal.h" 3
}
# 2970 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\sal.h" 2 3
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 1 3
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 3
#pragma pack(push, 8)


extern "C" {
# 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 3
        typedef unsigned __int64 uintptr_t;
# 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 3
        typedef char* va_list;
# 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 3
    void __cdecl __va_start(va_list* , ...);
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 3
}



    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    }
# 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vadefs.h" 3
#pragma pack(pop)
# 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 2 3
# 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
#pragma pack(push, 8)
# 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
 extern "C" {
# 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
    typedef unsigned __int64 size_t;
    typedef __int64 ptrdiff_t;
    typedef __int64 intptr_t;







    typedef bool __vcrt_bool;
# 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];


    }
# 298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
    void __cdecl __security_init_cookie(void);





        void __cdecl __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure( uintptr_t _StackCookie);



extern uintptr_t __security_cookie;







}
# 317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 3
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\crtdefs.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 1 3
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 2 3


#pragma pack(push, 8)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
 extern "C" {
# 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}



    typedef bool __crt_bool;
# 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
               wchar_t const* _Expression,
               wchar_t const* _FunctionName,
               wchar_t const* _FileName,
               unsigned int _LineNo,
               uintptr_t _Reserved);
# 482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
typedef int errno_t;
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
typedef long __time32_t;
typedef __int64 __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
                        int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data* locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;
# 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
        typedef __time64_t time_t;
# 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
    typedef size_t rsize_t;
# 1982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
}
# 1982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h" 3
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\crtdefs.h" 2 3
# 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 2 3
# 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)
# 314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
#pragma detect_mismatch("_MSC_VER", "1900")



#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")








#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
# 445 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\use_ansi.h" 1 3
# 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\use_ansi.h" 3
#pragma comment(lib, "msvcprt" "" "")
# 445 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 2 3
# 598 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
namespace std {
enum _Uninitialized
 {
 _Noinit
 };


class __declspec(dllimport) _Lockit
 {
public:
# 626 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
 __thiscall _Lockit();
 explicit __thiscall _Lockit(int);
 __thiscall ~_Lockit() noexcept;


 static void __cdecl _Lockit_ctor(int);
 static void __cdecl _Lockit_dtor(int);

private:
 static void __cdecl _Lockit_ctor(_Lockit *);
 static void __cdecl _Lockit_ctor(_Lockit *, int);
 static void __cdecl _Lockit_dtor(_Lockit *);

public:
                    _Lockit(const _Lockit&) = delete;
 _Lockit& operator=(const _Lockit&) = delete;

private:
 int _Locktype;
 };
# 729 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
class __declspec(dllimport) _Init_locks
 {
public:
# 744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\yvals.h" 3
 __thiscall _Init_locks();
 __thiscall ~_Init_locks() noexcept;


private:
 static void __cdecl _Init_locks_ctor(_Init_locks *);
 static void __cdecl _Init_locks_dtor(_Init_locks *);
 };

}







__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;




#pragma warning(pop)
#pragma pack(pop)
# 5 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstddef" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h" 3
 extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;






    __declspec(dllimport) int* __cdecl _errno(void);


    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h" 3
__declspec(dllimport) extern unsigned long __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



}
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h" 3
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstddef" 2 3



namespace std {
using :: ptrdiff_t; using :: size_t;
typedef double max_align_t;
}

using ::std:: max_align_t;
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdlib" 1 3





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3
 extern "C" {
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
         size_t _Count,
         size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl calloc(
                            size_t _Count,
                            size_t _Size
    );


__declspec(dllimport) int __cdecl _callnewh(
         size_t _Size
    );


__declspec(dllimport) __declspec(allocator)
void* __cdecl _expand(
                            void* _Block,
                            size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
                                   void* _Block
    );

__declspec(dllimport)
void __cdecl free(
                                   void* _Block
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
         size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl malloc(
                            size_t _Size
    );


__declspec(dllimport)
size_t __cdecl _msize_base(
                  void* _Block
    );


__declspec(dllimport)
size_t __cdecl _msize(
                  void* _Block
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
                                    void* _Block,
                                    size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl realloc(
                                   void* _Block,
                                   size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
                                   void* _Block
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
                            size_t _Size,
                            size_t _Alignment
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
                            size_t _Size,
                            size_t _Alignment,
                            size_t _Offset
    );


__declspec(dllimport)
size_t __cdecl _aligned_msize(
                  void* _Block,
                  size_t _Alignment,
                  size_t _Offset
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
                                   void* _Block,
                                   size_t _Size,
                                   size_t _Alignment,
                                   size_t _Offset
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size,
                                   size_t _Alignment,
                                   size_t _Offset
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
                                   void* _Block,
                                   size_t _Size,
                                   size_t _Alignment
    );


__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
                                   void* _Block,
                                   size_t _Count,
                                   size_t _Size,
                                   size_t _Alignment
    );
# 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3
}
# 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 1 3
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
#pragma pack(push, 8)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
 extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);





    __declspec(dllimport) void* __cdecl bsearch_s(
                                                           void const* _Key,
                                                           void const* _Base,
                                                           rsize_t _NumOfElements,
                                                           rsize_t _SizeOfElements,
                               _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                           void* _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
                                                                void* _Base,
                                                                rsize_t _NumOfElements,
                                                                rsize_t _SizeOfElements,
                                _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                                void* _Context
        );






__declspec(dllimport) void* __cdecl bsearch(
                                                       void const* _Key,
                                                       void const* _Base,
                                                       size_t _NumOfElements,
                                                       size_t _SizeOfElements,
                        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
                                                            void* _Base,
                                                            size_t _NumOfElements,
                                                            size_t _SizeOfElements,
                        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lfind_s(
                                                          void const* _Key,
                                                          void const* _Base,
                                                          unsigned int* _NumOfElements,
                                                          size_t _SizeOfElements,
                                _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                          void* _Context
    );


__declspec(dllimport) void* __cdecl _lfind(
                                                          void const* _Key,
                                                          void const* _Base,
                                                          unsigned int* _NumOfElements,
                                                          unsigned int _SizeOfElements,
                             _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lsearch_s(
                                                                void const* _Key,
                                                                void* _Base,
                                                                unsigned int* _NumOfElements,
                                                                size_t _SizeOfElements,
                                      _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                                void* _Context
    );


__declspec(dllimport) void* __cdecl _lsearch(
                                                                void const* _Key,
                                                                void* _Base,
                                                                unsigned int* _NumOfElements,
                                                                unsigned int _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
# 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                              void const* _Key,
                                                              void const* _Base,
                                                              unsigned int* _NumOfElements,
                                                              unsigned int _SizeOfElements,
                                 _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                   void const* _Key,
                                                                   void* _Base,
                                                                   unsigned int* _NumOfElements,
                                                                   unsigned int _SizeOfElements,
                                      _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );





}
# 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
 extern "C" {
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                     int _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);
# 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                     long _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);







    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                     unsigned long _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);







    __declspec(dllimport) double __cdecl wcstod(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr
        );


    __declspec(dllimport) double __cdecl _wcstod_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 _locale_t _Locale
        );


    __declspec(dllimport) long __cdecl wcstol(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) long __cdecl _wcstol_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) long long __cdecl wcstoll(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) long long __cdecl _wcstoll_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) unsigned long __cdecl wcstoul(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) long double __cdecl wcstold(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr
        );


    __declspec(dllimport) long double __cdecl _wcstold_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 _locale_t _Locale
        );


    __declspec(dllimport) float __cdecl wcstof(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr
        );


    __declspec(dllimport) float __cdecl _wcstof_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 _locale_t _Locale
        );


    __declspec(dllimport) double __cdecl _wtof(
               wchar_t const* _String
        );


    __declspec(dllimport) double __cdecl _wtof_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) int __cdecl _wtoi(
               wchar_t const* _String
        );


    __declspec(dllimport) int __cdecl _wtoi_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) long __cdecl _wtol(
               wchar_t const* _String
        );


    __declspec(dllimport) long __cdecl _wtol_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) long long __cdecl _wtoll(
               wchar_t const* _String
        );


    __declspec(dllimport) long long __cdecl _wtoll_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                     __int64 _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                               __int64 _Value,
                               wchar_t* _Buffer,
                               int _Radix
        );


    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                     unsigned __int64 _Value,
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     int _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                               unsigned __int64 _Value,
                               wchar_t* _Buffer,
                               int _Radix
        );


    __declspec(dllimport) __int64 __cdecl _wtoi64(
               wchar_t const* _String
        );


    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
                 wchar_t const* _String,
                 _locale_t _Locale
        );


    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );


    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix
        );


    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                                 wchar_t const* _String,
                                 wchar_t** _EndPtr,
                                 int _Radix,
                                 _locale_t _Locale
        );






    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
                                         wchar_t* _Buffer,
                                         wchar_t const* _Path,
                                         size_t _BufferCount
        );




    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
                                     wchar_t* _Buffer,
                                     size_t _BufferCount,
                                     wchar_t const* _Drive,
                                     wchar_t const* _Dir,
                                     wchar_t const* _Filename,
                                     wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);







#pragma warning(pop)

 __declspec(dllimport) void __cdecl _wperror(
                   wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                                 wchar_t const* _FullPath,
                                 wchar_t* _Drive,
                                 wchar_t* _Dir,
                                 wchar_t* _Filename,
                                 wchar_t* _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                           wchar_t const* _FullPath,
                                           wchar_t* _Drive,
                                           size_t _DriveCount,
                                           wchar_t* _Dir,
                                           size_t _DirCount,
                                           wchar_t* _Filename,
                                           size_t _FilenameCount,
                                           wchar_t* _Ext,
                                           size_t _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
# 413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                                                                                        wchar_t** _Buffer,
                                                                                        size_t* _BufferCount,
                                                                                        wchar_t const* _VarName
            );



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
                   wchar_t const* _VarName
            );



        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                             size_t* _RequiredCount,
                                             wchar_t* _Buffer,
                                             size_t _BufferCount,
                                             wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
# 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
        __declspec(dllimport) int __cdecl _wputenv(
                   wchar_t const* _EnvString
            );


        __declspec(dllimport) errno_t __cdecl _wputenv_s(
                   wchar_t const* _Name,
                   wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                         wchar_t const* _Filename,
                                         wchar_t const* _VarName,
                                         wchar_t* _Buffer,
                                         size_t _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }






        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






        __declspec(dllimport) int __cdecl _wsystem(
                       wchar_t const* _Command
            );






}
# 484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits.h" 2 3


#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits.h" 3
 extern "C" {
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits.h" 3
}
# 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits.h" 3
#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 2 3


#pragma pack(push, 8)
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
 extern "C" {
# 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) void __cdecl _swab(
                                                                     char* _Buf1,
                                                                     char* _Buf2,
                                                                     int _SizeInBytes
    );
# 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    __declspec(dllimport) __declspec(noreturn) void __cdecl exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);






__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
         unsigned int _Flags,
         unsigned int _Mask
    );






    typedef int (__cdecl* _onexit_t)(void);
# 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    int __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);


int __cdecl at_quick_exit(void (__cdecl*)(void));
# 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    typedef void (__cdecl* _purecall_handler)(void);


    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );


    __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(
                 _purecall_handler _Handler
        );

    __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);


    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
                 _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
                 _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
# 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
                   __declspec(dllimport) int __cdecl _set_error_mode( int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);


    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);


    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);


    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);


    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);


    __declspec(dllimport) void __cdecl perror( char const* _ErrMsg);





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char** __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int* __cdecl __p__fmode (void);
# 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _get_pgmptr ( char** _Value);


__declspec(dllimport) errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode ( int _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode ( int* _PMode);
# 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

               int __cdecl abs ( int _Number);
               long __cdecl labs ( long _Number);
               long long __cdecl llabs ( long long _Number);
               __int64 __cdecl _abs64( __int64 _Number);

               unsigned short __cdecl _byteswap_ushort( unsigned short _Number);
               unsigned long __cdecl _byteswap_ulong ( unsigned long _Number);
               unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

               __declspec(dllimport) div_t __cdecl div ( int _Numerator, int _Denominator);
               __declspec(dllimport) ldiv_t __cdecl ldiv ( long _Numerator, long _Denominator);
               __declspec(dllimport) lldiv_t __cdecl lldiv( long long _Numerator, long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
         unsigned int _Value,
         int _Shift
    );


unsigned long __cdecl _lrotl(
         unsigned long _Value,
         int _Shift
    );

unsigned __int64 __cdecl _rotl64(
         unsigned __int64 _Value,
         int _Shift
    );

unsigned int __cdecl _rotr(
         unsigned int _Value,
         int _Shift
    );


unsigned long __cdecl _lrotr(
         unsigned long _Value,
         int _Shift
    );

unsigned __int64 __cdecl _rotr64(
         unsigned __int64 _Value,
         int _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand( unsigned int _Seed);

               __declspec(dllimport) int __cdecl rand(void);
# 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
# 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#pragma pack(push, 4)
 typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
#pragma pack(pop)
# 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








 __declspec(dllimport) double __cdecl atof ( char const* _String);
                                  __declspec(dllimport) int __cdecl atoi ( char const* _String);
                                  __declspec(dllimport) long __cdecl atol ( char const* _String);
                                  __declspec(dllimport) long long __cdecl atoll ( char const* _String);
                                  __declspec(dllimport) __int64 __cdecl _atoi64( char const* _String);

               __declspec(dllimport) double __cdecl _atof_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _atoi_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) long __cdecl _atol_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) long long __cdecl _atoll_l ( char const* _String, _locale_t _Locale);
               __declspec(dllimport) __int64 __cdecl _atoi64_l( char const* _String, _locale_t _Locale);

               __declspec(dllimport) int __cdecl _atoflt ( _CRT_FLOAT* _Result, char const* _String);
               __declspec(dllimport) int __cdecl _atodbl ( _CRT_DOUBLE* _Result, char* _String);
               __declspec(dllimport) int __cdecl _atoldbl( _LDOUBLE* _Result, char* _String);


__declspec(dllimport) int __cdecl _atoflt_l(
             _CRT_FLOAT* _Result,
             char const* _String,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _atodbl_l(
             _CRT_DOUBLE* _Result,
             char* _String,
             _locale_t _Locale
    );



__declspec(dllimport) int __cdecl _atoldbl_l(
             _LDOUBLE* _Result,
             char* _String,
             _locale_t _Locale
    );


__declspec(dllimport) float __cdecl strtof(
                             char const* _String,
                             char** _EndPtr
    );


__declspec(dllimport) float __cdecl _strtof_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


__declspec(dllimport) double __cdecl strtod(
                             char const* _String,
                             char** _EndPtr
    );


__declspec(dllimport) double __cdecl _strtod_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


__declspec(dllimport) long double __cdecl strtold(
                             char const* _String,
                             char** _EndPtr
    );


__declspec(dllimport) long double __cdecl _strtold_l(
                             char const* _String,
                             char** _EndPtr,
                             _locale_t _Locale
    );


__declspec(dllimport) long __cdecl strtol(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) long __cdecl _strtol_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) long long __cdecl strtoll(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) long long __cdecl _strtoll_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) unsigned long __cdecl strtoul(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) unsigned long long __cdecl strtoull(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) __int64 __cdecl _strtoi64(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                             char const* _String,
                             char** _EndPtr,
                             int _Radix,
                             _locale_t _Locale
    );
# 621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _itoa_s(
                                 int _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



__declspec(dllimport) errno_t __cdecl _ltoa_s(
                                 long _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);
# 672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _ultoa_s(
                                 unsigned long _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }






#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



__declspec(dllimport) errno_t __cdecl _i64toa_s(
                                 __int64 _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                           __int64 _Value,
                           char* _Buffer,
                           int _Radix
    );



__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                                 unsigned __int64 _Value,
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 int _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                           unsigned __int64 _Value,
                           char* _Buffer,
                           int _Radix
    );
# 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) errno_t __cdecl _ecvt_s(
                                 char* _Buffer,
          size_t _BufferCount,
          double _Value,
          int _DigitCount,
          int* _PtDec,
          int* _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
# 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
          double _Value,
          int _DigitCount,
          int* _PtDec,
          int* _PtSign
    );



__declspec(dllimport) errno_t __cdecl _fcvt_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 double _Value,
                                 int _FractionalDigitCount,
                                 int* _PtDec,
                                 int* _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
# 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
          double _Value,
          int _FractionalDigitCount,
          int* _PtDec,
          int* _PtSign
    );


__declspec(dllimport) errno_t __cdecl _gcvt_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 double _Value,
                                 int _DigitCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                           double _Value,
                           int _DigitCount,
                           char* _Buffer
    );
# 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);


    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);





__declspec(dllimport) int __cdecl mblen(
                                                char const* _Ch,
                                                size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _mblen_l(
                                                char const* _Ch,
                                                size_t _MaxCount,
                                                _locale_t _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrlen(
           char const* _String
    );



__declspec(dllimport) size_t __cdecl _mbstrlen_l(
             char const* _String,
             _locale_t _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen(
           char const* _String,
           size_t _MaxCount
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
             char const* _String,
             size_t _MaxCount,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl mbtowc(
                                         wchar_t* _DstCh,
                                         char const* _SrcCh,
                                         size_t _SrcSizeInBytes
    );


__declspec(dllimport) int __cdecl _mbtowc_l(
                                         wchar_t* _DstCh,
                                         char const* _SrcCh,
                                         size_t _SrcSizeInBytes,
                                         _locale_t _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                              size_t* _PtNumOfCharConverted,
                                                              wchar_t* _DstBuf,
                                                              size_t _SizeInWords,
                                                              char const* _SrcBuf,
                                                              size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                              size_t* _PtNumOfCharConverted,
                                                              wchar_t* _DstBuf,
                                                              size_t _SizeInWords,
                                                              char const* _SrcBuf,
                                                              size_t _MaxCount,
                                                              _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
# 952 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);
# 964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
                                   char* _MbCh,
                                   wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
                             char* _MbCh,
                             wchar_t _WCh,
                             _locale_t _Locale
    );




    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                                 int* _SizeConverted,
                                                                 char* _MbCh,
                                                                 rsize_t _SizeInBytes,
                                                                 wchar_t _WCh
        );




__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                                     int* _SizeConverted,
                                     char* _MbCh,
                                     size_t _SizeInBytes,
                                     wchar_t _WCh,
                                     _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                                       size_t* _PtNumOfCharConverted,
                                                                       char* _Dst,
                                                                       size_t _DstSizeInBytes,
                                                                       wchar_t const* _Src,
                                                                       size_t _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                                       size_t* _PtNumOfCharConverted,
                                                                       char* _Dst,
                                                                       size_t _DstSizeInBytes,
                                                                       wchar_t const* _Src,
                                                                       size_t _MaxCountInBytes,
                                                                       _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
# 1040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);
# 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
                                     char* _Buffer,
                                     char const* _Path,
                                     size_t _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
                                 char* _Buffer,
                                 size_t _BufferCount,
                                 char const* _Drive,
                                 char const* _Dir,
                                 char const* _Filename,
                                 char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);







#pragma warning(pop)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                             char const* _FullPath,
                             char* _Drive,
                             char* _Dir,
                             char* _Filename,
                             char* _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                       char const* _FullPath,
                                       char* _Drive,
                                       size_t _DriveCount,
                                       char* _Dir,
                                       size_t _DirCount,
                                       char* _Filename,
                                       size_t _FilenameCount,
                                       char* _Ext,
                                       size_t _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
# 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    __declspec(dllimport) errno_t __cdecl getenv_s(
                                         size_t* _RequiredCount,
                                         char* _Buffer,
                                         rsize_t _BufferCount,
                                         char const* _VarName
        );






    __declspec(dllimport) int* __cdecl __p___argc (void);
    __declspec(dllimport) char*** __cdecl __p___argv (void);
    __declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);
# 1173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
    __declspec(dllimport) char*** __cdecl __p__environ (void);
    __declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);
# 1198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) char* __cdecl getenv(
                   char const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
# 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
        __declspec(dllimport) errno_t __cdecl _dupenv_s(
                                                                                        char** _Buffer,
                                                                                        size_t* _BufferCount,
                                                                                        char const* _VarName
            );





        __declspec(dllimport) int __cdecl system(
                       char const* _Command
            );



#pragma warning(push)
#pragma warning(disable: 6540)


 __declspec(dllimport) int __cdecl _putenv(
                   char const* _EnvString
            );


        __declspec(dllimport) errno_t __cdecl _putenv_s(
                   char const* _Name,
                   char const* _Value
            );

#pragma warning(pop)

 __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                         char const* _Filename,
                                         char const* _VarName,
                                         char* _Buffer,
                                         size_t _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }






        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);







        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _seterrormode(
                 int _Mode
            );

        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _beep(
                 unsigned _Frequency,
                 unsigned _Duration
            );

        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _sleep(
                 unsigned long _Duration
            );
# 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
              double _Value,
              int _DigitCount,
              int* _PtDec,
              int* _PtSign
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
              double _Value,
              int _FractionalDigitCount,
              int* _PtDec,
              int* _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                               double _Value,
                               int _DigitCount,
                               char* _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                               int _Value,
                               char* _Buffer,
                               int _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                               long _Value,
                               char* _Buffer,
                               int _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
                                        char* _Buf1,
                                        char* _Buf2,
                                        int _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                               unsigned long _Value,
                               char* _Buffer,
                               int _Radix
        );





                       __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
        __declspec(dllimport) int __cdecl putenv(
                   char const* _EnvString
            );



#pragma warning(pop)

 _onexit_t __cdecl onexit( _onexit_t _Func);





}
# 1381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h" 3
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdlib" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 1 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
 extern "C" {

#pragma warning(push)
#pragma warning(disable: 4738)
#pragma warning(disable: 4820)






 struct _exception
    {
        int type;
        char* name;
        double arg1;
        double arg2;
        double retval;
    };






        struct _complex
        {
            double x, y;
        };
# 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
    typedef float float_t;
    typedef double double_t;
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
        extern double const _HUGE;
# 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
void __cdecl _fperrraise( int _Except);

               __declspec(dllimport) short __cdecl _dclass( double _X);
               __declspec(dllimport) short __cdecl _ldclass( long double _X);
               __declspec(dllimport) short __cdecl _fdclass( float _X);

               __declspec(dllimport) int __cdecl _dsign( double _X);
               __declspec(dllimport) int __cdecl _ldsign( long double _X);
               __declspec(dllimport) int __cdecl _fdsign( float _X);

               __declspec(dllimport) int __cdecl _dpcomp( double _X, double _Y);
               __declspec(dllimport) int __cdecl _ldpcomp( long double _X, long double _Y);
               __declspec(dllimport) int __cdecl _fdpcomp( float _X, float _Y);

               __declspec(dllimport) short __cdecl _dtest( double* _Px);
               __declspec(dllimport) short __cdecl _ldtest( long double* _Px);
               __declspec(dllimport) short __cdecl _fdtest( float* _Px);

__declspec(dllimport) short __cdecl _d_int( double* _Px, short _Xexp);
__declspec(dllimport) short __cdecl _ld_int( long double* _Px, short _Xexp);
__declspec(dllimport) short __cdecl _fd_int( float* _Px, short _Xexp);

__declspec(dllimport) short __cdecl _dscale( double* _Px, long _Lexp);
__declspec(dllimport) short __cdecl _ldscale( long double* _Px, long _Lexp);
__declspec(dllimport) short __cdecl _fdscale( float* _Px, long _Lexp);

__declspec(dllimport) short __cdecl _dunscale( short* _Pex, double* _Px);
__declspec(dllimport) short __cdecl _ldunscale( short* _Pex, long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale( short* _Pex, float* _Px);

               __declspec(dllimport) short __cdecl _dexp( double* _Px, double _Y, long _Eoff);
               __declspec(dllimport) short __cdecl _ldexp( long double* _Px, long double _Y, long _Eoff);
               __declspec(dllimport) short __cdecl _fdexp( float* _Px, float _Y, long _Eoff);

               __declspec(dllimport) short __cdecl _dnorm( unsigned short* _Ps);
               __declspec(dllimport) short __cdecl _fdnorm( unsigned short* _Ps);

               __declspec(dllimport) double __cdecl _dpoly( double _X, double const* _Tab, int _N);
               __declspec(dllimport) long double __cdecl _ldpoly( long double _X, long double const* _Tab, int _N);
               __declspec(dllimport) float __cdecl _fdpoly( float _X, float const* _Tab, int _N);

               __declspec(dllimport) double __cdecl _dlog( double _X, int _Baseflag);
               __declspec(dllimport) long double __cdecl _ldlog( long double _X, int _Baseflag);
               __declspec(dllimport) float __cdecl _fdlog( float _X, int _Baseflag);

               __declspec(dllimport) double __cdecl _dsin( double _X, unsigned int _Qoff);
               __declspec(dllimport) long double __cdecl _ldsin( long double _X, unsigned int _Qoff);
               __declspec(dllimport) float __cdecl _fdsin( float _X, unsigned int _Qoff);


typedef union
{
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C, _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double _Zero_C, _Xbig_C;
extern const float _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;
# 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
extern "C++"
{
                   inline int fpclassify( float _X) throw()
    {
        return _fdtest(&_X);
    }

                   inline int fpclassify( double _X) throw()
    {
        return _dtest(&_X);
    }

                   inline int fpclassify( long double _X) throw()
    {
        return _ldtest(&_X);
    }

                   inline bool signbit( float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

                   inline bool signbit( double _X) throw()
    {
        return _dsign(_X) != 0;
    }

                   inline bool signbit( long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

                   inline int _fpcomp( float _X, float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

                   inline int _fpcomp( double _X, double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

                   inline int _fpcomp( long double _X, long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {
        typedef double _Type;
    };

    template <> struct _Real_type<float>
    {
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {
        typedef long double _Type;
    };

    template <class _T1, class _T2>
                   inline int _fpcomp( _T1 _X, _T2 _Y) throw()
    {
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
                   inline bool isfinite( _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
                   inline bool isinf( _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
                   inline bool isnan( _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
                   inline bool isnormal( _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
                   inline bool isgreater( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool isgreaterequal( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool isless( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool islessequal( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool islessgreater( _Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
                   inline bool isunordered( _Ty1 _X, _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}






                   int __cdecl abs( int _X);
                   long __cdecl labs( long _X);
                   long long __cdecl llabs( long long _X);

                   double __cdecl acos( double _X);
                   double __cdecl asin( double _X);
                   double __cdecl atan( double _X);
                   double __cdecl atan2( double _Y, double _X);

                   double __cdecl cos( double _X);
                   double __cdecl cosh( double _X);
                   double __cdecl exp( double _X);
                                      double __cdecl fabs( double _X);
                   double __cdecl fmod( double _X, double _Y);
                   double __cdecl log( double _X);
                   double __cdecl log10( double _X);
                   double __cdecl pow( double _X, double _Y);
                   double __cdecl sin( double _X);
                   double __cdecl sinh( double _X);
                                      double __cdecl sqrt( double _X);
                   double __cdecl tan( double _X);
                   double __cdecl tanh( double _X);

                   __declspec(dllimport) double __cdecl acosh( double _X);
                   __declspec(dllimport) double __cdecl asinh( double _X);
                   __declspec(dllimport) double __cdecl atanh( double _X);
                   __declspec(dllimport) double __cdecl atof( char const* _String);
                   __declspec(dllimport) double __cdecl _atof_l( char const* _String, _locale_t _Locale);
                   __declspec(dllimport) double __cdecl _cabs( struct _complex _Complex_value);
                   __declspec(dllimport) double __cdecl cbrt( double _X);
                   __declspec(dllimport) double __cdecl ceil( double _X);
                   __declspec(dllimport) double __cdecl _chgsign( double _X);
                   __declspec(dllimport) double __cdecl copysign( double _Number, double _Sign);
                   __declspec(dllimport) double __cdecl _copysign( double _Number, double _Sign);
                   __declspec(dllimport) double __cdecl erf( double _X);
                   __declspec(dllimport) double __cdecl erfc( double _X);
                   __declspec(dllimport) double __cdecl exp2( double _X);
                   __declspec(dllimport) double __cdecl expm1( double _X);
                   __declspec(dllimport) double __cdecl fdim( double _X, double _Y);
                   __declspec(dllimport) double __cdecl floor( double _X);
                   __declspec(dllimport) double __cdecl fma( double _X, double _Y, double _Z);
                   __declspec(dllimport) double __cdecl fmax( double _X, double _Y);
                   __declspec(dllimport) double __cdecl fmin( double _X, double _Y);
                   __declspec(dllimport) double __cdecl frexp( double _X, int* _Y);
                   __declspec(dllimport) double __cdecl hypot( double _X, double _Y);
                   __declspec(dllimport) double __cdecl _hypot( double _X, double _Y);
                   __declspec(dllimport) int __cdecl ilogb( double _X);
                   __declspec(dllimport) double __cdecl ldexp( double _X, int _Y);
                   __declspec(dllimport) double __cdecl lgamma( double _X);
                   __declspec(dllimport) long long __cdecl llrint( double _X);
                   __declspec(dllimport) long long __cdecl llround( double _X);
                   __declspec(dllimport) double __cdecl log1p( double _X);
                   __declspec(dllimport) double __cdecl log2( double _X);
                   __declspec(dllimport) double __cdecl logb( double _X);
                   __declspec(dllimport) long __cdecl lrint( double _X);
                   __declspec(dllimport) long __cdecl lround( double _X);

    int __cdecl _matherr( struct _exception* _Except);

                   __declspec(dllimport) double __cdecl modf( double _X, double* _Y);
                   __declspec(dllimport) double __cdecl nan( char const* _X);
                   __declspec(dllimport) double __cdecl nearbyint( double _X);
                   __declspec(dllimport) double __cdecl nextafter( double _X, double _Y);
                   __declspec(dllimport) double __cdecl nexttoward( double _X, long double _Y);
                   __declspec(dllimport) double __cdecl remainder( double _X, double _Y);
                   __declspec(dllimport) double __cdecl remquo( double _X, double _Y, int* _Z);
                   __declspec(dllimport) double __cdecl rint( double _X);
                   __declspec(dllimport) double __cdecl round( double _X);
                   __declspec(dllimport) double __cdecl scalbln( double _X, long _Y);
                   __declspec(dllimport) double __cdecl scalbn( double _X, int _Y);
                   __declspec(dllimport) double __cdecl tgamma( double _X);
                   __declspec(dllimport) double __cdecl trunc( double _X);
                   __declspec(dllimport) double __cdecl _j0( double _X );
                   __declspec(dllimport) double __cdecl _j1( double _X );
                   __declspec(dllimport) double __cdecl _jn(int _X, double _Y);
                   __declspec(dllimport) double __cdecl _y0( double _X);
                   __declspec(dllimport) double __cdecl _y1( double _X);
                   __declspec(dllimport) double __cdecl _yn( int _X, double _Y);

                   __declspec(dllimport) float __cdecl acoshf( float _X);
                   __declspec(dllimport) float __cdecl asinhf( float _X);
                   __declspec(dllimport) float __cdecl atanhf( float _X);
                   __declspec(dllimport) float __cdecl cbrtf( float _X);
                   __declspec(dllimport) float __cdecl _chgsignf( float _X);
                   __declspec(dllimport) float __cdecl copysignf( float _Number, float _Sign);
                   __declspec(dllimport) float __cdecl _copysignf( float _Number, float _Sign);
                   __declspec(dllimport) float __cdecl erff( float _X);
                   __declspec(dllimport) float __cdecl erfcf( float _X);
                   __declspec(dllimport) float __cdecl expm1f( float _X);
                   __declspec(dllimport) float __cdecl exp2f( float _X);
                   __declspec(dllimport) float __cdecl fdimf( float _X, float _Y);
                   __declspec(dllimport) float __cdecl fmaf( float _X, float _Y, float _Z);
                   __declspec(dllimport) float __cdecl fmaxf( float _X, float _Y);
                   __declspec(dllimport) float __cdecl fminf( float _X, float _Y);
                   __declspec(dllimport) float __cdecl _hypotf( float _X, float _Y);
                   __declspec(dllimport) int __cdecl ilogbf( float _X);
                   __declspec(dllimport) float __cdecl lgammaf( float _X);
                   __declspec(dllimport) long long __cdecl llrintf( float _X);
                   __declspec(dllimport) long long __cdecl llroundf( float _X);
                   __declspec(dllimport) float __cdecl log1pf( float _X);
                   __declspec(dllimport) float __cdecl log2f( float _X);
                   __declspec(dllimport) float __cdecl logbf( float _X);
                   __declspec(dllimport) long __cdecl lrintf( float _X);
                   __declspec(dllimport) long __cdecl lroundf( float _X);
                   __declspec(dllimport) float __cdecl nanf( char const* _X);
                   __declspec(dllimport) float __cdecl nearbyintf( float _X);
                   __declspec(dllimport) float __cdecl nextafterf( float _X, float _Y);
                   __declspec(dllimport) float __cdecl nexttowardf( float _X, long double _Y);
                   __declspec(dllimport) float __cdecl remainderf( float _X, float _Y);
                   __declspec(dllimport) float __cdecl remquof( float _X, float _Y, int* _Z);
                   __declspec(dllimport) float __cdecl rintf( float _X);
                   __declspec(dllimport) float __cdecl roundf( float _X);
                   __declspec(dllimport) float __cdecl scalblnf( float _X, long _Y);
                   __declspec(dllimport) float __cdecl scalbnf( float _X, int _Y);
                   __declspec(dllimport) float __cdecl tgammaf( float _X);
                   __declspec(dllimport) float __cdecl truncf( float _X);
# 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
                       __declspec(dllimport) float __cdecl _logbf( float _X);
                       __declspec(dllimport) float __cdecl _nextafterf( float _X, float _Y);
                       __declspec(dllimport) int __cdecl _finitef( float _X);
                       __declspec(dllimport) int __cdecl _isnanf( float _X);
                       __declspec(dllimport) int __cdecl _fpclassf( float _X);

                       __declspec(dllimport) int __cdecl _set_FMA3_enable( int _Flag);
                       __declspec(dllimport) int __cdecl _get_FMA3_enable(void);
# 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
                       __declspec(dllimport) float __cdecl acosf( float _X);
                       __declspec(dllimport) float __cdecl asinf( float _X);
                       __declspec(dllimport) float __cdecl atan2f( float _Y, float _X);
                       __declspec(dllimport) float __cdecl atanf( float _X);
                       __declspec(dllimport) float __cdecl ceilf( float _X);
                       __declspec(dllimport) float __cdecl cosf( float _X);
                       __declspec(dllimport) float __cdecl coshf( float _X);
                       __declspec(dllimport) float __cdecl expf( float _X);
# 669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
                       __inline float __cdecl fabsf( float _X)
        {
            return (float)fabs(_X);
        }





                       __declspec(dllimport) float __cdecl floorf( float _X);
                       __declspec(dllimport) float __cdecl fmodf( float _X, float _Y);
# 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
                   __inline float __cdecl frexpf( float _X, int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

                   __inline float __cdecl hypotf( float _X, float _Y)
    {
        return _hypotf(_X, _Y);
    }

                   __inline float __cdecl ldexpf( float _X, int _Y)
    {
        return (float)ldexp(_X, _Y);
    }



                       __declspec(dllimport) float __cdecl log10f( float _X);
                       __declspec(dllimport) float __cdecl logf( float _X);
                       __declspec(dllimport) float __cdecl modff( float _X, float *_Y);
                       __declspec(dllimport) float __cdecl powf( float _X, float _Y);
                       __declspec(dllimport) float __cdecl sinf( float _X);
                       __declspec(dllimport) float __cdecl sinhf( float _X);
                       __declspec(dllimport) float __cdecl sqrtf( float _X);
                       __declspec(dllimport) float __cdecl tanf( float _X);
                       __declspec(dllimport) float __cdecl tanhf( float _X);
# 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
                   __declspec(dllimport) long double __cdecl acoshl( long double _X);

                   __inline long double __cdecl acosl( long double _X)
    {
        return acos((double)_X);
    }

                   __declspec(dllimport) long double __cdecl asinhl( long double _X);

                   __inline long double __cdecl asinl( long double _X)
    {
        return asin((double)_X);
    }

                   __inline long double __cdecl atan2l( long double _Y, long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

                   __declspec(dllimport) long double __cdecl atanhl( long double _X);

                   __inline long double __cdecl atanl( long double _X)
    {
        return atan((double)_X);
    }

                   __declspec(dllimport) long double __cdecl cbrtl( long double _X);

                   __inline long double __cdecl ceill( long double _X)
    {
        return ceil((double)_X);
    }

                   __inline long double __cdecl _chgsignl( long double _X)
    {
        return _chgsign((double)_X);
    }

                   __declspec(dllimport) long double __cdecl copysignl( long double _Number, long double _Sign);

                   __inline long double __cdecl _copysignl( long double _Number, long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

                   __inline long double __cdecl coshl( long double _X)
    {
        return cosh((double)_X);
    }

                   __inline long double __cdecl cosl( long double _X)
    {
        return cos((double)_X);
    }

                   __declspec(dllimport) long double __cdecl erfl( long double _X);
                   __declspec(dllimport) long double __cdecl erfcl( long double _X);

                   __inline long double __cdecl expl( long double _X)
    {
        return exp((double)_X);
    }

                   __declspec(dllimport) long double __cdecl exp2l( long double _X);
                   __declspec(dllimport) long double __cdecl expm1l( long double _X);

                   __inline long double __cdecl fabsl( long double _X)
    {
        return fabs((double)_X);
    }

                   __declspec(dllimport) long double __cdecl fdiml( long double _X, long double _Y);

                   __inline long double __cdecl floorl( long double _X)
    {
        return floor((double)_X);
    }

                   __declspec(dllimport) long double __cdecl fmal( long double _X, long double _Y, long double _Z);
                   __declspec(dllimport) long double __cdecl fmaxl( long double _X, long double _Y);
                   __declspec(dllimport) long double __cdecl fminl( long double _X, long double _Y);

                   __inline long double __cdecl fmodl( long double _X, long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

                   __inline long double __cdecl frexpl( long double _X, int *_Y)
    {
        return frexp((double)_X, _Y);
    }

                   __declspec(dllimport) int __cdecl ilogbl( long double _X);

                   __inline long double __cdecl _hypotl( long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

                   __inline long double __cdecl hypotl( long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

                   __inline long double __cdecl ldexpl( long double _X, int _Y)
    {
        return ldexp((double)_X, _Y);
    }

                   __declspec(dllimport) long double __cdecl lgammal( long double _X);
                   __declspec(dllimport) long long __cdecl llrintl( long double _X);
                   __declspec(dllimport) long long __cdecl llroundl( long double _X);

                   __inline long double __cdecl logl( long double _X)
    {
        return log((double)_X);
    }

                   __inline long double __cdecl log10l( long double _X)
    {
        return log10((double)_X);
    }

                   __declspec(dllimport) long double __cdecl log1pl( long double _X);
                   __declspec(dllimport) long double __cdecl log2l( long double _X);
                   __declspec(dllimport) long double __cdecl logbl( long double _X);
                   __declspec(dllimport) long __cdecl lrintl( long double _X);
                   __declspec(dllimport) long __cdecl lroundl( long double _X);

                   __inline long double __cdecl modfl( long double _X, long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

                   __declspec(dllimport) long double __cdecl nanl( char const* _X);
                   __declspec(dllimport) long double __cdecl nearbyintl( long double _X);
                   __declspec(dllimport) long double __cdecl nextafterl( long double _X, long double _Y);
                   __declspec(dllimport) long double __cdecl nexttowardl( long double _X, long double _Y);

                   __inline long double __cdecl powl( long double _X, long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

                   __declspec(dllimport) long double __cdecl remainderl( long double _X, long double _Y);
                   __declspec(dllimport) long double __cdecl remquol( long double _X, long double _Y, int* _Z);
                   __declspec(dllimport) long double __cdecl rintl( long double _X);
                   __declspec(dllimport) long double __cdecl roundl( long double _X);
                   __declspec(dllimport) long double __cdecl scalblnl( long double _X, long _Y);
                   __declspec(dllimport) long double __cdecl scalbnl( long double _X, int _Y);

                   __inline long double __cdecl sinhl( long double _X)
    {
        return sinh((double)_X);
    }

                   __inline long double __cdecl sinl( long double _X)
    {
        return sin((double)_X);
    }

                   __inline long double __cdecl sqrtl( long double _X)
    {
        return sqrt((double)_X);
    }

                   __inline long double __cdecl tanhl( long double _X)
    {
        return tanh((double)_X);
    }

                   __inline long double __cdecl tanl( long double _X)
    {
        return tan((double)_X);
    }

                   __declspec(dllimport) long double __cdecl tgammal( long double _X);
                   __declspec(dllimport) long double __cdecl truncl( long double _X);
# 975 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
            extern double HUGE;




        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details.")) __declspec(dllimport) double __cdecl j0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details.")) __declspec(dllimport) double __cdecl j1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details.")) __declspec(dllimport) double __cdecl jn( int _X, double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details.")) __declspec(dllimport) double __cdecl y0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details.")) __declspec(dllimport) double __cdecl y1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details.")) __declspec(dllimport) double __cdecl yn( int _X, double _Y);





#pragma warning(pop)

}
# 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\math.h" 2 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdlib" 2 3




               inline double abs( double _Xx) noexcept
 {
 return (:: fabs(_Xx));
 }

               inline float abs( float _Xx) noexcept
 {
 return (:: fabsf(_Xx));
 }

               inline long double abs( long double _Xx) noexcept
 {
 return (:: fabsl(_Xx));
 }

namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;


using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\initializer_list" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<class _Elem>
 class initializer_list
 {
public:
 typedef _Elem value_type;
 typedef const _Elem& reference;
 typedef const _Elem& const_reference;
 typedef size_t size_type;

 typedef const _Elem* iterator;
 typedef const _Elem* const_iterator;

 constexpr initializer_list() noexcept
  : _First(0), _Last(0)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg,
  const _Elem *_Last_arg) noexcept
  : _First(_First_arg), _Last(_Last_arg)
  {
  }

 constexpr const _Elem *begin() const noexcept
  {
  return (_First);
  }

 constexpr const _Elem *end() const noexcept
  {
  return (_Last);
  }

 constexpr size_t size() const noexcept
  {
  return ((size_t)(_Last - _First));
  }

private:
 const _Elem *_First;
 const _Elem *_Last;
 };


template<class _Elem> inline
 constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Elem> inline
 constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.end());
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xtr1common" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

struct _Nil
 {
 };


template<class _Ty,
 _Ty _Val>
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant<_Ty, _Val> type;

 constexpr operator value_type() const noexcept
  {
  return (value);
  }

 constexpr value_type operator()() const noexcept
  {
  return (value);
  }
 };

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


template<bool _Val>
 using bool_constant = integral_constant<bool, _Val>;


template<bool _Val>
 struct _Cat_base
  : integral_constant<bool, _Val>
 {
 };


template<bool _Test,
 class _Ty = void>
 struct enable_if
 {
 };

template<class _Ty>
 struct enable_if<true, _Ty>
 {
 typedef _Ty type;
 };


template<bool _Test,
 class _Ty1,
 class _Ty2>
 struct conditional
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct conditional<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };


template<class _Ty1,
 class _Ty2>
 struct is_same
  : false_type
 {
 };

template<class _Ty1>
 struct is_same<_Ty1, _Ty1>
  : true_type
 {
 };

template<class _Ty,
 class _Uty>
 constexpr bool is_same_v = is_same<_Ty, _Uty>::value;


template<class _Ty>
 struct remove_const
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_volatile
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_cv
 {
 typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
  type;
 };


template<class _Ty>
 struct _Is_integral
  : false_type
 {
 };

template<>
 struct _Is_integral<bool>
  : true_type
 {
 };

template<>
 struct _Is_integral<char>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned char>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed char>
  : true_type
 {
 };


template<>
 struct _Is_integral<wchar_t>
  : true_type
 {
 };


template<>
 struct _Is_integral<unsigned short>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed short>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned int>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed int>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned long>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed long>
  : true_type
 {
 };

template<>
 struct _Is_integral<char16_t>
  : true_type
 {
 };

template<>
 struct _Is_integral<char32_t>
  : true_type
 {
 };

template<>
 struct _Is_integral<long long>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned long long>
  : true_type
 {
 };


template<class _Ty>
 struct is_integral
  : _Is_integral<typename remove_cv<_Ty>::type>
 {
 };

template<class _Ty>
 constexpr bool is_integral_v = is_integral<_Ty>::value;


template<class _Ty>
 struct _Is_floating_point
  : false_type
 {
 };

template<>
 struct _Is_floating_point<float>
  : true_type
 {
 };

template<>
 struct _Is_floating_point<double>
  : true_type
 {
 };

template<>
 struct _Is_floating_point<long double>
  : true_type
 {
 };


template<class _Ty>
 struct is_floating_point
  : _Is_floating_point<typename remove_cv<_Ty>::type>
 {
 };

template<class _Ty>
 constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;


template<class _Ty>
 struct is_arithmetic
  : _Cat_base<is_integral<_Ty>::value
   || is_floating_point<_Ty>::value>
 {
 };

template<class _Ty>
 constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;


template<class _Ty>
 struct remove_reference
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&&>
 {
 typedef _Ty type;
 };


struct _Wrap_int
 {
 _Wrap_int(int)
  {
  }
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
# 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 3
template<bool,
 class _Ty1,
 class _Ty2>
 struct _If
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct _If<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };

template<class _Ty>
 struct _Always_false
 {
 static constexpr bool value = false;
 };
# 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 3
template<class _Ty = void>
 struct plus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left + _Right);
  }
 };


template<class _Ty = void>
 struct minus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left - _Right);
  }
 };


template<class _Ty = void>
 struct multiplies
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left * _Right);
  }
 };


template<class _Ty = void>
 struct equal_to
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left == _Right);
  }
 };


template<class _Ty = void>
 struct less
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left < _Right);
  }
 };


template<>
 struct plus<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct minus<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct multiplies<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct equal_to<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct less<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right));
  }
 };


}



namespace std {

inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
 {

 static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
 const size_t _FNV_offset_basis = 14695981039346656037ULL;
 const size_t _FNV_prime = 1099511628211ULL;







 size_t _Val = _FNV_offset_basis;
 for (size_t _Next = 0; _Next < _Count; ++_Next)
  {
  _Val ^= (size_t)_First[_Next];
  _Val *= _FNV_prime;
  }
 return (_Val);
 }


template<class _Kty>
 struct _Bitwise_hash
 {
 typedef _Kty argument_type;
 typedef size_t result_type;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
  }
 };


template<class _Kty>
 struct hash
  : public _Bitwise_hash<_Kty>
 {
 static constexpr bool _Value = __is_enum(_Kty);
 static_assert(_Value,
  "The C++ Standard doesn't provide a hash for this type.");
 };
template<>
 struct hash<bool>
  : public _Bitwise_hash<bool>
 {
 };

template<>
 struct hash<char>
  : public _Bitwise_hash<char>
 {
 };

template<>
 struct hash<signed char>
  : public _Bitwise_hash<signed char>
 {
 };

template<>
 struct hash<unsigned char>
  : public _Bitwise_hash<unsigned char>
 {
 };

template<>
 struct hash<char16_t>
  : public _Bitwise_hash<char16_t>
 {
 };

template<>
 struct hash<char32_t>
  : public _Bitwise_hash<char32_t>
 {
 };


template<>
 struct hash<wchar_t>
  : public _Bitwise_hash<wchar_t>
 {
 };


template<>
 struct hash<short>
  : public _Bitwise_hash<short>
 {
 };

template<>
 struct hash<unsigned short>
  : public _Bitwise_hash<unsigned short>
 {
 };

template<>
 struct hash<int>
  : public _Bitwise_hash<int>
 {
 };

template<>
 struct hash<unsigned int>
  : public _Bitwise_hash<unsigned int>
 {
 };

template<>
 struct hash<long>
  : public _Bitwise_hash<long>
 {
 };

template<>
 struct hash<unsigned long>
  : public _Bitwise_hash<unsigned long>
 {
 };

template<>
 struct hash<long long>
  : public _Bitwise_hash<long long>
 {
 };

template<>
 struct hash<unsigned long long>
  : public _Bitwise_hash<unsigned long long>
 {
 };

template<>
 struct hash<float>
  : public _Bitwise_hash<float>
 {
 typedef float _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<double>
  : public _Bitwise_hash<double>
 {
 typedef double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<long double>
  : public _Bitwise_hash<long double>
 {
 typedef long double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<class _Ty>
 struct hash<_Ty *>
  : public _Bitwise_hash<_Ty *>
 {
 };
}
# 625 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstddef" 3
namespace std {

template<class _Ty> inline
 constexpr _Ty *addressof(_Ty& _Val) noexcept
 {
 return (__builtin_addressof(_Val));
 }


template<class _Ptrty> inline
 auto _Unfancy(_Ptrty _Ptr)
 {
 return (::std:: addressof(*_Ptr));
 }

template<class _Ty> inline
 _Ty * _Unfancy(_Ty * _Ptr)
 {
 return (_Ptr);
 }

}

#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



#pragma warning(disable: 4180)

namespace std {

template<class... _Types>
 struct _Arg_types
 {
 };

template<class _Ty1>
 struct _Arg_types<_Ty1>
 {
 typedef _Ty1 argument_type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Arg_types<_Ty1, _Ty2>
 {
 typedef _Ty1 first_argument_type;
 typedef _Ty2 second_argument_type;
 };


template<class _Ty>
 struct _Is_function
 {
 typedef false_type _Bool_type;
 };
# 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; };


template<class _Ty>
 struct is_function
  : _Is_function<_Ty>::_Bool_type
 {
 };

template<class _Ty>
 constexpr bool is_function_v = is_function<_Ty>::value;


template<class _Ty>
 struct _Is_memfunptr
 {
 typedef false_type _Bool_type;
 };
# 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };
# 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };



template<class _Ty>
 struct is_void
  : false_type
 {
 };
# 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<> struct is_void< void> : true_type { }; template<> struct is_void<const void> : true_type { }; template<> struct is_void<volatile void> : true_type { }; template<> struct is_void<const volatile void> : true_type { };



template<class... _Types>
 using void_t = void;



template<class _Ty>
 struct add_const
 {
 typedef const _Ty type;
 };


template<class _Ty>
 struct add_volatile
 {
 typedef volatile _Ty type;
 };


template<class _Ty>
 struct add_cv
 {
 typedef const volatile _Ty type;
 };


template<class _Ty,
 class = void>
 struct _Add_reference
 {
 typedef _Ty _Lvalue;
 typedef _Ty _Rvalue;
 };

template<class _Ty>
 struct _Add_reference<_Ty, void_t<_Ty&> >
 {
 typedef _Ty& _Lvalue;
 typedef _Ty&& _Rvalue;
 };


template<class _Ty>
 struct add_lvalue_reference
 {
 typedef typename _Add_reference<_Ty>::_Lvalue type;
 };


template<class _Ty>
 struct add_rvalue_reference
 {
 typedef typename _Add_reference<_Ty>::_Rvalue type;
 };


template<class _Ty>
 typename add_rvalue_reference<_Ty>::type
  declval() noexcept;


template<class _Ty>
 struct remove_extent
 {
 typedef _Ty type;
 };

template<class _Ty, size_t _Ix>
 struct remove_extent<_Ty[_Ix]>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_extent<_Ty[]>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_all_extents
 {
 typedef _Ty type;
 };

template<class _Ty, size_t _Ix>
 struct remove_all_extents<_Ty[_Ix]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };

template<class _Ty>
 struct remove_all_extents<_Ty[]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };


template<class _Ty>
 struct remove_pointer
 {
 typedef _Ty type;
 };
# 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };



template<class _Ty,
 class = void>
 struct _Add_pointer
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct _Add_pointer<_Ty, void_t<typename remove_reference<_Ty>::type *> >
 {
 typedef typename remove_reference<_Ty>::type * type;
 };

template<class _Ty>
 struct add_pointer
 {
 typedef typename _Add_pointer<_Ty>::type type;
 };



template<class _Ty>
 struct is_array
  : false_type
 {
 };

template<class _Ty, size_t _Nx>
 struct is_array<_Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_array<_Ty[]>
  : true_type
 {
 };


template<class _Ty>
 struct is_lvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_lvalue_reference<_Ty&>
  : true_type
 {
 };


template<class _Ty>
 struct is_rvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_rvalue_reference<_Ty&&>
  : true_type
 {
 };


template<class _Ty>
 struct is_reference
  : _Cat_base<is_lvalue_reference<_Ty>::value
  || is_rvalue_reference<_Ty>::value>
 {
 };



template<class _Ty,
 bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
 struct _Is_member_object_pointer
  : false_type
 {
 };

template<class _Ty1,
 class _Ty2>
 struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
  : true_type
 {
 typedef _Ty2 _Class_type;
 };

template<class _Ty>
 struct is_member_object_pointer
  : _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
 {
 };


template<class _Ty>
 struct is_member_function_pointer
  : _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
 {
 };


template<class _Ty>
 struct _Is_pointer
  : false_type
 {
 };

template<class _Ty>
 struct _Is_pointer<_Ty *>
  : _Cat_base<!is_member_object_pointer<_Ty *>::value
  && !is_member_function_pointer<_Ty *>::value>
 {
 };

template<class _Ty>
 struct is_pointer
  : _Is_pointer<typename remove_cv<_Ty>::type>
 {
 };



template<class _Ty>
 struct is_null_pointer
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };


template<class _Ty>
 struct is_union
  : _Cat_base<__is_union(_Ty)>
 {
 };


template<class _Ty>
 struct is_class
  : _Cat_base<__is_class(_Ty)>
 {
 };


template<class _Ty>
 struct is_fundamental
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_void<_Ty>::value
  || is_null_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_object
  : _Cat_base<!is_function<_Ty>::value
  && !is_reference<_Ty>::value
  && !is_void<_Ty>::value>
 {
 };



template<class _From,
 class _To>
 struct is_convertible
  : _Cat_base<__is_convertible_to(_From, _To)>
 {
 };


template<class _Ty>
 struct is_enum
  : _Cat_base<__is_enum(_Ty)>
 {
 };


template<class _Ty>
 struct is_compound
  : _Cat_base<!is_fundamental<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_member_pointer
  : _Cat_base<is_member_object_pointer<_Ty>::value
  || is_member_function_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_scalar
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_enum<_Ty>::value
  || is_pointer<_Ty>::value
  || is_member_pointer<_Ty>::value
  || is_null_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_const
  : false_type
 {
 };

template<class _Ty>
 struct is_const<const _Ty>
  : true_type
 {
 };


template<class _Ty>
 struct is_volatile
  : false_type
 {
 };

template<class _Ty>
 struct is_volatile<volatile _Ty>
  : true_type
 {
 };


template<class _Ty>
 struct is_pod
  : _Cat_base<__is_pod(_Ty)>
 {
 };


template<class _Ty>
 struct is_empty
  : _Cat_base<__is_empty(_Ty)>
 {
 };


template<class _Ty>
 struct is_polymorphic
  : _Cat_base<__is_polymorphic(_Ty)>
 {
 };


template<class _Ty>
 struct is_abstract
  : _Cat_base<__is_abstract(_Ty)>
 {
 };


template<class _Ty>
 struct is_final
  : _Cat_base<__is_final(_Ty)>
 {
 };


template<class _Ty>
 struct is_standard_layout
  : _Cat_base<__is_standard_layout(_Ty)>
 {
 };


template<class _Ty>
 struct is_literal_type
  : _Cat_base<__is_literal_type(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivial
  : _Cat_base<__is_trivial(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivially_copyable
  : _Cat_base<__is_trivially_copyable(_Ty)>
 {
 };


template<class _Ty>
 struct has_virtual_destructor
  : _Cat_base<__has_virtual_destructor(_Ty)>
 {
 };




template<class _Ty,
 class... _Args>
 struct is_constructible
  : _Cat_base<__is_constructible(_Ty, _Args...)>
 {
 };


template<class _Ty>
 struct is_copy_constructible
  : is_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_default_constructible
  : is_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_move_constructible
  : is_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _To,
 class _From>
 struct is_assignable
  : integral_constant<bool, __is_assignable(_To, _From)>
 {
 };


template<class _Ty>
 struct is_copy_assignable
  : is_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_move_assignable
  : is_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct is_destructible
  : _Cat_base<__is_destructible(_Ty)>
 {
 };




template<class _Ty,
 class... _Args>
 struct is_trivially_constructible
  : _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
 {
 };


template<class _Ty>
 struct is_trivially_copy_constructible
  : is_trivially_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_trivially_default_constructible
  : is_trivially_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_trivially_move_constructible
  : is_trivially_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _To,
 class _From>
 struct is_trivially_assignable
  : _Cat_base<__is_trivially_assignable(_To, _From)>
 {
 };


template<class _Ty>
 struct is_trivially_copy_assignable
  : is_trivially_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_trivially_move_assignable
  : is_trivially_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct is_trivially_destructible
  : _Cat_base<__has_trivial_destructor(_Ty)>
 {
 };




template<class _Ty,
 class... _Args>
 struct is_nothrow_constructible
  : _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
 {
 };


template<class _Ty>
 struct is_nothrow_copy_constructible
  : is_nothrow_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_nothrow_default_constructible
  : is_nothrow_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_nothrow_move_constructible
  : is_nothrow_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _To,
 class _From>
 struct is_nothrow_assignable
  : _Cat_base<__is_nothrow_assignable(_To, _From)>
 {
 };


template<class _Ty>
 struct is_nothrow_copy_assignable
  : is_nothrow_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct is_nothrow_move_assignable
  : is_nothrow_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct is_nothrow_destructible
  : _Cat_base<__is_nothrow_destructible(_Ty)>
 {
 };


#pragma warning(push)
#pragma warning(disable: 4296)
template<class _Ty,
 bool = is_integral<_Ty>::value>
 struct _Sign_base
 {
 typedef typename remove_cv<_Ty>::type _Uty;
 typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
 typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
 };
#pragma warning(pop)

template<class _Ty>
 struct _Sign_base<_Ty, false>
 {

 typedef is_floating_point<_Ty> _Signed;
 typedef false_type _Unsigned;
 };

template<class _Ty>
 struct is_signed
  : _Sign_base<_Ty>::_Signed
 {
 };


template<class _Ty>
 struct is_unsigned
  : _Sign_base<_Ty>::_Unsigned
 {
 };


template<class _Ty>
 struct _Change_sign
 {
 static_assert(
  ((is_integral<_Ty>::value || is_enum<_Ty>::value)
   && !is_same<_Ty, bool>::value),
  "make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
  "cv-qualified) integral type or enumeration but not a bool type.");

 typedef
  typename _If<is_same<_Ty, signed char>::value
   || is_same<_Ty, unsigned char >::value, signed char,
  typename _If<is_same<_Ty, short >::value
   || is_same<_Ty, unsigned short >::value, short,
  typename _If<is_same<_Ty, int >::value
   || is_same<_Ty, unsigned int >::value, int,
  typename _If<is_same<_Ty, long >::value
   || is_same<_Ty, unsigned long >::value, long,
  typename _If<is_same<_Ty, long long >::value
   || is_same<_Ty, unsigned long long>::value, long long,
  typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
  typename _If<sizeof (_Ty) == sizeof (short ), short,
  typename _If<sizeof (_Ty) == sizeof (int ), int,
  typename _If<sizeof (_Ty) == sizeof (long ), long,
   long long
  >::type>::type>::type>::type>::type>::type>::type>::type>::type
   _Signed;

 typedef
  typename _If<is_same<_Signed, signed char>::value, unsigned char,
  typename _If<is_same<_Signed, short >::value, unsigned short,
  typename _If<is_same<_Signed, int >::value, unsigned int,
  typename _If<is_same<_Signed, long >::value, unsigned long,
   unsigned long long
  >::type>::type>::type>::type
   _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const _Ty>
 {
 typedef const typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<volatile _Ty>
 {
 typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const volatile _Ty>
 {
 typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };


template<class _Ty>
 struct make_signed
 {
 typedef typename _Change_sign<_Ty>::_Signed type;
 };


template<class _Ty>
 struct make_unsigned
 {
 typedef typename _Change_sign<_Ty>::_Unsigned type;
 };



template<class _Ty>
 struct alignment_of
  : integral_constant<size_t, alignof(_Ty)>
 {
 };






template<class _Ty,
 size_t _Len>
 union _Align_type
 {
 _Ty _Val;
 char _Pad[_Len];
 };

template<size_t _Len,
 size_t _Align,
 class _Ty,
 bool _Ok>
 struct _Aligned;

template<size_t _Len,
 size_t _Align,
 class _Ty>
 struct _Aligned<_Len, _Align, _Ty, true>
 {
 typedef _Align_type<_Ty, _Len> type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, double, false>
 {
 typedef _Align_type<max_align_t, _Len> type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, int, false>
 {
 typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, short, false>
 {
 typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, char, false>
 {
 typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
 };

template<size_t _Len,
 size_t _Align = alignment_of<max_align_t>::value>
 struct aligned_storage
 {
 typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
 };





template<size_t... _Vals>
 struct _Maximum;

template<>
 struct _Maximum<>
 {
 static constexpr size_t value = 0;
 };

template<size_t _Val>
 struct _Maximum<_Val>
 {
 static constexpr size_t value = _Val;
 };

template<size_t _First,
 size_t _Second,
 size_t... _Rest>
 struct _Maximum<_First, _Second, _Rest...>
  : _Maximum<(_First < _Second ? _Second : _First), _Rest...>
 {
 };

template<size_t _Len,
 class... _Types>
 struct aligned_union
 {
 static constexpr size_t _Max_len = _Maximum<
  _Len, sizeof(_Types)...>::value;
 static constexpr size_t alignment_value = _Maximum<
  alignment_of<_Types>::value...>::value;
 typedef typename aligned_storage<_Max_len, alignment_value>::type type;
 };


template<class _Ty>
 struct underlying_type
 {
 typedef __underlying_type(_Ty) type;
 };


template<class _Ty>
 struct rank
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty, size_t _Ix>
 struct rank<_Ty[_Ix]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };

template<class _Ty>
 struct rank<_Ty[]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };


template<class _Ty, unsigned int _Nx>
 struct _Extent
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty, size_t _Ix>
 struct _Extent<_Ty[_Ix], 0>
  : integral_constant<size_t, _Ix>
 {
 };

template<class _Ty, unsigned int _Nx, size_t _Ix>
 struct _Extent<_Ty[_Ix], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct _Extent<_Ty[], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx = 0>
 struct extent
  : _Extent<_Ty, _Nx>
 {
 };


template<class _Base,
 class _Der>
 struct is_base_of
  : _Cat_base<__is_base_of(_Base, _Der)>
 {
 };


template<class _Ty>
 struct decay
 {
 typedef typename remove_reference<_Ty>::type _Ty1;

 typedef typename _If<is_array<_Ty1>::value,
  typename remove_extent<_Ty1>::type *,
  typename _If<is_function<_Ty1>::value,
   typename add_pointer<_Ty1>::type,
   typename remove_cv<_Ty1>::type>::type>::type type;
 };


template<class...>
 struct _Conjunction;

template<bool,
 class _Lhs,
 class... _Traits>
 struct _Choose_conjunction
 {
 typedef _Lhs type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Choose_conjunction<true, _Lhs, _Traits...>
 {
 typedef typename _Conjunction<_Traits...>::type type;
 };

template<>
 struct _Conjunction<>
 {
 typedef true_type type;
 };

template<class _Trait>
 struct _Conjunction<_Trait>
 {
 typedef _Trait type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Conjunction<_Lhs, _Traits...>
 {
 typedef typename _Choose_conjunction<_Lhs::value, _Lhs, _Traits...>::type type;
 };

template<class... _Traits>
 struct conjunction
  : _Conjunction<_Traits...>::type
 {


 };

template<class... _Traits>
 using _Conjunction_t = typename conjunction<_Traits...>::type;


template<class...>
 struct _Disjunction;

template<bool,
 class _Lhs,
 class... _Traits>
 struct _Choose_disjunction
 {
 typedef _Lhs type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Choose_disjunction<false, _Lhs, _Traits...>
 {
 typedef typename _Disjunction<_Traits...>::type type;
 };

template<>
 struct _Disjunction<>
 {
 typedef false_type type;
 };

template<class _Trait>
 struct _Disjunction<_Trait>
 {
 typedef _Trait type;
 };

template<class _Lhs,
 class... _Traits>
 struct _Disjunction<_Lhs, _Traits...>
 {
 typedef typename _Choose_disjunction<_Lhs::value, _Lhs, _Traits...>::type type;
 };

template<class... _Traits>
 struct disjunction
  : _Disjunction<_Traits...>::type
 {


 };

template<class... _Traits>
 using _Disjunction_t = typename disjunction<_Traits...>::type;


template<class _Trait>
 struct negation
  : bool_constant<!_Trait::value>
 {
 };
# 1235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class... _Ty>
 struct common_type;

template<class _Ty>
 struct common_type<_Ty>
 {
 typedef typename decay<_Ty>::type type;
 };

template<class _Ty0,
 class _Ty1>
 struct common_type<_Ty0, _Ty1>
 {
 typedef typename decay<
  decltype(_Always_false<_Ty0>::value
   ? ::std:: declval<_Ty0>()
   : ::std:: declval<_Ty1>())
 >::type type;
 };

template<class _Ty0,
 class _Ty1,
 class... _Ty>
 struct common_type<_Ty0, _Ty1, _Ty...>
 {
 typedef typename common_type<
  typename common_type<_Ty0, _Ty1>::type, _Ty...
 >::type type;
 };


template<class _Ty,
 _Ty... _Vals>
 struct integer_sequence
 {
 static_assert(is_integral<_Ty>::value,
  "integer_sequence<T, I...> requires T to be an integral type.");

 typedef _Ty value_type;

 static constexpr size_t size() noexcept
  {
  return (sizeof...(_Vals));
  }
 };


template<class _Ty,
 _Ty _Size>
 using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template<size_t... _Vals>
 using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
 using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
 using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 1310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ty>
 struct _Identity
 {
 using type = _Ty;
 };
template<class _Ty>
 using _Identity_t = typename _Identity<_Ty>::type;


template<class _Type,
 template <class...> class _Template>
 struct _Is_specialization
  : false_type
 {};
template<template <class...> class _Template,
 class... _Types>
 struct _Is_specialization<_Template<_Types...>, _Template>
  : true_type
 {};


template<class _Ty> inline
 constexpr _Ty&& forward(
  typename remove_reference<_Ty>::type& _Arg) noexcept
 {
 return (static_cast<_Ty&&>(_Arg));
 }

template<class _Ty> inline
 constexpr _Ty&& forward(
  typename remove_reference<_Ty>::type&& _Arg) noexcept
 {
 static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
 return (static_cast<_Ty&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename remove_reference<_Ty>::type&&
  move(_Ty&& _Arg) noexcept
 {
 return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
  && is_copy_constructible<_Ty>::value,
   const _Ty&, _Ty&&>::type
 move_if_noexcept(_Ty& _Arg) noexcept
 {
 return (::std:: move(_Arg));
 }

template<class _Ty>
 struct _Unrefwrap;
# 1534 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
struct _Invoker_pmf_object { template<class _Decayed, class _Ty1, class... _Types2> static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _Invoker_pmf_refwrap { template<class _Decayed, class _Ty1, class... _Types2> static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return ((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _Invoker_pmf_pointer { template<class _Decayed, class _Ty1, class... _Types2> static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _Invoker_pmd_object { template<class _Decayed, class _Ty1> static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return (::std:: forward<_Ty1>(_Arg1).*_Pmd); } }; struct _Invoker_pmd_refwrap { template<class _Decayed, class _Ty1> static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmd); } }; struct _Invoker_pmd_pointer { template<class _Decayed, class _Ty1> static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd); } }; struct _Invoker_functor { template<class _Callable, class... _Types> static auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return (::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)); } }; template<class _Callable, class _Ty1, class _Decayed = typename decay<_Callable>::type, bool _Is_pmf = is_member_function_pointer<_Decayed>::value, bool _Is_pmd = is_member_object_pointer<_Decayed>::value> struct _Invoker1; template<class _Callable, class _Ty1, class _Decayed> struct _Invoker1<_Callable, _Ty1, _Decayed, true, false> : _If<is_base_of< typename _Is_memfunptr<_Decayed>::_Class_type, typename decay<_Ty1>::type>::value, _Invoker_pmf_object, typename _If<_Unrefwrap<_Ty1>::_Is_refwrap, _Invoker_pmf_refwrap, _Invoker_pmf_pointer >::type>::type { }; template<class _Callable, class _Ty1, class _Decayed> struct _Invoker1<_Callable, _Ty1, _Decayed, false, true> : _If<is_base_of< typename _Is_member_object_pointer<_Decayed>::_Class_type, typename decay<_Ty1>::type>::value, _Invoker_pmd_object, typename _If<_Unrefwrap<_Ty1>::_Is_refwrap, _Invoker_pmd_refwrap, _Invoker_pmd_pointer >::type>::type { }; template<class _Callable, class _Ty1, class _Decayed> struct _Invoker1<_Callable, _Ty1, _Decayed, false, false> : _Invoker_functor { }; template<class _Callable, class... _Types> struct _Invoker; template<class _Callable> struct _Invoker<_Callable> : _Invoker_functor { }; template<class _Callable, class _Ty1, class... _Types2> struct _Invoker<_Callable, _Ty1, _Types2...> : _Invoker1<_Callable, _Ty1> { }; template<class _Callable, class... _Types> inline auto invoke(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept((_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)))) -> decltype(_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return (_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)); }



struct _C__Invoker_pmf_object { template<class _Decayed, class _Ty1, class... _Types2> static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _C__Invoker_pmf_refwrap { template<class _Decayed, class _Ty1, class... _Types2> static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return ((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _C__Invoker_pmf_pointer { template<class _Decayed, class _Ty1, class... _Types2> static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _C__Invoker_pmd_object { template<class _Decayed, class _Ty1> static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return (::std:: forward<_Ty1>(_Arg1).*_Pmd); } }; struct _C__Invoker_pmd_refwrap { template<class _Decayed, class _Ty1> static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmd); } }; struct _C__Invoker_pmd_pointer { template<class _Decayed, class _Ty1> static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd); } }; struct _C__Invoker_functor { template<class _Callable, class... _Types> static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return (::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)); } }; template<class _Callable, class _Ty1, class _Decayed = typename decay<_Callable>::type, bool _Is_pmf = is_member_function_pointer<_Decayed>::value, bool _Is_pmd = is_member_object_pointer<_Decayed>::value> struct _C__Invoker1; template<class _Callable, class _Ty1, class _Decayed> struct _C__Invoker1<_Callable, _Ty1, _Decayed, true, false> : _If<is_base_of< typename _Is_memfunptr<_Decayed>::_Class_type, typename decay<_Ty1>::type>::value, _C__Invoker_pmf_object, typename _If<_Unrefwrap<_Ty1>::_Is_refwrap, _C__Invoker_pmf_refwrap, _C__Invoker_pmf_pointer >::type>::type { }; template<class _Callable, class _Ty1, class _Decayed> struct _C__Invoker1<_Callable, _Ty1, _Decayed, false, true> : _If<is_base_of< typename _Is_member_object_pointer<_Decayed>::_Class_type, typename decay<_Ty1>::type>::value, _C__Invoker_pmd_object, typename _If<_Unrefwrap<_Ty1>::_Is_refwrap, _C__Invoker_pmd_refwrap, _C__Invoker_pmd_pointer >::type>::type { }; template<class _Callable, class _Ty1, class _Decayed> struct _C__Invoker1<_Callable, _Ty1, _Decayed, false, false> : _C__Invoker_functor { }; template<class _Callable, class... _Types> struct _C__Invoker; template<class _Callable> struct _C__Invoker<_Callable> : _C__Invoker_functor { }; template<class _Callable, class _Ty1, class... _Types2> struct _C__Invoker<_Callable, _Ty1, _Types2...> : _C__Invoker1<_Callable, _Ty1> { }; template<class _Callable, class... _Types> inline constexpr auto _C_invoke(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept((_C__Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)))) -> decltype(_C__Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return (_C__Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)); }




template<class _Rx,
 bool = is_void<_Rx>::value>
 struct _Invoker_ret
 {
 };

struct _Unforced
 {
 };

template<class _Cv_void>
 struct _Invoker_ret<_Cv_void, true>
 {
 template<class... _Valtys>
  static void _Call(_Valtys&&... _Vals)
  {
  ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
  }
 };

template<class _Rx>
 struct _Invoker_ret<_Rx, false>
 {
 template<class... _Valtys>
  static _Rx _Call(_Valtys&&... _Vals)
  {
  return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
  }
 };

template<>
 struct _Invoker_ret<_Unforced, false>
 {
 template<class... _Valtys>
  static auto _Call(_Valtys&&... _Vals)
  -> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))
  {
  return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
  }
 };


struct _Unique_tag_result_of
 {
 };

template<class _Void,
 class... _Types>
 struct _Result_of
 {
 };

template<class... _Types>
 struct _Result_of<
  void_t<
   _Unique_tag_result_of,
   decltype(::std:: invoke(::std:: declval<_Types>()...))>,
  _Types...>
 {
 typedef decltype(::std:: invoke(::std:: declval<_Types>()...)) type;
 };

template<class _Fty>
 struct result_of
 {
 static_assert(_Always_false<_Fty>::value,
  "result_of<CallableType> is invalid; use "
  "result_of<CallableType(zero or more argument types)> instead.");
 };
# 1621 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Callable, class... _Args> struct result_of<_Callable __cdecl (_Args...)> : _Result_of<void, _Callable, _Args...> { }; template<class _Callable, class... _Args> struct result_of<_Callable __vectorcall (_Args...)> : _Result_of<void, _Callable, _Args...> { };




template<bool _Was_void ,
 bool _Was_convertible ,
 class _Rx,
 class... _Types>
 struct _Is_callable2
  : true_type
 {

 static constexpr bool _Nothrow = noexcept(::std:: invoke(::std:: declval<_Types>()...));



 };

template<class _To>
 void _Implicitly_convert_to(_To) noexcept;

template<class _Rx,
 class... _Types>
 struct _Is_callable2<false, true, _Rx, _Types...>
  : true_type
 {

 static constexpr bool _Nothrow = noexcept(
  _Implicitly_convert_to<_Rx>(::std:: invoke(::std:: declval<_Types>()...)));



 };

template<class _Rx,
 class... _Types>
 struct _Is_callable2<false, false, _Rx, _Types...>
  : false_type
 {
 static constexpr bool _Nothrow = false;
 };

struct _Unique_tag_is_callable
 {
 };

template<class _Void,
 class _Rx,
 class... _Types>
 struct _Is_callable1
  : false_type
 {
 static constexpr bool _Nothrow = false;
 };

template<class _Rx,
 class... _Types>
 struct _Is_callable1<
  void_t<
   _Unique_tag_is_callable,
   decltype(::std:: invoke(::std:: declval<_Types>()...))>,
  _Rx,
  _Types...>
  : _Is_callable2<
   is_void<_Rx>::value,
   is_convertible<decltype(::std:: invoke(::std:: declval<_Types>()...)), _Rx>::value,
   _Rx, _Types...>
 {
 };



template<class _Fty,
 class _Rx = void>
 struct is_callable
 {
 static_assert(_Always_false<_Fty>::value,
  "is_callable<CallableType> is invalid; use "
  "is_callable<CallableType(zero or more argument types)> instead.");
 };
# 1712 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Callable, class... _Args, class _Rx> struct is_callable<_Callable __cdecl (_Args...), _Rx> : _Is_callable1<void, _Rx, _Callable, _Args...>::type { }; template<class _Callable, class... _Args, class _Rx> struct is_callable<_Callable __vectorcall (_Args...), _Rx> : _Is_callable1<void, _Rx, _Callable, _Args...>::type { };



template<class _Fty,
 class _Rx = void>
 struct is_nothrow_callable
 {
 static_assert(_Always_false<_Fty>::value,
  "is_nothrow_callable<CallableType> is invalid; use "
  "is_nothrow_callable<CallableType(zero or more argument types)> instead.");
 };
# 1734 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Callable, class... _Args, class _Rx> struct is_nothrow_callable<_Callable __cdecl (_Args...), _Rx> : bool_constant<_Is_callable1<void, _Rx, _Callable, _Args...>::_Nothrow> { }; template<class _Callable, class... _Args, class _Rx> struct is_nothrow_callable<_Callable __vectorcall (_Args...), _Rx> : bool_constant<_Is_callable1<void, _Rx, _Callable, _Args...>::_Nothrow> { };






template<class _Ty,
 class = void>
 struct _Weak_result_type
 {
 };

template<class _Ty>
 struct _Weak_result_type<_Ty, void_t<
  typename _Ty::result_type> >
 {
 typedef typename _Ty::result_type result_type;
 };

template<class _Ty,
 class = void>
 struct _Weak_argument_type
  : _Weak_result_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_argument_type<_Ty, void_t<
  typename _Ty::argument_type> >
  : _Weak_result_type<_Ty>
 {
 typedef typename _Ty::argument_type argument_type;
 };

template<class _Ty,
 class = void>
 struct _Weak_binary_args
  : _Weak_argument_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_binary_args<_Ty, void_t<
  typename _Ty::first_argument_type,
  typename _Ty::second_argument_type> >
  : _Weak_argument_type<_Ty>
 {
 typedef typename _Ty::first_argument_type first_argument_type;
 typedef typename _Ty::second_argument_type second_argument_type;
 };

template<class _Ty>
 struct _Weak_types
 {
 typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
 typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
 typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
  typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
  _Weak_binary_args<_Ty> >::type>::type type;
 };


template<class _Ty>
 class reference_wrapper
  : public _Weak_types<_Ty>::type
 {
public:
 static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
  "reference_wrapper<T> requires T to be an object type "
  "or a function type.");

 typedef _Ty type;

 reference_wrapper(_Ty& _Val) noexcept
  : _Ptr(::std:: addressof(_Val))
  {
  }

 operator _Ty&() const noexcept
  {
  return (*_Ptr);
  }

 _Ty& get() const noexcept
  {
  return (*_Ptr);
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
  }

 reference_wrapper(_Ty&&) = delete;

private:
 _Ty *_Ptr;
 };


template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(_Ty& _Val) noexcept
 {
 return (reference_wrapper<_Ty>(_Val));
 }

template<class _Ty>
 void ref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: ref(_Val.get()));
 }

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(const _Ty& _Val) noexcept
 {
 return (reference_wrapper<const _Ty>(_Val));
 }

template<class _Ty>
 void cref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: cref(_Val.get()));
 }


template<class _Ty>
 struct _Unrefwrap_helper
 {
 typedef _Ty type;
 static constexpr bool _Is_refwrap = false;
 };

template<class _Ty>
 struct _Unrefwrap_helper<reference_wrapper<_Ty> >
 {
 typedef _Ty& type;
 static constexpr bool _Is_refwrap = true;
 };

template<class _Ty>
 struct _Unrefwrap
 {
 typedef typename decay<_Ty>::type _Ty1;
 typedef typename _Unrefwrap_helper<_Ty1>::type type;
 static constexpr bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
 };
# 1904 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\type_traits" 3
template<class _Ty>
 struct _Is_swappable;


template<class _Ty>
 struct _Is_nothrow_swappable;



template<class _Ty,
 class = typename enable_if<is_move_constructible<_Ty>::value
  && is_move_assignable<_Ty>::value>::type> inline




 void swap(_Ty&, _Ty&)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);


template<class _Ty,
 size_t _Size,
 class = typename enable_if<_Is_swappable<_Ty>::value>::type> inline
 void swap(_Ty (&)[_Size], _Ty (&)[_Size])
  noexcept(_Is_nothrow_swappable<_Ty>::value);


template<class _Ty1,
 class _Ty2,
 class = void>
 struct _Swappable_with_helper
  : false_type
 {
 };

struct _Swappable_with_helper_unique_type {};
template<class _Ty1,
 class _Ty2>
 struct _Swappable_with_helper<_Ty1, _Ty2, void_t<
  _Swappable_with_helper_unique_type,
  decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
  : true_type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Is_swappable_with
  : _Conjunction_t<
   _Swappable_with_helper<_Ty1, _Ty2>,
   _Swappable_with_helper<_Ty2, _Ty1>>
 {

 };


template<class _Ty>
 struct _Is_swappable
  : _Is_swappable_with<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<_Ty>::type>::type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Swap_cannot_throw
  : bool_constant<

   noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
    && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))



   >
 {


 };


template<class _Ty1,
 class _Ty2>
 struct _Is_nothrow_swappable_with
  : _Conjunction_t<
   _Is_swappable_with<_Ty1, _Ty2>,
   _Swap_cannot_throw<_Ty1, _Ty2>>
 {

 };


template<class _Ty>
 struct _Is_nothrow_swappable
  : _Is_nothrow_swappable_with<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<_Ty>::type>::type
 {
 };



template<class _Ty1,
 class _Ty2>
 struct is_swappable_with
  : _Is_swappable_with<_Ty1, _Ty2>::type
 {

 };


template<class _Ty>
 struct is_swappable
  : _Is_swappable<_Ty>::type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct is_nothrow_swappable_with
  : _Is_nothrow_swappable_with<_Ty1, _Ty2>::type
 {

 };


template<class _Ty>
 struct is_nothrow_swappable
  : _Is_nothrow_swappable<_Ty>::type
 {
 };



template<class _Ty>
 using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
 using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
 using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
 using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
 using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
 using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
 using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
 using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
 using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
 using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
 using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
 using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
 using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
 using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
 using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
 size_t _Align = alignment_of<max_align_t>::value>
 using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
 class... _Types>
 using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
 using decay_t = typename decay<_Ty>::type;

template<bool _Test,
 class _Ty = void>
 using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
 class _Ty1,
 class _Ty2>
 using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
 using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
 using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
 using result_of_t = typename result_of<_Ty>::type;


template<class _Ty>
 constexpr bool is_void_v = is_void<_Ty>::value;
template<class _Ty>
 constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_array_v = is_array<_Ty>::value;
template<class _Ty>
 constexpr bool is_pointer_v = is_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
template<class _Ty>
 constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
template<class _Ty>
 constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_enum_v = is_enum<_Ty>::value;
template<class _Ty>
 constexpr bool is_union_v = is_union<_Ty>::value;
template<class _Ty>
 constexpr bool is_class_v = is_class<_Ty>::value;
template<class _Ty>
 constexpr bool is_reference_v = is_reference<_Ty>::value;
template<class _Ty>
 constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
template<class _Ty>
 constexpr bool is_object_v = is_object<_Ty>::value;
template<class _Ty>
 constexpr bool is_scalar_v = is_scalar<_Ty>::value;
template<class _Ty>
 constexpr bool is_compound_v = is_compound<_Ty>::value;
template<class _Ty>
 constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
template<class _Ty>
 constexpr bool is_const_v = is_const<_Ty>::value;
template<class _Ty>
 constexpr bool is_volatile_v = is_volatile<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivial_v = is_trivial<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Ty>::value;
template<class _Ty>
 constexpr bool is_standard_layout_v = is_standard_layout<_Ty>::value;
template<class _Ty>
 constexpr bool is_pod_v = is_pod<_Ty>::value;
template<class _Ty>
 constexpr bool is_literal_type_v = is_literal_type<_Ty>::value;
template<class _Ty>
 constexpr bool is_empty_v = is_empty<_Ty>::value;
template<class _Ty>
 constexpr bool is_polymorphic_v = is_polymorphic<_Ty>::value;
template<class _Ty>
 constexpr bool is_abstract_v = is_abstract<_Ty>::value;
template<class _Ty>
 constexpr bool is_final_v = is_final<_Ty>::value;
template<class _Ty>
 constexpr bool is_signed_v = is_signed<_Ty>::value;
template<class _Ty>
 constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
template<class _Ty,
 class... _Args>
 constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;
template<class _Ty>
 constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_move_constructible_v = is_move_constructible<_Ty>::value;
template<class _Ty,
 class _Uty>
 constexpr bool is_assignable_v = is_assignable<_Ty, _Uty>::value;
template<class _Ty>
 constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;

template<class _Ty1,
 class _Ty2>
 constexpr bool is_swappable_with_v = is_swappable_with<_Ty1, _Ty2>::value;
template<class _Ty>
 constexpr bool is_swappable_v = is_swappable<_Ty>::value;

template<class _Ty>
 constexpr bool is_destructible_v = is_destructible<_Ty>::value;
template<class _Ty,
 class... _Args>
 constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Ty, _Args...>::value;
template<class _Ty>
 constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Ty>::value;
template<class _Ty,
 class _Uty>
 constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Ty, _Uty>::value;
template<class _Ty>
 constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Ty>::value;
template<class _Ty,
 class... _Args>
 constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Ty, _Args...>::value;
template<class _Ty>
 constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;
template<class _Ty>
 constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Ty>::value;
template<class _Ty,
 class _Uty>
 constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Ty, _Uty>::value;
template<class _Ty>
 constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;
template<class _Ty>
 constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;

template<class _Ty1,
 class _Ty2>
 constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Ty1, _Ty2>::value;
template<class _Ty>
 constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Ty>::value;

template<class _Ty>
 constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Ty>::value;
template<class _Ty>
 constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Ty>::value;
template<class _Ty>
 constexpr size_t alignment_of_v = alignment_of<_Ty>::value;
template<class _Ty>
 constexpr size_t rank_v = rank<_Ty>::value;
template<class _Ty,
 unsigned int _Ix = 0>
 constexpr size_t extent_v = extent<_Ty, _Ix>::value;
template<class _Base,
 class _Derived>
 constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template<class _From,
 class _To>
 constexpr bool is_convertible_v = is_convertible<_From, _To>::value;

template<class _Fty,
 class _Rx = void>
 constexpr bool is_callable_v = is_callable<_Fty, _Rx>::value;
template<class _Fty,
 class _Rx = void>
 constexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fty, _Rx>::value;

template<class... _Traits>
 constexpr bool conjunction_v = conjunction<_Traits...>::value;
template<class... _Traits>
 constexpr bool disjunction_v = disjunction<_Traits...>::value;
template<class _Trait>
 constexpr bool negation_v = negation<_Trait>::value;

}


#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\exception" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
# 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\exception" 3
__declspec(dllimport) bool __cdecl uncaught_exception() noexcept;
__declspec(dllimport) int __cdecl uncaught_exceptions() noexcept;

}




# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
 extern "C" {
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
void* __cdecl _alloca( size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);


    __declspec(dllimport) int __cdecl _heapmin(void);


        __declspec(dllimport) int __cdecl _heapwalk( _HEAPINFO* _EntryInfo);



                       __declspec(dllimport) int __cdecl _heapchk(void);


    __declspec(dllimport) int __cdecl _resetstkoflw(void);
# 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
    typedef char __static_assert_t[(sizeof(unsigned int) <= 16) != 0];


#pragma warning(push)
#pragma warning(disable: 6540)

 __inline void* _MarkAllocaS( void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

#pragma warning(pop)
# 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
#pragma warning(push)
#pragma warning(disable: 6014)
 __inline void __cdecl _freea( void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }






        }
    }
#pragma warning(pop)
# 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
}
# 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h" 3
#pragma pack(pop)
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\exception" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_exception.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_exception.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\eh.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\eh.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3
 extern "C" {



typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();



        __declspec(dllimport) terminate_handler __cdecl set_terminate(
                     terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();





}
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\eh.h" 2 3




#pragma pack(push, 8)
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\eh.h" 3
 extern "C" {



typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;



    __declspec(dllimport) __declspec(noreturn) void __cdecl unexpected() throw(...);



        __declspec(dllimport) unexpected_handler __cdecl set_unexpected(
                     unexpected_handler _NewUnexpectedHandler
            ) throw();

        __declspec(dllimport) unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

        __declspec(dllimport) _se_translator_function __cdecl _set_se_translator(
                     _se_translator_function _NewSETranslator
            );



    class type_info;

    __declspec(dllimport) int __cdecl _is_exception_typeof(
             type_info const& _Type,
             _EXCEPTION_POINTERS* _ExceptionPtr
        );

    __declspec(dllimport) bool __cdecl __uncaught_exception();
    __declspec(dllimport) int __cdecl __uncaught_exceptions();



}
# 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\eh.h" 3
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_exception.h" 2 3






#pragma pack(push, 8)


#pragma pack(push, 8)
# 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_exception.h" 3
 extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool _DoFree;
};

__declspec(dllimport) void __cdecl __std_exception_copy(
          __std_exception_data const* _From,
          __std_exception_data* _To
    );

__declspec(dllimport) void __cdecl __std_exception_destroy(
            __std_exception_data* _Data
    );

}
# 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_exception.h" 3
#pragma pack(pop)



namespace std {

class exception
{
public:

    exception() throw()
        : _Data()
    {
    }

    explicit exception(char const* const _Message) throw()
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) throw()
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) throw()
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) throw()
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

}


#pragma pack(pop)
# 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\exception" 2 3


namespace std {

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);


inline terminate_handler __cdecl get_terminate() noexcept
 {
 return (_get_terminate());
 }

inline unexpected_handler __cdecl get_unexpected() noexcept
 {
 return (_get_unexpected());
 }


}
# 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\exception" 3
__declspec(dllimport) void __cdecl __ExceptionPtrCreate( void*);
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy( void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopy( void*, const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrAssign( void*, const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare( const void*, const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool( const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap( void*, void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException( void*);
[[noreturn]] __declspec(dllimport) void __cdecl __ExceptionPtrRethrow( const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(
         void*, const void*, const void*);

namespace std {

class exception_ptr
 {
public:
 exception_ptr() throw ()
  {
  __ExceptionPtrCreate(this);
  }

 exception_ptr(nullptr_t) throw ()
  {
  __ExceptionPtrCreate(this);
  }

 ~exception_ptr() throw ()
  {
  __ExceptionPtrDestroy(this);
  }

 exception_ptr(const exception_ptr& _Rhs) throw ()
  {
  __ExceptionPtrCopy(this, &_Rhs);
  }

 exception_ptr& operator=(const exception_ptr& _Rhs) throw ()
  {
  __ExceptionPtrAssign(this, &_Rhs);
  return *this;
  }

 exception_ptr& operator=(nullptr_t) throw ()
  {
  exception_ptr _Ptr;
  __ExceptionPtrAssign(this, &_Ptr);
  return *this;
  }

 explicit operator bool() const throw ()
  {
  return __ExceptionPtrToBool(this);
  }

 [[noreturn]] void _RethrowException() const
  {
  __ExceptionPtrRethrow(this);
  }

 static exception_ptr _Current_exception() throw ()
  {
  exception_ptr _Retval;
  __ExceptionPtrCurrentException(&_Retval);
  return _Retval;
  }

 static exception_ptr _Copy_exception( void* _Except, const void* _Ptr)
  {
  exception_ptr _Retval = 0;
  if (!_Ptr)
   {

   return _Retval;
   }
  __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
  return _Retval;
  }

private:




 void* _Data1;
 void* _Data2;



 };

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) throw ()
 {
 __ExceptionPtrSwap(&_Lhs, &_Rhs);
 }

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
 {
 return __ExceptionPtrCompare(&_Lhs, &_Rhs);
 }

inline bool operator==(nullptr_t, const exception_ptr& _Rhs) throw ()
 {
 return !_Rhs;
 }

inline bool operator==(const exception_ptr& _Lhs, nullptr_t) throw ()
 {
 return !_Lhs;
 }

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
 {
 return !(_Lhs == _Rhs);
 }

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) throw ()
 {
 return !(_Lhs == _Rhs);
 }

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) throw ()
 {
 return !(_Lhs == _Rhs);
 }

inline exception_ptr current_exception() noexcept
 {
 return exception_ptr::_Current_exception();
 }

[[noreturn]] inline void rethrow_exception( exception_ptr _Ptr)
 {
 _Ptr._RethrowException();
 }

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> exception_ptr make_exception_ptr(_Ex _Except) noexcept
 {
 return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
 }


class nested_exception
 {
public:
 nested_exception() noexcept
  : _Exc(::std:: current_exception())
  {
  }

 nested_exception(const nested_exception&) noexcept = default;
 nested_exception& operator=(const nested_exception&) noexcept = default;
 virtual ~nested_exception() noexcept = default;

 [[noreturn]] void rethrow_nested() const
  {
  if (_Exc)
   ::std:: rethrow_exception(_Exc);
  else
   ::std:: terminate();
  }

 exception_ptr nested_ptr() const noexcept
  {
  return (_Exc);
  }

private:
 exception_ptr _Exc;
 };


template<class _Ty,
 class _Uty>
 struct _With_nested
  : _Uty, nested_exception
 {
 explicit _With_nested(_Ty&& _Arg)
  : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
  {
  }
 };

template<class _Ty>
 [[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type)
 {
 typedef typename remove_reference<_Ty>::type _Uty;
 typedef _With_nested<_Ty, _Uty> _Glued;

 throw _Glued(::std:: forward<_Ty>(_Arg));
 }

template<class _Ty>
 [[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type)
 {
 typedef typename decay<_Ty>::type _Decayed;

 throw _Decayed(::std:: forward<_Ty>(_Arg));
 }

template<class _Ty>
 [[noreturn]] inline void throw_with_nested(_Ty&& _Arg)
 {
 typedef typename remove_reference<_Ty>::type _Uty;

 integral_constant<bool,
  is_class<_Uty>::value
  && !is_base_of<nested_exception, _Uty>::value
  && !is_final<_Uty>::value> _Tag;

 _Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
 }


template<class _Ty> inline
 void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
 {
 const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

 if (_Nested)
  _Nested->rethrow_nested();
 }

template<class _Ty> inline
 void _Rethrow_if_nested(const _Ty *, false_type)
 {
 }

template<class _Ty> inline
 void rethrow_if_nested(const _Ty& _Arg)
 {
 integral_constant<bool,
  is_polymorphic<_Ty>::value
  && (!is_base_of<nested_exception, _Ty>::value
   || is_convertible<_Ty *, nested_exception *>::value)> _Tag;

 _Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\iosfwd" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdio" 1 3





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma pack(push, 8)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
 extern "C" {
# 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
# 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
 __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }




    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
# 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
}
# 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 2 3


#pragma pack(push, 8)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
 extern "C" {
# 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) wint_t __cdecl fgetwc(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);


    __declspec(dllimport) wint_t __cdecl fputwc(
                wchar_t _Character,
                FILE* _Stream);


    __declspec(dllimport) wint_t __cdecl _fputwchar(
             wchar_t _Character
        );


    __declspec(dllimport) wint_t __cdecl getwc(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl getwchar(void);




    __declspec(dllimport) wchar_t* __cdecl fgetws(
                                     wchar_t* _Buffer,
                                     int _BufferCount,
                                     FILE* _Stream
        );


    __declspec(dllimport) int __cdecl fputws(
                wchar_t const* _Buffer,
                FILE* _Stream
        );



    __declspec(dllimport) wchar_t* __cdecl _getws_s(
                                     wchar_t* _Buffer,
                                     size_t _BufferCount
        );

    extern "C++" { template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }






    __declspec(dllimport) wint_t __cdecl putwc(
                wchar_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl putwchar(
             wchar_t _Character
        );


    __declspec(dllimport) int __cdecl _putws(
               wchar_t const* _Buffer
        );


    __declspec(dllimport) wint_t __cdecl ungetwc(
                wint_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) FILE * __cdecl _wfdopen(
               int _FileHandle,
               wchar_t const* _Mode
        );

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
               wchar_t const* _FileName,
               wchar_t const* _Mode
        );


    __declspec(dllimport) errno_t __cdecl _wfopen_s(
                                  FILE** _Stream,
                                  wchar_t const* _FileName,
                                  wchar_t const* _Mode
        );


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
                wchar_t const* _FileName,
                wchar_t const* _Mode,
                FILE* _OldStream
        );


    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
                                  FILE** _Stream,
                                  wchar_t const* _FileName,
                                  wchar_t const* _Mode,
                                  FILE* _OldStream
        );


    __declspec(dllimport) FILE* __cdecl _wfsopen(
               wchar_t const* _FileName,
               wchar_t const* _Mode,
               int _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
                   wchar_t const* _ErrorMessage
        );




        __declspec(dllimport) FILE* __cdecl _wpopen(
                   wchar_t const* _Command,
                   wchar_t const* _Mode
            );



    __declspec(dllimport) int __cdecl _wremove(
               wchar_t const* _FileName
        );





    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
                   wchar_t const* _Directory,
                   wchar_t const* _FilePrefix
        );





    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
                                     wchar_t* _Buffer,
                                     size_t _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }





    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);
# 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
                wchar_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
                wchar_t _Character,
                FILE* _Stream
        );


    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
                wint_t _Character,
                FILE* _Stream
        );
# 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __inline int __cdecl _vfwprintf_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfwprintf(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vfwprintf_s_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vfwprintf_s(
                                          FILE* const _Stream,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }





    __inline int __cdecl _vfwprintf_p_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vfwprintf_p(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vwprintf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }



    __inline int __cdecl _vwprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vwprintf_s(
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }





    __inline int __cdecl _vwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vwprintf_p(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }



    __inline int __cdecl _fwprintf_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl fwprintf(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _fwprintf_s_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl fwprintf_s(
                                          FILE* const _Stream,
                                          wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }





    __inline int __cdecl _fwprintf_p_l(
                                                FILE* const _Stream,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _fwprintf_p(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _wprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl wprintf(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _wprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl wprintf_s(
                                          wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }





    __inline int __cdecl _wprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _wprintf_p(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                               unsigned __int64 _Options,
                                               FILE* _Stream,
                                               wchar_t const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );


    __inline int __cdecl _vfwscanf_l(
                FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfwscanf(
                FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vfwscanf_s_l(
                                      FILE* const _Stream,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vfwscanf_s(
                                          FILE* const _Stream,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }




    __inline int __cdecl _vwscanf_l(
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vwscanf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }



    __inline int __cdecl _vwscanf_s_l(
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vwscanf_s(
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                               FILE* const _Stream,
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                                     FILE* const _Stream,
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _fwscanf_s_l(
                                                 FILE* const _Stream,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl fwscanf_s(
                                           FILE* const _Stream,
                                           wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _wscanf_s_l(
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl wscanf_s(
                                           wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
# 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );



    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );



    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                size_t _MaxCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );



    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                                unsigned __int64 _Options,
                                                wchar_t* _Buffer,
                                                size_t _BufferCount,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
                                                     wchar_t* const _Buffer,
                                                     size_t const _BufferCount,
                                                     wchar_t const* const _Format,
                                                     _locale_t const _Locale,
                                                     va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


#pragma warning(push)
#pragma warning(disable: 4793)



 __inline int __cdecl _vsnwprintf_s_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnwprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);








#pragma warning(pop)


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
                                                     wchar_t* _Buffer,
                                                     size_t _BufferCount,
                                                     wchar_t const* _Format,
                                                     va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)
 }


    extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
# 1150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _vswprintf_c_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vswprintf_c(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }




    __inline int __cdecl _vswprintf_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)
 }




    __inline int __cdecl __vswprintf_l(
                                                wchar_t* const _Buffer,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




    __inline int __cdecl _vswprintf(
                                         wchar_t* const _Buffer,
                                         wchar_t const* const _Format,
                                         va_list _ArgList
        )



    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }




    __inline int __cdecl vswprintf(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }




    __inline int __cdecl _vswprintf_s_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }





        __inline int __cdecl vswprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          va_list _ArgList
            )



        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }




    extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
# 1302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _vswprintf_p_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vswprintf_p(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      va_list _ArgList
        )



    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }




    __inline int __cdecl _vscwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vscwprintf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }




    __inline int __cdecl _vscwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vscwprintf_p(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }




    __inline int __cdecl __swprintf_l(
                                                wchar_t* const _Buffer,
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _swprintf_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _swprintf(
                                         wchar_t* const _Buffer,
                                         wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl swprintf(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


#pragma warning(push)


#pragma warning(disable: 4793 4996)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);
# 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






#pragma warning(pop)



 __inline int __cdecl _swprintf_s_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl swprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }




    extern "C++" {
# 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(push)
# 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
;
# 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(disable: 4793)
# 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
; template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); }
# 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(pop)
# 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
; }
# 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _swprintf_p_l(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _swprintf_p(
                                                      wchar_t* const _Buffer,
                                                      size_t const _BufferCount,
                                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _swprintf_c_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _swprintf_c(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
                                                     wchar_t* const _Buffer,
                                                     size_t const _BufferCount,
                                                     wchar_t const* const _Format,
                                                     _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snwprintf(
                                                     wchar_t* _Buffer,
                                                     size_t _BufferCount,
                                                     wchar_t const* _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snwprintf_s_l(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snwprintf_s(
                                                          wchar_t* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    extern "C++" {
# 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(push)
# 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
;
# 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(disable: 4793)
# 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
; template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
# 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma warning(pop)
# 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
; }
# 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
    __inline int __cdecl _scwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _scwprintf(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _scwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _scwprintf_p(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




#pragma warning(push)
#pragma warning(disable: 4141 4412 4793 4996 6054)



 extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                                              wchar_t* const _Buffer,
                                              wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
#pragma warning(suppress: 28719)
 _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                                              wchar_t* const _Buffer,
                                              wchar_t const* const _Format,
                                              va_list _ArgList
                ) throw()
            {
#pragma warning(suppress: 28719)
 return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                                        wchar_t* const _Buffer,
                                                        wchar_t const* const _Format,
                                                        _locale_t const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                                        wchar_t* const _Buffer,
                                                        wchar_t const* const _Format,
                                                        _locale_t const _Locale,
                                                        va_list _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }



#pragma warning(pop)
# 1892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
 __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                               unsigned __int64 _Options,
                                               wchar_t const* _Buffer,
                                               size_t _BufferCount,
                                               wchar_t const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );



    __inline int __cdecl _vswscanf_l(
                                      wchar_t const* const _Buffer,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




    __inline int __cdecl vswscanf(
                                      wchar_t const* _Buffer,
                                      wchar_t const* _Format,
                                      va_list _ArgList
        )



    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }




    __inline int __cdecl _vswscanf_s_l(
                                      wchar_t const* const _Buffer,
                                      wchar_t const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }






        __inline int __cdecl vswscanf_s(
                                          wchar_t const* const _Buffer,
                                          wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }




    extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
# 1980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                                               wchar_t const* const _Buffer,
                                               size_t const _BufferCount,
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }




    __inline int __cdecl _vsnwscanf_s_l(
                                                 wchar_t const* const _Buffer,
                                                 size_t const _BufferCount,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
                                                 va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                               wchar_t const* const _Buffer,
                                               wchar_t const* const _Format,
                                               _locale_t _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                     wchar_t const* const _Buffer,
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _swscanf_s_l(
                                                 wchar_t const* const _Buffer,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






        __inline int __cdecl swscanf_s(
                                           wchar_t const* const _Buffer,
                                           wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }





                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                                               wchar_t const* const _Buffer,
                                               size_t const _BufferCount,
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
                                         wchar_t const* const _Buffer,
                                         size_t const _BufferCount,
                                         wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snwscanf_s_l(
                                                 wchar_t const* const _Buffer,
                                                 size_t const _BufferCount,
                                                 wchar_t const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snwscanf_s(
                                          wchar_t const* const _Buffer,
                                          size_t const _BufferCount,
                                          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 2198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
}
# 2198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
 extern "C" {
# 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
typedef __int64 fpos_t;






    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
                  FILE* _Stream,
                  char*** _Base,
                  char*** _Pointer,
                  int** _Count
        );
# 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        __declspec(dllimport) errno_t __cdecl clearerr_s(
                    FILE* _Stream
            );


        __declspec(dllimport) errno_t __cdecl fopen_s(
                                      FILE** _Stream,
                                      char const* _FileName,
                                      char const* _Mode
            );



        __declspec(dllimport) size_t __cdecl fread_s(
                                                                               void* _Buffer,
                                                                               size_t _BufferSize,
                                                                               size_t _ElementSize,
                                                                               size_t _ElementCount,
                                                                               FILE* _Stream
            );


        __declspec(dllimport) errno_t __cdecl freopen_s(
                                      FILE** _Stream,
                                      char const* _FileName,
                                      char const* _Mode,
                                      FILE* _OldStream
            );


        __declspec(dllimport) char* __cdecl gets_s(
                                  char* _Buffer,
                                  rsize_t _Size
            );


        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                                         FILE** _Stream
            );



        __declspec(dllimport) errno_t __cdecl tmpnam_s(
                                  char* _Buffer,
                                  rsize_t _Size
            );



    __declspec(dllimport) void __cdecl clearerr(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl fclose(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fcloseall(void);


    __declspec(dllimport) FILE* __cdecl _fdopen(
               int _FileHandle,
               char const* _Mode
        );


    __declspec(dllimport) int __cdecl feof(
             FILE* _Stream
        );


    __declspec(dllimport) int __cdecl ferror(
             FILE* _Stream
        );


    __declspec(dllimport) int __cdecl fflush(
                    FILE* _Stream
        );



    __declspec(dllimport) int __cdecl fgetc(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fgetchar(void);



    __declspec(dllimport) int __cdecl fgetpos(
                FILE* _Stream,
                fpos_t* _Position
        );



    __declspec(dllimport) char* __cdecl fgets(
                                  char* _Buffer,
                                  int _MaxCount,
                                  FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fileno(
             FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _flushall(void);

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
               char const* _FileName,
               char const* _Mode
        );




    __declspec(dllimport) int __cdecl fputc(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fputchar(
             int _Character
        );



    __declspec(dllimport) int __cdecl fputs(
                char const* _Buffer,
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl fread(
                                                         void* _Buffer,
                                                         size_t _ElementSize,
                                                         size_t _ElementCount,
                                                         FILE* _Stream
        );


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
                char const* _FileName,
                char const* _Mode,
                FILE* _Stream
        );


    __declspec(dllimport) FILE* __cdecl _fsopen(
               char const* _FileName,
               char const* _Mode,
               int _ShFlag
        );



    __declspec(dllimport) int __cdecl fsetpos(
                FILE* _Stream,
                fpos_t const* _Position
        );



    __declspec(dllimport) int __cdecl fseek(
                FILE* _Stream,
                long _Offset,
                int _Origin
        );



    __declspec(dllimport) int __cdecl _fseeki64(
                FILE* _Stream,
                __int64 _Offset,
                int _Origin
        );



    __declspec(dllimport) long __cdecl ftell(
                FILE* _Stream
        );



    __declspec(dllimport) __int64 __cdecl _ftelli64(
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl fwrite(
                                                       void const* _Buffer,
                                                       size_t _ElementSize,
                                                       size_t _ElementCount,
                                                       FILE* _Stream
        );



    __declspec(dllimport) int __cdecl getc(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl getchar(void);


    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }




    __declspec(dllimport) int __cdecl _getw(
                FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
                   char const* _ErrorMessage
        );





        __declspec(dllimport) int __cdecl _pclose(
                    FILE* _Stream
            );


        __declspec(dllimport) FILE* __cdecl _popen(
                   char const* _Command,
                   char const* _Mode
            );





    __declspec(dllimport) int __cdecl putc(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl putchar(
             int _Character
        );


    __declspec(dllimport) int __cdecl puts(
               char const* _Buffer
        );



    __declspec(dllimport) int __cdecl _putw(
                int _Word,
                FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
               char const* _FileName
        );


    __declspec(dllimport) int __cdecl rename(
               char const* _OldFileName,
               char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
               char const* _FileName
        );



        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
                   char const* _FileName
            );



    __declspec(dllimport) void __cdecl rewind(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                            FILE* _Stream,
                                                            char* _Buffer
        );


    __declspec(dllimport) int __cdecl _setmaxstdio(
             int _Maximum
        );



    __declspec(dllimport) int __cdecl setvbuf(
                                     FILE* _Stream,
                                     char* _Buffer,
                                     int _Mode,
                                     size_t _Size
        );







    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
                   char const* _DirectoryName,
                   char const* _FilePrefix
        );





                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }





#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl tmpnam( char *_Buffer);




#pragma warning(pop)



 __declspec(dllimport) int __cdecl ungetc(
                int _Character,
                FILE* _Stream
        );
# 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) void __cdecl _lock_file(
                FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fclose_nolock(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fflush_nolock(
                    FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fgetc_nolock(
                FILE* _Stream
        );



    __declspec(dllimport) int __cdecl _fputc_nolock(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl _fread_nolock(
                                                         void* _Buffer,
                                                         size_t _ElementSize,
                                                         size_t _ElementCount,
                                                         FILE* _Stream
        );



    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
                                                                         void* _Buffer,
                                                                         size_t _BufferSize,
                                                                         size_t _ElementSize,
                                                                         size_t _ElementCount,
                                                                         FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _fseek_nolock(
                FILE* _Stream,
                long _Offset,
                int _Origin
        );


    __declspec(dllimport) int __cdecl _fseeki64_nolock(
                FILE* _Stream,
                __int64 _Offset,
                int _Origin
        );


    __declspec(dllimport) long __cdecl _ftell_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
                                                       void const* _Buffer,
                                                       size_t _ElementSize,
                                                       size_t _ElementCount,
                                                       FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _getc_nolock(
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _putc_nolock(
                int _Character,
                FILE* _Stream
        );


    __declspec(dllimport) int __cdecl _ungetc_nolock(
                int _Character,
                FILE* _Stream
        );
# 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int* __cdecl __p__commode(void);
# 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                                unsigned __int64 _Options,
                                                FILE* _Stream,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __inline int __cdecl _vfprintf_l(
                 FILE* const _Stream,
                 char const* const _Format,
                 _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfprintf(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vfprintf_s_l(
                 FILE* const _Stream,
                 char const* const _Format,
                 _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vfprintf_s(
                                          FILE* const _Stream,
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }





    __inline int __cdecl _vfprintf_p_l(
                 FILE* const _Stream,
                 char const* const _Format,
                 _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vfprintf_p(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vprintf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vprintf(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }



    __inline int __cdecl _vprintf_s_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vprintf_s(
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }





    __inline int __cdecl _vprintf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vprintf_p(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }



    __inline int __cdecl _fprintf_l(
                                                FILE* const _Stream,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl fprintf(
                                      FILE* const _Stream,
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    __declspec(dllimport) int __cdecl _set_printf_count_output(
             int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);


    __inline int __cdecl _fprintf_s_l(
                                                FILE* const _Stream,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl fprintf_s(
                                          FILE* const _Stream,
                                          char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }





    __inline int __cdecl _fprintf_p_l(
                                                FILE* const _Stream,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _fprintf_p(
                                      FILE* const _Stream,
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _printf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl printf(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _printf_s_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl printf_s(
                                          char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }





    __inline int __cdecl _printf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _printf_p(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 1042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                               unsigned __int64 _Options,
                                               FILE* _Stream,
                                               char const* _Format,
                                               _locale_t _Locale,
                                               va_list _Arglist
        );


    __inline int __cdecl _vfscanf_l(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vfscanf(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vfscanf_s_l(
                                      FILE* const _Stream,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }






        __inline int __cdecl vfscanf_s(
                                          FILE* const _Stream,
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }





    __inline int __cdecl _vscanf_l(
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vscanf(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }



    __inline int __cdecl _vscanf_s_l(
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }





        __inline int __cdecl vscanf_s(
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                               FILE* const _Stream,
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                                     FILE* const _Stream,
                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _fscanf_s_l(
                                                 FILE* const _Stream,
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl fscanf_s(
                                           FILE* const _Stream,
                                           char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }




                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _scanf_s_l(
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl scanf_s(
                                           char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
# 1335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                size_t _MaxCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                                unsigned __int64 _Options,
                                                char* _Buffer,
                                                size_t _BufferCount,
                                                char const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
                                                     char* const _Buffer,
                                                     size_t const _BufferCount,
                                                     char const* const _Format,
                                                     _locale_t const _Locale,
                                                     va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnprintf(
                                                     char* const _Buffer,
                                                    size_t const _BufferCount,
                                                    char const* const _Format,
                                                    va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)
 }
# 1428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl vsnprintf(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
                                         char* const _Buffer,
                                         char const* const _Format,
                                         _locale_t const _Locale,
                                         va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
#pragma warning(pop)
 }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
                                         char* const _Buffer,
                                         char const* const _Format,
                                         va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
#pragma warning(pop)
 }




    __inline int __cdecl _vsprintf_s_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }






        __inline int __cdecl vsprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
                                                          va_list _ArgList
            )



        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }


        extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
# 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _vsprintf_p_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsprintf_p(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      va_list _ArgList
        )



    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }




    __inline int __cdecl _vsnprintf_s_l(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
                                                          _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }


    extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
# 1621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
        __inline int __cdecl vsnprintf_s(
                                                              char* const _Buffer,
                                                              size_t const _BufferCount,
                                                              size_t const _MaxCount,
                                                              char const* const _Format,
                                                              va_list _ArgList
            )



        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }


        extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
# 1648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _vscprintf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }



    __inline int __cdecl _vscprintf(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _vscprintf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }



    __inline int __cdecl _vscprintf_p(
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _vsnprintf_c_l(
                                                char* const _Buffer,
                                                size_t const _BufferCount,
                                                char const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




    __inline int __cdecl _vsnprintf_c(
                                       char* const _Buffer,
                                       size_t const _BufferCount,
                                       char const* const _Format,
                                       va_list _ArgList
        )



    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                                                char* const _Buffer,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl sprintf(
                                         char* const _Buffer,
                                         char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }


#pragma warning(push)
#pragma warning(disable: 4996)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl sprintf( char *_Buffer, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl vsprintf( char *_Buffer, char const* _Format, va_list _Args);





#pragma warning(pop)



 __inline int __cdecl _sprintf_s_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






        __inline int __cdecl sprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }




    extern "C++" {
# 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma warning(push)
# 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
;
# 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma warning(disable: 4793)
# 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
; template <size_t _Size> inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); }
# 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma warning(pop)
# 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
; }
# 1860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _sprintf_p_l(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
                                                      _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _sprintf_p(
                                                      char* const _Buffer,
                                                      size_t const _BufferCount,
                                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
                                                     char* const _Buffer,
                                                     size_t const _BufferCount,
                                                     char const* const _Format,
                                                     _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 1938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl snprintf(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
#pragma warning(suppress: 28719)
 _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snprintf(
                                                     char* const _Buffer,
                                                     size_t const _BufferCount,
                                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
#pragma warning(suppress: 28719)
 _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int __cdecl _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);
# 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _snprintf_c_l(
                                                char* const _Buffer,
                                                size_t const _BufferCount,
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snprintf_c(
                                       char* const _Buffer,
                                       size_t const _BufferCount,
                                       char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snprintf_s_l(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
                                                          _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snprintf_s(
                                                          char* const _Buffer,
                                                          size_t const _BufferCount,
                                                          size_t const _MaxCount,
                                                          char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    extern "C++" {
# 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma warning(push)
# 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
;
# 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma warning(disable: 4793)
# 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
; template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
# 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma warning(pop)
# 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
; }
# 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
    __inline int __cdecl _scprintf_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _scprintf(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _scprintf_p_l(
                                                char const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _scprintf_p(
                                      char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }







    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                               unsigned __int64 _Options,
                                               char const* _Buffer,
                                               size_t _BufferCount,
                                               char const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );


    __inline int __cdecl _vsscanf_l(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }



    __inline int __cdecl vsscanf(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }



    __inline int __cdecl _vsscanf_s_l(
                                      char const* const _Buffer,
                                      char const* const _Format,
                                      _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




#pragma warning(push)
#pragma warning(disable: 6530)


 __inline int __cdecl vsscanf_s(
                                          char const* const _Buffer,
                                          char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }


        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }






#pragma warning(pop)



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                               char const* const _Buffer,
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                     char const* const _Buffer,
                                     char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _sscanf_s_l(
                                                 char const* const _Buffer,
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





        __inline int __cdecl sscanf_s(
                                           char const* const _Buffer,
                                           char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = vsscanf_s(_Buffer, _Format, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
            return _Result;
        }




#pragma warning(push)
#pragma warning(disable: 6530)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
                                               char const* const _Buffer,
                                               size_t const _BufferCount,
                                               char const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
                                               char const* const _Buffer,
                                               size_t const _BufferCount,
                                               char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    __inline int __cdecl _snscanf_s_l(
                                                 char const* const _Buffer,
                                                 size_t const _BufferCount,
                                                 char const* const _Format,
                                                 _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _snscanf_s(
                                               char const* const _Buffer,
                                               size_t const _BufferCount,
                                               char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


#pragma warning(pop)
# 2444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
                       char const* _Directory,
                       char const* _FilePrefix
            );





                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport) FILE* __cdecl fdopen( int _FileHandle, char const* _Format);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport) int __cdecl fileno( FILE* _Stream);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar( int _Ch);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport) int __cdecl getw( FILE* _Stream);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport) int __cdecl putw( int _Ch, FILE* _Stream);
                           __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);






}
# 2469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h" 3
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdio" 2 3
# 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdio" 3
typedef FILE FILE;


namespace std {
using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\iosfwd" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstring" 1 3





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 1 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3
 extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);


    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);


    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3
}
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 2 3




#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 3
 extern "C" {




__declspec(dllimport) void const* __cdecl memchr(
                                    void const* _Buf,
                                    int _Val,
                                    size_t _MaxCount
    );


int __cdecl memcmp(
                            void const* _Buf1,
                            void const* _Buf2,
                            size_t _Size
    );
# 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 3
void* __cdecl memcpy(
                                  void* _Dst,
                                  void const* _Src,
                                  size_t _Size
    );


__declspec(dllimport) void* __cdecl memmove(
                                      void* _Dst,
                                      void const* _Src,
                                      size_t _Size
    );
# 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 3
void* __cdecl memset(
                                  void* _Dst,
                                  int _Val,
                                  size_t _Size
    );


__declspec(dllimport) char const* __cdecl strchr(
           char const* _Str,
           int _Val
    );


__declspec(dllimport) char const* __cdecl strrchr(
           char const* _Str,
           int _Ch
    );


__declspec(dllimport) char const* __cdecl strstr(
           char const* _Str,
           char const* _SubStr
    );



__declspec(dllimport) wchar_t const* __cdecl wcschr(
           wchar_t const* _Str,
           wchar_t _Ch
    );


__declspec(dllimport) wchar_t const* __cdecl wcsrchr(
           wchar_t const* _Str,
           wchar_t _Ch
    );



__declspec(dllimport) wchar_t const* __cdecl wcsstr(
           wchar_t const* _Str,
           wchar_t const* _SubStr
    );



}
# 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_string.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
 extern "C" {
# 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
    static __inline errno_t __cdecl memcpy_s(
                                                                 void* const _Destination,
                                                                 rsize_t const _DestinationSize,
                                                                 void const* const _Source,
                                                                 rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };


            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }


    static __inline errno_t __cdecl memmove_s(
                                                                 void* const _Destination,
                                                                 rsize_t const _DestinationSize,
                                                                 void const* const _Source,
                                                                 rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }





}
# 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h" 3
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 2 3





#pragma pack(push, 8)
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
 extern "C" {




__declspec(dllimport) int __cdecl _memicmp(
                                void const* _Buf1,
                                void const* _Buf2,
                                size_t _Size
    );


__declspec(dllimport) int __cdecl _memicmp_l(
                                void const* _Buf1,
                                void const* _Buf2,
                                size_t _Size,
                                _locale_t _Locale
    );
# 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
                                      void* _Dst,
                                      void const* _Src,
                                      int _Val,
                                      size_t _Size
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
                                    void const* _Buf1,
                                    void const* _Buf2,
                                    size_t _Size
        );







    extern "C++"
    inline void* __cdecl memchr(
                                 void* _Pv,
                                 int _C,
                                 size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }





}
# 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h" 3
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 1 3
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
#pragma pack(push, 8)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
 extern "C" {
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
    __declspec(dllimport) errno_t __cdecl wcscat_s(
                                        wchar_t* _Destination,
             rsize_t _SizeInWords,
               wchar_t const* _Source
        );


    __declspec(dllimport) errno_t __cdecl wcscpy_s(
                                     wchar_t* _Destination,
             rsize_t _SizeInWords,
               wchar_t const* _Source
        );


    __declspec(dllimport) errno_t __cdecl wcsncat_s(
                                        wchar_t* _Destination,
                                        rsize_t _SizeInWords,
                                        wchar_t const* _Source,
                                        rsize_t _MaxCount
        );


    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
                                     wchar_t* _Destination,
                                     rsize_t _SizeInWords,
                                     wchar_t const* _Source,
                                     rsize_t _MaxCount
        );


    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                                      wchar_t* _String,
                                      wchar_t const* _Delimiter,
                                      wchar_t** _Context
        );
# 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
           wchar_t const* _String
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)



__declspec(dllimport) int __cdecl wcscmp(
           wchar_t const* _String1,
           wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }





#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)


__declspec(dllimport) size_t __cdecl wcscspn(
           wchar_t const* _String,
           wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcslen(
           wchar_t const* _String
    );
# 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) size_t __cdecl wcsnlen(
                               wchar_t const* _Source,
                               size_t _MaxCount
    );
# 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
    static __inline size_t __cdecl wcsnlen_s(
                                   wchar_t const* _Source,
                                   size_t _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);
# 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) int __cdecl wcsncmp(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);
# 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
           wchar_t const* _String,
           wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcsspn(
           wchar_t const* _String,
           wchar_t const* _Control
    );

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                                      wchar_t* _String,
                                      wchar_t const* _Delimiter,
                                      wchar_t** _Context
    );
# 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
#pragma warning(push)
#pragma warning(disable: 4141 4996)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
                      wchar_t* const _String,
                      wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }






        extern "C++" __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
                          wchar_t* _String,
                          wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }


#pragma warning(pop)






 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
         int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
                                     wchar_t* _Buffer,
                                     size_t _SizeInWords,
                                     int _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }







               __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
               wchar_t const* _String
    );

                   __declspec(dllimport) errno_t __cdecl __wcserror_s(
                                     wchar_t* _Buffer,
                                     size_t _SizeInWords,
                                     wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }





               __declspec(dllimport) int __cdecl _wcsicmp(
           wchar_t const* _String1,
           wchar_t const* _String2
    );

               __declspec(dllimport) int __cdecl _wcsicmp_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );

               __declspec(dllimport) int __cdecl _wcsnicmp(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );

               __declspec(dllimport) int __cdecl _wcsnicmp_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );

                   __declspec(dllimport) errno_t __cdecl _wcsnset_s(
                                    wchar_t* _Destination,
                                    size_t _SizeInWords,
                                    wchar_t _Value,
                                    size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







__declspec(dllimport) wchar_t* __cdecl _wcsrev(
              wchar_t* _String
    );

                   __declspec(dllimport) errno_t __cdecl _wcsset_s(
                                    wchar_t* _Destination,
                                    size_t _SizeInWords,
                                    wchar_t _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);






                   __declspec(dllimport) errno_t __cdecl _wcslwr_s(
                                    wchar_t* _String,
                                    size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
                                    wchar_t* _String,
                                    size_t _SizeInWords,
                                    _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);







__declspec(dllimport) errno_t __cdecl _wcsupr_s(
                             wchar_t* _String,
                             size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
                             wchar_t* _String,
                             size_t _Size,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);
# 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
__declspec(dllimport) size_t __cdecl wcsxfrm(
                                              wchar_t* _Destination,
                                              wchar_t const* _Source,
                                              size_t _MaxCount
    );



__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
                                              wchar_t* _Destination,
                                              wchar_t const* _Source,
                                              size_t _MaxCount,
                                              _locale_t _Locale
    );


__declspec(dllimport) int __cdecl wcscoll(
           wchar_t const* _String1,
           wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcscoll_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _wcsicoll(
           wchar_t const* _String1,
           wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcsicoll_l(
             wchar_t const* _String1,
             wchar_t const* _String2,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _wcsncoll(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsncoll_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _wcsnicoll(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsnicoll_l(
                               wchar_t const* _String1,
                               wchar_t const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );
# 535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
extern "C++" {



    inline wchar_t* __cdecl wcschr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }


    inline wchar_t* __cdecl wcspbrk( wchar_t* _String, wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }


    inline wchar_t* __cdecl wcsrchr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }



    inline wchar_t* __cdecl wcsstr( wchar_t* _String, wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
# 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
               wchar_t const* _String
        );
# 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
               wchar_t const* _String1,
               wchar_t const* _String2
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
                                   wchar_t const* _String1,
                                   wchar_t const* _String2,
                                   size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsnset(
                                     wchar_t* _String,
                                     wchar_t _Value,
                                     size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsrev(
                  wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsset(
                  wchar_t* _String,
                  wchar_t _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcslwr(
                  wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsupr(
                  wchar_t* _String
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
               wchar_t const* _String1,
               wchar_t const* _String2
        );





}
# 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h" 3
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 2 3





#pragma pack(push, 8)
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
 extern "C" {
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
    __declspec(dllimport) errno_t __cdecl strcpy_s(
                                     char* _Destination,
                                     rsize_t _SizeInBytes,
                                     char const* _Source
        );


    __declspec(dllimport) errno_t __cdecl strcat_s(
                                        char* _Destination,
                                        rsize_t _SizeInBytes,
                                        char const* _Source
        );


    __declspec(dllimport) errno_t __cdecl strerror_s(
                                     char* _Buffer,
                                     size_t _SizeInBytes,
                                     int _ErrorNumber);


    __declspec(dllimport) errno_t __cdecl strncat_s(
                                        char* _Destination,
                                        rsize_t _SizeInBytes,
                                        char const* _Source,
                                        rsize_t _MaxCount
        );


    __declspec(dllimport) errno_t __cdecl strncpy_s(
                                     char* _Destination,
                                     rsize_t _SizeInBytes,
                                     char const* _Source,
                                     rsize_t _MaxCount
        );


    __declspec(dllimport) char* __cdecl strtok_s(
                                      char* _String,
                                      char const* _Delimiter,
                                      char** _Context
        );



__declspec(dllimport) void* __cdecl _memccpy(
                                      void* _Dst,
                                      void const* _Src,
                                      int _Val,
                                      size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcat( char *_Destination, char const* _Source);




#pragma warning(pop)




int __cdecl strcmp(
           char const* _Str1,
           char const* _Str2
    );


__declspec(dllimport) int __cdecl _strcmpi(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl strcoll(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl _strcoll_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }





#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl strcpy( char *_Destination, char const* _Source);




#pragma warning(pop)


__declspec(dllimport) size_t __cdecl strcspn(
           char const* _Str,
           char const* _Control
    );







__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
               char const* _Source
    );







               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _strerror(
               char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
                                 char* _Buffer,
                                 size_t _SizeInBytes,
                                 char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }






               __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
         int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }






__declspec(dllimport) int __cdecl _stricmp(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll(
           char const* _String1,
           char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _stricmp_l(
             char const* _String1,
             char const* _String2,
             _locale_t _Locale
    );


size_t __cdecl strlen(
           char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
                             char* _String,
                             size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);





__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
                             char* _String,
                             size_t _Size,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l( char *_String, _locale_t _Locale);






extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat( char *_Destination, char const* _Source, size_t _Count);
# 274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
__declspec(dllimport) int __cdecl strncmp(
                               char const* _Str1,
                               char const* _Str2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _strnicoll(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicoll_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );


__declspec(dllimport) int __cdecl _strncoll(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount
    );


__declspec(dllimport) int __cdecl _strncoll_l(
                               char const* _String1,
                               char const* _String2,
                               size_t _MaxCount,
                               _locale_t _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
                            char const* _String,
                            size_t _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy( char *_Destination, char const* _Source, size_t _Count);
# 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
__declspec(dllimport) size_t __cdecl strnlen(
                               char const* _String,
                               size_t _MaxCount
    );
# 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
    static __inline size_t __cdecl strnlen_s(
                                   char const* _String,
                                   size_t _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }




__declspec(dllimport) errno_t __cdecl _strnset_s(
                                    char* _String,
                                    size_t _SizeInBytes,
                                    int _Value,
                                    size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset( char *_Destination, int _Value, size_t _Count);
# 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
__declspec(dllimport) char const* __cdecl strpbrk(
           char const* _Str,
           char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
              char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
                                        char* _Destination,
                                        size_t _DestinationSize,
                                        int _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _strset( char *_Destination, int _Value);






__declspec(dllimport) size_t __cdecl strspn(
           char const* _Str,
           char const* _Control
    );

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
                  char* _String,
                  char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
                             char* _String,
                             size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);





__declspec(dllimport) errno_t __cdecl _strupr_s_l(
                             char* _String,
                             size_t _Size,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l( char *_String, _locale_t _Locale);
# 482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
__declspec(dllimport) size_t __cdecl strxfrm(
                                              char* _Destination,
                                              char const* _Source,
                                              size_t _MaxCount
    );



__declspec(dllimport) size_t __cdecl _strxfrm_l(
                                              char* _Destination,
                                              char const* _Source,
                                              size_t _MaxCount,
                                              _locale_t _Locale
    );




extern "C++"
{

    inline char* __cdecl strchr( char* const _String, int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }


    inline char* __cdecl strpbrk( char* const _String, char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }


    inline char* __cdecl strrchr( char* const _String, int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }


    inline char* __cdecl strstr( char* const _String, char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
# 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
                   char const* _String
        );






                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
               char const* _String1,
               char const* _String2
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
               char const* _String1,
               char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
                  char* _String
        );

                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
                                   char const* _String1,
                                   char const* _String2,
                                   size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
                                     char* _String,
                                     int _Value,
                                     size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
                  char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
                  char* _String,
                  int _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
                  char* _String
        );





}
# 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h" 3
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstring" 2 3



namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\iosfwd" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cwchar" 1 3





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 1 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
 extern "C" {
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
                                                  wchar_t* _Buffer,
                                                  size_t _BufferCount,
                                                  size_t* _SizeRead
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }







    __declspec(dllimport) int __cdecl _cputws(
               wchar_t const* _Buffer
        );

                       __declspec(dllimport) wint_t __cdecl _getwch (void);
                       __declspec(dllimport) wint_t __cdecl _getwche (void);
                       __declspec(dllimport) wint_t __cdecl _putwch ( wchar_t _Character);
                       __declspec(dllimport) wint_t __cdecl _ungetwch( wint_t _Character);

                       __declspec(dllimport) wint_t __cdecl _getwch_nolock (void);
                       __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
                       __declspec(dllimport) wint_t __cdecl _putwch_nolock ( wchar_t _Character);
                       __declspec(dllimport) wint_t __cdecl _ungetwch_nolock( wint_t _Character);
# 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                                unsigned __int64 _Options,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                                unsigned __int64 _Options,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                                unsigned __int64 _Options,
                                                wchar_t const* _Format,
                                                _locale_t _Locale,
                                                va_list _ArgList
        );


    __inline int __cdecl _vcwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwprintf(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _vcwprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwprintf_s(
                                      wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _vcwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwprintf_p(
                                      const wchar_t* const _Format,
                                      va_list _ArgList
        )



    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }



    __inline int __cdecl _cwprintf_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_s_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_s(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_p_l(
                                                wchar_t const* const _Format,
                                                _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwprintf_p(
                                      wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
# 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                               unsigned __int64 _Options,
                                               wchar_t const* _Format,
                                               _locale_t _Locale,
                                               va_list _ArgList
        );

                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
                                               wchar_t const* const _Format,
                                               va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _vcwscanf_l(_Format, 0, _ArgList);
#pragma warning(pop)
 }



    __inline int __cdecl _vcwscanf_s_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }



    __inline int __cdecl _vcwscanf_s(
                                               wchar_t const* const _Format,
                                               va_list _ArgList
        )



    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }


                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

#pragma warning(push)
#pragma warning(disable: 4996)
 _Result = _vcwscanf_l(_Format, 0, _ArgList);
#pragma warning(pop)

 ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwscanf_s_l(
                                               wchar_t const* const _Format,
                                               _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }



    __inline int __cdecl _cwscanf_s(
                                     wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






}
# 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h" 3
#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
 extern "C" {
# 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t* __cdecl __pwctype_func(void);
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
               __declspec(dllimport) int __cdecl iswalnum ( wint_t _C);
               __declspec(dllimport) int __cdecl iswalpha ( wint_t _C);
               __declspec(dllimport) int __cdecl iswascii ( wint_t _C);
               __declspec(dllimport) int __cdecl iswblank ( wint_t _C);
               __declspec(dllimport) int __cdecl iswcntrl ( wint_t _C);


               __declspec(dllimport) int __cdecl iswdigit ( wint_t _C);

               __declspec(dllimport) int __cdecl iswgraph ( wint_t _C);
               __declspec(dllimport) int __cdecl iswlower ( wint_t _C);
               __declspec(dllimport) int __cdecl iswprint ( wint_t _C);
               __declspec(dllimport) int __cdecl iswpunct ( wint_t _C);
               __declspec(dllimport) int __cdecl iswspace ( wint_t _C);
               __declspec(dllimport) int __cdecl iswupper ( wint_t _C);
               __declspec(dllimport) int __cdecl iswxdigit ( wint_t _C);
               __declspec(dllimport) int __cdecl __iswcsymf( wint_t _C);
               __declspec(dllimport) int __cdecl __iswcsym ( wint_t _C);

               __declspec(dllimport) int __cdecl _iswalnum_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswalpha_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswblank_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswcntrl_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswdigit_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswgraph_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswlower_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswprint_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswpunct_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswspace_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswupper_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswxdigit_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswcsymf_l ( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswcsym_l ( wint_t _C, _locale_t _Locale);


               __declspec(dllimport) wint_t __cdecl towupper( wint_t _C);
               __declspec(dllimport) wint_t __cdecl towlower( wint_t _C);
               __declspec(dllimport) int __cdecl iswctype( wint_t _C, wctype_t _Type);

               __declspec(dllimport) wint_t __cdecl _towupper_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) wint_t __cdecl _towlower_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _iswctype_l( wint_t _C, wctype_t _Type, _locale_t _Locale);



                   __declspec(dllimport) int __cdecl isleadbyte( int _C);
                   __declspec(dllimport) int __cdecl _isleadbyte_l( int _C, _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype( wint_t _C, wctype_t _Type);
# 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
}
# 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h" 3
#pragma pack(pop)
# 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3
 extern "C" {
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
                                     wchar_t* _DstBuf,
                                     int _SizeInWords
    );



__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                     int _Drive,
                                     wchar_t* _DstBuf,
                                     int _SizeInWords
    );







__declspec(dllimport) int __cdecl _wchdir(
           wchar_t const* _Path
    );


__declspec(dllimport) int __cdecl _wmkdir(
           wchar_t const* _Path
    );


__declspec(dllimport) int __cdecl _wrmdir(
           wchar_t const* _Path
    );



}
# 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h" 3
#pragma pack(pop)
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_share.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
 extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820)
# 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
};

struct _wfinddata32i64_t
{
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __int64 size;
    wchar_t name[260];
};

struct _wfinddata64i32_t
{
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
};

struct _wfinddata64_t
{
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __int64 size;
    wchar_t name[260];
};
# 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
__declspec(dllimport) int __cdecl _waccess(
           wchar_t const* _FileName,
           int _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
           wchar_t const* _FileName,
           int _AccessMode
    );


__declspec(dllimport) int __cdecl _wchmod(
           wchar_t const* _FileName,
           int _Mode
    );

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
           wchar_t const* _FileName,
           int _PermissionMode
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
           wchar_t const* _FileName,
           struct _wfinddata32_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext32(
          intptr_t _FindHandle,
          struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
           wchar_t const* _FileName
    );


__declspec(dllimport) int __cdecl _wrename(
           wchar_t const* _OldFileName,
           wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
                                    wchar_t* _TemplateName,
                                    size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);






__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
           wchar_t const* _FileName,
           struct _wfinddata32i64_t* _FindData
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
           wchar_t const* _FileName,
           struct _wfinddata64i32_t* _FindData
    );



__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
           wchar_t const* _FileName,
           struct _wfinddata64_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext32i64(
          intptr_t _FindHandle,
          struct _wfinddata32i64_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext64i32(
          intptr_t _FindHandle,
          struct _wfinddata64i32_t* _FindData
    );



__declspec(dllimport) int __cdecl _wfindnext64(
          intptr_t _FindHandle,
          struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
           int* _FileHandle,
           wchar_t const* _FileName,
           int _OpenFlag,
           int _ShareFlag,
           int _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
           wchar_t const* _FileName,
           int _OFlag,
           int _ShFlag,
           int _PMode,
           int* _PFileHandle,
           int _BSecure
    );






    extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
               wchar_t const* _FileName,
               int _OFlag,
               int _PMode = 0
        )
    {
        int _FileHandle;

        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
               wchar_t const* _FileName,
               int _OFlag,
               int _ShFlag,
               int _PMode = 0
        )
    {
        int _FileHandle;

        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
# 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
#pragma warning(pop)


}
# 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h" 3
#pragma pack(pop)
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3
 extern "C" {






        __declspec(dllimport) intptr_t __cdecl _wexecl(
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                       wchar_t const* _FileName,
                       wchar_t const* const* _ArgList,
                       wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                       wchar_t const* _FileName,
                       wchar_t const* const* _ArgList,
                       wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                       int _Mode,
                       wchar_t const* _FileName,
                       wchar_t const* const* _ArgList,
                       wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                   int _Mode,
                   wchar_t const* _FileName,
                   wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                       int _Mode,
                       wchar_t const* _FileName,
                       wchar_t const* const* _ArgList,
                       wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
                       wchar_t const* _Command
            );






}
# 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h" 3
#pragma pack(pop)
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3




# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
 extern "C" {
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};







               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))


__declspec(dllimport) wchar_t* __cdecl _wasctime(
         struct tm const* _Tm
    );



__declspec(dllimport) errno_t __cdecl _wasctime_s(
                                                          wchar_t* _Buffer,
                                                          size_t _SizeInWords,
                                                          struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
__declspec(dllimport) size_t __cdecl wcsftime(
                                  wchar_t* _Buffer,
                                  size_t _SizeInWords,
                                  wchar_t const* _Format,
                                  struct tm const* _Tm
    );



__declspec(dllimport) size_t __cdecl _wcsftime_l(
                                  wchar_t* _Buffer,
                                  size_t _SizeInWords,
                                  wchar_t const* _Format,
                                  struct tm const* _Tm,
                                  _locale_t _Locale
    );


               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
         __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
                                                          wchar_t* _Buffer,
                                                          size_t _SizeInWords,
                                                          __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }







               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
         __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
                                                          wchar_t* _Buffer,
                                                          size_t _SizeInWords,
                                                          __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) errno_t __cdecl _wstrdate_s(
                                                                                   wchar_t* _Buffer,
                                                                                   size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);





__declspec(dllimport) errno_t __cdecl _wstrtime_s(
                                                                                   wchar_t* _Buffer,
                                                                                   size_t _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
# 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
#pragma warning(push)
#pragma warning(disable: 4996)
# 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
 static __inline wchar_t * __cdecl _wctime(
                 time_t const* const _Time)
        {
            return _wctime64(_Time);
        }


        static __inline errno_t __cdecl _wctime_s(
                                                                wchar_t* const _Buffer,
                                                                size_t const _SizeInWords,
                                                                time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }



#pragma warning(pop)




}
# 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h" 3
#pragma pack(pop)
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 1 3
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 1 3
# 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
    typedef unsigned short _ino_t;


        typedef _ino_t ino_t;
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
    typedef unsigned int _dev_t;


        typedef _dev_t dev_t;
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h" 3
    typedef long _off_t;


        typedef _off_t off_t;
# 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 2 3


#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
 extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820)







struct _stat32
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
};

struct _stat32i64
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __int64 st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
};

struct _stat64i32
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
};

struct _stat64
{
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __int64 st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
};




    struct stat
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
    };
# 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
__declspec(dllimport) int __cdecl _fstat32(
          int _FileHandle,
          struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
          int _FileHandle,
          struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
          int _FileHandle,
          struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
          int _FileHandle,
          struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
           char const* _FileName,
           struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
           char const* _FileName,
           struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
           char const* _FileName,
           struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
           char const* _FileName,
           struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
           wchar_t const* _FileName,
           struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
           wchar_t const* _FileName,
           struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
           wchar_t const* _FileName,
           struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
           wchar_t const* _FileName,
           struct _stat64* _Stat
    );
# 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }





#pragma warning(pop)


}
# 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h" 3
#pragma pack(pop)
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 2 3




#pragma pack(push, 8)
# 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
 extern "C" {
# 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
typedef wchar_t _Wint_t;






    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                   int _Category,
                   wchar_t const* _Locale
        );


    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
               int _Category,
               wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
             int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
                                                       char const* _Ch,
                                                       size_t _SizeInBytes,
                                                       mbstate_t* _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                                       wchar_t* _DstCh,
                                                       char const* _SrcCh,
                                                       size_t _SizeInBytes,
                                                       mbstate_t* _State
        );


    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                          size_t* _Retval,
                                          wchar_t* _Dst,
                                          size_t _Size,
                                          char const** _PSrc,
                                          size_t _N,
                                          mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
# 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);
# 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                         size_t* _Retval,
                                         char* _Dst,
                                         size_t _SizeInBytes,
                                         wchar_t _Ch,
                                         mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
# 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb( char *_Dest, wchar_t _Source, mbstate_t* _State);







    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                          size_t* _Retval,
                                                          char* _Dst,
                                                          size_t _SizeInBytes,
                                                          wchar_t const** _Src,
                                                          size_t _Size,
                                                          mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
# 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs( char *_Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);







    __declspec(dllimport) int __cdecl wctob(
             wint_t _WCh
        );




        errno_t __cdecl wmemcpy_s(
                                         wchar_t* _S1,
                                         rsize_t _N1,
                                         wchar_t const* _S2,
                                         rsize_t _N
            );


        errno_t __cdecl wmemmove_s(
                                         wchar_t* _S1,
                                         rsize_t _N1,
                                         wchar_t const* _S2,
                                         rsize_t _N
            );



    __inline int __cdecl fwide(
                 FILE* _F,
                 int _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
                 mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
                       wchar_t const* _S,
                       wchar_t _C,
                       size_t _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
                       wchar_t const* _S1,
                       wchar_t const* _S2,
                       size_t _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }



    __inline
    wchar_t* __cdecl wmemcpy(
                             wchar_t* _S1,
                             wchar_t const* _S2,
                             size_t _N
        )
    {
#pragma warning(push)
#pragma warning(disable: 4995 4996 6386)
 return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning(pop)
 }

    __inline
    wchar_t* __cdecl wmemmove(
                                 wchar_t* _S1,
                                 wchar_t const* _S2,
                                 size_t _N
        )
    {
#pragma warning(push)
#pragma warning(disable: 4996 6386)
 return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning(pop)
 }



    __inline wchar_t* __cdecl wmemset(
                             wchar_t* _S,
                             wchar_t _C,
                             size_t _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }



        extern "C++" inline wchar_t* __cdecl wmemchr(
                           wchar_t* _S,
                           wchar_t _C,
                           size_t _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }







}
# 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h" 3
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cwchar" 2 3


typedef mbstate_t _Mbstatet;


namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\iosfwd" 2 3



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 1 3
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_new_debug.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_new_debug.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_new.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_new.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_new.h" 2 3



extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985)






 namespace std
    {
        struct nothrow_t { };




            extern nothrow_t const nothrow;

    }



__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );


__declspec(allocator) void* __cdecl operator new(
    size_t _Size,
    std::nothrow_t const&
    ) throw();


__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );


__declspec(allocator) void* __cdecl operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block
    ) throw();

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete[](
    void* _Block
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block,
    size_t _Size
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) throw();




    inline void* __cdecl operator new(size_t _Size, void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) throw()
    {
        return;
    }





    inline void* __cdecl operator new[](size_t _Size, void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) throw()
    {
    }




#pragma warning(pop)
#pragma pack(pop)

}
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_new_debug.h" 2 3



extern "C++" {

#pragma pack(push, 8)







 __declspec(allocator) void* __cdecl operator new(
               size_t _Size,
               int _BlockUse,
               char const* _FileName,
               int _LineNumber
        );


    __declspec(allocator) void* __cdecl operator new[](
               size_t _Size,
               int _BlockUse,
               char const* _FileName,
               int _LineNumber
        );

    void __cdecl operator delete(
        void* _Block,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber
        ) throw();

    void __cdecl operator delete[](
        void* _Block,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber
        ) throw();





#pragma pack(pop)

}
# 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
 extern "C" {



typedef void* _HFILE;
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*, int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);
# 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;
# 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
}
# 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h" 3
#pragma pack(pop)
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\iosfwd" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {


typedef long long streamoff;
typedef long long streamsize;





extern __declspec(dllimport) const streamoff _BADOFF;



template<class _Statetype>
 class fpos
 {
 typedef fpos<_Statetype> _Myt;

public:
                    fpos(streamoff _Off = 0)
  : _Myoff(_Off), _Fpos(0), _Mystate()
  {
  }

                    fpos(_Statetype _State, fpos_t _Fileposition)
  : _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
  {
  }

 _Statetype state() const
  {
  return (_Mystate);
  }

 void state(_Statetype _State)
  {
  _Mystate = _State;
  }

 fpos_t seekpos() const
  {
  return (_Fpos);
  }

                    operator streamoff() const
  {
  return (_Myoff + _Fpos);
  }

 streamoff operator-(const _Myt& _Right) const
  {
  return ((streamoff)*this - (streamoff)_Right);
  }

 _Myt& operator+=(streamoff _Off)
  {
  _Myoff += _Off;
  return (*this);
  }

 _Myt& operator-=(streamoff _Off)
  {
  _Myoff -= _Off;
  return (*this);
  }

 _Myt operator+(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt operator-(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

 bool operator==(const _Myt& _Right) const
  {
  return ((streamoff)*this == (streamoff)_Right);
  }

 bool operator==(streamoff _Right) const
  {
  return ((streamoff)*this == _Right);
  }

 bool operator!=(const _Myt& _Right) const
  {
  return (!(*this == _Right));
  }

private:
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };






typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;


template<class _Elem,
 class _Int_type>
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare( const _Elem * _First1,
                     const _Elem * _First2, size_t _Count) noexcept
  {
  for (; 0 < _Count; --_Count, ++_First1, ++_First2)
   if (!eq(*_First1, *_First2))
    return (lt(*_First1, *_First2) ? -1 : +1);
  return (0);
  }

 static size_t __cdecl length( const _Elem * _First) noexcept
  {
  size_t _Count;
  for (_Count = 0; !eq(*_First, _Elem()); ++_First)
   ++_Count;
  return (_Count);
  }

 static _Elem * __cdecl copy( _Elem * const _First1,
                     const _Elem * _First2, size_t _Count) noexcept
  {
  _Elem * _Next = _First1;
  for (; 0 < _Count; --_Count, ++_Next, ++_First2)
   assign(*_Next, *_First2);
  return (_First1);
  }

                                       static _Elem * __cdecl _Copy_s(
                               _Elem * const _First1, const size_t _Dest_size,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  { if (!(_Count <= _Dest_size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); return (0); } };
  return (copy(_First1, _First2, _Count));
  }

 static const _Elem * __cdecl find( const _Elem * _First,
  size_t _Count, const _Elem& _Ch) noexcept
  {
  for (; 0 < _Count; --_Count, ++_First)
   if (eq(*_First, _Ch))
    return (_First);
  return (0);
  }

 static _Elem * __cdecl move( _Elem * const _First1,
                     const _Elem * _First2, size_t _Count) noexcept
  {
  _Elem * _Next = _First1;
  if (_First2 < _Next && _Next < _First2 + _Count)
   for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
    assign(*--_Next, *--_First2);
  else
   for (; 0 < _Count; --_Count, ++_Next, ++_First2)
    assign(*_Next, *_First2);
  return (_First1);
  }

 static _Elem * __cdecl assign( _Elem * const _First,
  size_t _Count, const _Elem _Ch) noexcept
  {
  _Elem * _Next = _First;
  for (; 0 < _Count; --_Count, ++_Next)
   assign(*_Next, _Ch);
  return (_First);
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem __cdecl to_char_type(const int_type& _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type __cdecl to_int_type(const _Elem& _Ch) noexcept
  {
  return ((int_type)_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return ((int_type)(-1));
  }
 };


template<class _Elem>
 struct char_traits
  : public _Char_traits<_Elem, long>
 {
 };


template<>
 struct char_traits<char16_t>
 : public _Char_traits<char16_t, unsigned short>
 {
 };

typedef streampos u16streampos;


template<>
 struct char_traits<char32_t>
 : public _Char_traits<char32_t, unsigned int>
 {
 };

typedef streampos u32streampos;


template<>
 struct char_traits<wchar_t>
 {
 typedef wchar_t _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare( const _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return (:: wmemcmp(_First1, _First2, _Count));
  }

 static size_t __cdecl length( const _Elem * const _First) noexcept
  {
  return (:: wcslen(_First));
  }

 static _Elem * __cdecl copy( _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return ((_Elem *):: wmemcpy(_First1, _First2, _Count));
  }

                                           static _Elem * __cdecl _Copy_s(
                                   _Elem * const _First1, const size_t _Size_in_words,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  ::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
  return (_First1);
  }

 static const _Elem * __cdecl find( const _Elem * const _First,
  const size_t _Count, const _Elem& _Ch) noexcept
  {
  return ((const _Elem *):: wmemchr(_First, _Ch, _Count));
  }

 static _Elem * __cdecl move( _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return ((_Elem *):: wmemmove(_First1, _First2, _Count));
  }

 static _Elem * __cdecl assign( _Elem * const _First,
  const size_t _Count, const _Elem _Ch) noexcept
  {
  return ((_Elem *):: wmemset(_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem __cdecl to_char_type(const int_type& _Meta) noexcept
  {
  return (_Meta);
  }

 static constexpr int_type __cdecl to_int_type(const _Elem& _Ch) noexcept
  {
  return (_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return (((wint_t)(0xFFFF)));
  }
 };



template<>
 struct char_traits<unsigned short>
 {
 typedef unsigned short _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare( const _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return (:: wmemcmp((const wchar_t *)_First1, (const wchar_t *)_First2, _Count));
  }

 static size_t __cdecl length( const _Elem * _First) noexcept
  {
  return (:: wcslen((const wchar_t *)_First));
  }

 static _Elem * __cdecl copy( _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return ((_Elem *):: wmemcpy((wchar_t *)_First1, (const wchar_t *)_First2, _Count));
  }

                                           static _Elem * __cdecl _Copy_s(
                                   _Elem * const _First1, const size_t _Size_in_words,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  ::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
  return (_First1);
  }

 static const _Elem * __cdecl find( const _Elem * _First,
  const size_t _Count, const _Elem& _Ch) noexcept
  {
  return ((const _Elem *):: wmemchr((const wchar_t *)_First, _Ch, _Count));
  }

 static _Elem * __cdecl move( _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return ((_Elem *):: wmemmove((wchar_t *)_First1, (const wchar_t *)_First2, _Count));
  }

 static _Elem * __cdecl assign( _Elem * const _First, size_t _Count,
  _Elem _Ch) noexcept
  {
  return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem __cdecl to_char_type(const int_type& _Meta) noexcept
  {
  return (_Meta);
  }

 static constexpr int_type __cdecl to_int_type(const _Elem& _Ch) noexcept
  {
  return (_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return (((wint_t)(0xFFFF)));
  }
 };



template<> struct char_traits<char>
 {
 typedef char _Elem;
 typedef _Elem char_type;
 typedef int int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare( const _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return (:: memcmp(_First1, _First2, _Count));
  }

 static size_t __cdecl length( const _Elem * const _First) noexcept
  {
  return (:: strlen(_First));
  }

 static _Elem * __cdecl copy( _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return ((_Elem *):: memcpy(_First1, _First2, _Count));
  }

                                           static _Elem * __cdecl _Copy_s(
                                   _Elem * const _First1, const size_t _Size_in_bytes,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  ::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
  return (_First1);
  }

 static const _Elem * __cdecl find( const _Elem * const _First,
  const size_t _Count, const _Elem& _Ch) noexcept
  {
  return ((const _Elem *):: memchr(_First, _Ch, _Count));
  }

 static _Elem * __cdecl move( _Elem * const _First1,
                     const _Elem * const _First2, const size_t _Count) noexcept
  {
  return ((_Elem *):: memmove(_First1, _First2, _Count));
  }

 static _Elem * __cdecl assign( _Elem * const _First,
  const size_t _Count, const _Elem _Ch) noexcept
  {
  return ((_Elem *):: memset(_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool __cdecl lt(const _Elem& _Left, const _Elem& _Right) noexcept
  {
  return ((unsigned char)_Left < (unsigned char)_Right);
  }

 static constexpr _Elem __cdecl to_char_type(const int_type& _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type __cdecl to_int_type(const _Elem& _Ch) noexcept
  {
  return ((unsigned char)_Ch);
  }

 static constexpr bool __cdecl eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type __cdecl not_eof(const int_type& _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static constexpr int_type __cdecl eof() noexcept
  {
  return ((-1));
  }
 };


template<class _Ty>
 class allocator;
class ios_base;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ios;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class istreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class ostreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_streambuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_istream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ostream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_iostream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringbuf;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_istringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_ostringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_filebuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ifstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ofstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_fstream;


template<class _Elem,
 class _InIt >
 class num_get;
template<class _Elem,
 class _OutIt >
 class num_put;
template<class _Elem>
 class collate;



typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
 allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
 allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
 allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
 allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
 wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
# 681 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\iosfwd" 3
}


#pragma warning(pop)
#pragma pack(pop)
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xfunctional" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdint" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdint.h" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdint.h" 2 3




typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long intmax_t;
typedef unsigned long long uintmax_t;
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdint" 2 3



namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
# 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cstdint" 3
}
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\ymath.h" 1 3






#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)






extern "C" {
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\ymath.h" 3
void __cdecl _Feraise(int);

typedef union
 {
 unsigned short _Word[8];
 float _Float;
 double _Double;
 long double _Long_double;
 } _Dconst;


__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) double __cdecl _Sinh(double, double);

__declspec(dllimport) short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport) _Dconst _Denorm, _Hugeval, _Inf,
 _Nan, _Snan;


__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) float __cdecl _FSinh(float, float);

__declspec(dllimport) short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport) _Dconst _FDenorm, _FInf, _FNan, _FSnan;


__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);

__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport) _Dconst _LDenorm, _LInf, _LNan, _LSnan;



}




#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cfloat" 1 3






# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
 extern "C" {
# 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
         unsigned int _NewValue,
         unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
         unsigned int _NewValue,
         unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
              unsigned int* _CurrentState,
              unsigned int _NewValue,
              unsigned int _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);
# 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
__declspec(dllimport) unsigned int __cdecl _control87(
         unsigned int _NewValue,
         unsigned int _Mask
    );
# 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
__declspec(dllimport) int* __cdecl __fpecode(void);




__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);
# 307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
               __declspec(dllimport) double __cdecl _copysign( double _Number, double _Sign);
               __declspec(dllimport) double __cdecl _chgsign( double _X);
               __declspec(dllimport) double __cdecl _scalb( double _X, long _Y);
               __declspec(dllimport) double __cdecl _logb( double _X);
               __declspec(dllimport) double __cdecl _nextafter( double _X, double _Y);
               __declspec(dllimport) int __cdecl _finite( double _X);
               __declspec(dllimport) int __cdecl _isnan( double _X);
               __declspec(dllimport) int __cdecl _fpclass( double _X);


                   __declspec(dllimport) float __cdecl _scalbf( float _X, long _Y);
# 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
    __declspec(dllimport) void __cdecl fpreset(void);
# 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
}
# 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h" 3
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cfloat" 2 3
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\climits" 1 3
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cmath" 1 3








               inline double pow( double _Xx, int _Yx) noexcept
 {
 if (_Yx == 2)
  return (_Xx * _Xx);

 return (:: pow(_Xx, static_cast<double>(_Yx)));
 }

               inline float acos( float _Xx) noexcept
 {
 return (:: acosf(_Xx));
 }

               inline float acosh( float _Xx) noexcept
 {
 return (:: acoshf(_Xx));
 }

               inline float asin( float _Xx) noexcept
 {
 return (:: asinf(_Xx));
 }

               inline float asinh( float _Xx) noexcept
 {
 return (:: asinhf(_Xx));
 }

               inline float atan( float _Xx) noexcept
 {
 return (:: atanf(_Xx));
 }

               inline float atanh( float _Xx) noexcept
 {
 return (:: atanhf(_Xx));
 }

               inline float atan2( float _Yx, float _Xx) noexcept
 {
 return (:: atan2f(_Yx, _Xx));
 }

               inline float cbrt( float _Xx) noexcept
 {
 return (:: cbrtf(_Xx));
 }

               inline float ceil( float _Xx) noexcept
 {
 return (:: ceilf(_Xx));
 }

               inline float copysign( float _Number,
      float _Sign) noexcept
 {
 return (:: copysignf(_Number, _Sign));
 }

               inline float cos( float _Xx) noexcept
 {
 return (:: cosf(_Xx));
 }

               inline float cosh( float _Xx) noexcept
 {
 return (:: coshf(_Xx));
 }

               inline float erf( float _Xx) noexcept
 {
 return (:: erff(_Xx));
 }

               inline float erfc( float _Xx) noexcept
 {
 return (:: erfcf(_Xx));
 }

               inline float exp( float _Xx) noexcept
 {
 return (:: expf(_Xx));
 }

               inline float exp2( float _Xx) noexcept
 {
 return (:: exp2f(_Xx));
 }

               inline float expm1( float _Xx) noexcept
 {
 return (:: expm1f(_Xx));
 }

               inline float fabs( float _Xx) noexcept
 {
 return (:: fabsf(_Xx));
 }

               inline float fdim( float _Xx, float _Yx) noexcept
 {
 return (:: fdimf(_Xx, _Yx));
 }

               inline float floor( float _Xx) noexcept
 {
 return (:: floorf(_Xx));
 }

               inline float fma( float _Xx, float _Yx,
      float _Zx) noexcept
 {
 return (:: fmaf(_Xx, _Yx, _Zx));
 }

               inline float fmax( float _Xx, float _Yx) noexcept
 {
 return (:: fmaxf(_Xx, _Yx));
 }

               inline float fmin( float _Xx, float _Yx) noexcept
 {
 return (:: fminf(_Xx, _Yx));
 }

               inline float fmod( float _Xx, float _Yx) noexcept
 {
 return (:: fmodf(_Xx, _Yx));
 }

               inline float frexp( float _Xx, int* _Yx) noexcept
 {
 return (:: frexpf(_Xx, _Yx));
 }

               inline float hypot( float _Xx, float _Yx) noexcept
 {
 return (:: hypotf(_Xx, _Yx));
 }

               inline int ilogb( float _Xx) noexcept
 {
 return (:: ilogbf(_Xx));
 }

               inline float ldexp( float _Xx, int _Yx) noexcept
 {
 return (:: ldexpf(_Xx, _Yx));
 }

               inline float lgamma( float _Xx) noexcept
 {
 return (:: lgammaf(_Xx));
 }

               inline long long llrint( float _Xx) noexcept
 {
 return (:: llrintf(_Xx));
 }

               inline long long llround( float _Xx) noexcept
 {
 return (:: llroundf(_Xx));
 }

               inline float log( float _Xx) noexcept
 {
 return (:: logf(_Xx));
 }

               inline float log10( float _Xx) noexcept
 {
 return (:: log10f(_Xx));
 }

               inline float log1p( float _Xx) noexcept
 {
 return (:: log1pf(_Xx));
 }

               inline float log2( float _Xx) noexcept
 {
 return (:: log2f(_Xx));
 }

               inline float logb( float _Xx) noexcept
 {
 return (:: logbf(_Xx));
 }

               inline long lrint( float _Xx) noexcept
 {
 return (:: lrintf(_Xx));
 }

               inline long lround( float _Xx) noexcept
 {
 return (:: lroundf(_Xx));
 }

               inline float modf( float _Xx, float* _Yx) noexcept
 {
 return (:: modff(_Xx, _Yx));
 }

               inline float nearbyint( float _Xx) noexcept
 {
 return (:: nearbyintf(_Xx));
 }

               inline float nextafter( float _Xx, float _Yx) noexcept
 {
 return (:: nextafterf(_Xx, _Yx));
 }

               inline float nexttoward( float _Xx,
      long double _Yx) noexcept
 {
 return (:: nexttowardf(_Xx, _Yx));
 }

               inline float pow( float _Xx,
      float _Yx) noexcept
 {
 return (:: powf(_Xx, _Yx));
 }

               inline float pow( float _Xx, int _Yx) noexcept
 {
 if (_Yx == 2)
  return (_Xx * _Xx);

 return (:: powf(_Xx, static_cast<float>(_Yx)));
 }

               inline float remainder( float _Xx, float _Yx) noexcept
 {
 return (:: remainderf(_Xx, _Yx));
 }

               inline float remquo( float _Xx, float _Yx,
       int *_Zx) noexcept
 {
 return (:: remquof(_Xx, _Yx, _Zx));
 }

               inline float rint( float _Xx) noexcept
 {
 return (:: rintf(_Xx));
 }

               inline float round( float _Xx) noexcept
 {
 return (:: roundf(_Xx));
 }

               inline float scalbln( float _Xx, long _Yx) noexcept
 {
 return (:: scalblnf(_Xx, _Yx));
 }

               inline float scalbn( float _Xx, int _Yx) noexcept
 {
 return (:: scalbnf(_Xx, _Yx));
 }

               inline float sin( float _Xx) noexcept
 {
 return (:: sinf(_Xx));
 }

               inline float sinh( float _Xx) noexcept
 {
 return (:: sinhf(_Xx));
 }

               inline float sqrt( float _Xx) noexcept
 {
 return (:: sqrtf(_Xx));
 }

               inline float tan( float _Xx) noexcept
 {
 return (:: tanf(_Xx));
 }

               inline float tanh( float _Xx) noexcept
 {
 return (:: tanhf(_Xx));
 }

               inline float tgamma( float _Xx) noexcept
 {
 return (:: tgammaf(_Xx));
 }

               inline float trunc( float _Xx) noexcept
 {
 return (:: truncf(_Xx));
 }

               inline long double acos( long double _Xx) noexcept
 {
 return (:: acosl(_Xx));
 }

               inline long double acosh( long double _Xx) noexcept
 {
 return (:: acoshl(_Xx));
 }

               inline long double asin( long double _Xx) noexcept
 {
 return (:: asinl(_Xx));
 }

               inline long double asinh( long double _Xx) noexcept
 {
 return (:: asinhl(_Xx));
 }

               inline long double atan( long double _Xx) noexcept
 {
 return (:: atanl(_Xx));
 }

               inline long double atanh( long double _Xx) noexcept
 {
 return (:: atanhl(_Xx));
 }

               inline long double atan2( long double _Yx,
      long double _Xx) noexcept
 {
 return (:: atan2l(_Yx, _Xx));
 }

               inline long double cbrt( long double _Xx) noexcept
 {
 return (:: cbrtl(_Xx));
 }

               inline long double ceil( long double _Xx) noexcept
 {
 return (:: ceill(_Xx));
 }

               inline long double copysign( long double _Number,
      long double _Sign) noexcept
 {
 return (:: copysignl(_Number, _Sign));
 }

               inline long double cos( long double _Xx) noexcept
 {
 return (:: cosl(_Xx));
 }

               inline long double cosh( long double _Xx) noexcept
 {
 return (:: coshl(_Xx));
 }

               inline long double erf( long double _Xx) noexcept
 {
 return (:: erfl(_Xx));
 }

               inline long double erfc( long double _Xx) noexcept
 {
 return (:: erfcl(_Xx));
 }

               inline long double exp( long double _Xx) noexcept
 {
 return (:: expl(_Xx));
 }

               inline long double exp2( long double _Xx) noexcept
 {
 return (:: exp2l(_Xx));
 }

               inline long double expm1( long double _Xx) noexcept
 {
 return (:: expm1l(_Xx));
 }

               inline long double fabs( long double _Xx) noexcept
 {
 return (:: fabsl(_Xx));
 }

               inline long double fdim( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fdiml(_Xx, _Yx));
 }

               inline long double floor( long double _Xx) noexcept
 {
 return (:: floorl(_Xx));
 }

               inline long double fma( long double _Xx,
      long double _Yx, long double _Zx) noexcept
 {
 return (:: fmal(_Xx, _Yx, _Zx));
 }

               inline long double fmax( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fmaxl(_Xx, _Yx));
 }

               inline long double fmin( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fminl(_Xx, _Yx));
 }

               inline long double fmod( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: fmodl(_Xx, _Yx));
 }

               inline long double frexp( long double _Xx,
       int* _Yx) noexcept
 {
 return (:: frexpl(_Xx, _Yx));
 }

               inline long double hypot( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: hypotl(_Xx, _Yx));
 }

               inline int ilogb( long double _Xx) noexcept
 {
 return (:: ilogbl(_Xx));
 }

               inline long double ldexp( long double _Xx,
      int _Yx) noexcept
 {
 return (:: ldexpl(_Xx, _Yx));
 }

               inline long double lgamma( long double _Xx) noexcept
 {
 return (:: lgammal(_Xx));
 }

               inline long long llrint( long double _Xx) noexcept
 {
 return (:: llrintl(_Xx));
 }

               inline long long llround( long double _Xx) noexcept
 {
 return (:: llroundl(_Xx));
 }

               inline long double log( long double _Xx) noexcept
 {
 return (:: logl(_Xx));
 }

               inline long double log10( long double _Xx) noexcept
 {
 return (:: log10l(_Xx));
 }

               inline long double log1p( long double _Xx) noexcept
 {
 return (:: log1pl(_Xx));
 }

               inline long double log2( long double _Xx) noexcept
 {
 return (:: log2l(_Xx));
 }

               inline long double logb( long double _Xx) noexcept
 {
 return (:: logbl(_Xx));
 }

               inline long lrint( long double _Xx) noexcept
 {
 return (:: lrintl(_Xx));
 }

               inline long lround( long double _Xx) noexcept
 {
 return (:: lroundl(_Xx));
 }

               inline long double modf( long double _Xx,
       long double* _Yx) noexcept
 {
 return (:: modfl(_Xx, _Yx));
 }

               inline long double nearbyint( long double _Xx) noexcept
 {
 return (:: nearbyintl(_Xx));
 }

               inline long double nextafter( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: nextafterl(_Xx, _Yx));
 }

               inline long double nexttoward( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: nexttowardl(_Xx, _Yx));
 }

               inline long double pow( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: powl(_Xx, _Yx));
 }

               inline long double pow( long double _Xx,
      int _Yx) noexcept
 {
 if (_Yx == 2)
  return (_Xx * _Xx);

 return (:: powl(_Xx, static_cast<long double>(_Yx)));
 }

               inline long double remainder( long double _Xx,
      long double _Yx) noexcept
 {
 return (:: remainderl(_Xx, _Yx));
 }

               inline long double remquo( long double _Xx,
      long double _Yx, int *_Zx) noexcept
 {
 return (:: remquol(_Xx, _Yx, _Zx));
 }

               inline long double rint( long double _Xx) noexcept
 {
 return (:: rintl(_Xx));
 }

               inline long double round( long double _Xx) noexcept
 {
 return (:: roundl(_Xx));
 }

               inline long double scalbln( long double _Xx,
      long _Yx) noexcept
 {
 return (:: scalblnl(_Xx, _Yx));
 }

               inline long double scalbn( long double _Xx,
      int _Yx) noexcept
 {
 return (:: scalbnl(_Xx, _Yx));
 }

               inline long double sin( long double _Xx) noexcept
 {
 return (:: sinl(_Xx));
 }

               inline long double sinh( long double _Xx) noexcept
 {
 return (:: sinhl(_Xx));
 }

               inline long double sqrt( long double _Xx) noexcept
 {
 return (:: sqrtl(_Xx));
 }

               inline long double tan( long double _Xx) noexcept
 {
 return (:: tanl(_Xx));
 }

               inline long double tanh( long double _Xx) noexcept
 {
 return (:: tanhl(_Xx));
 }

               inline long double tgamma( long double _Xx) noexcept
 {
 return (:: tgammal(_Xx));
 }

               inline long double trunc( long double _Xx) noexcept
 {
 return (:: truncl(_Xx));
 }


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xtgmath.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xtgmath.h" 3
#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
template<class _Ty>
 struct _Promote_to_float
 {
 typedef typename conditional<is_integral<_Ty>::value,
  double, _Ty>::type type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Common_float_type
 {
 typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
 typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
 typedef typename conditional<is_same<_Ty1f, long double>::value
  || is_same<_Ty2f, long double>::value, long double,
  typename conditional<is_same<_Ty1f, double>::value
   || is_same<_Ty2f, double>::value, double,
   float>::type>::type type;
 };
}
# 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xtgmath.h" 3
template<class _Ty1,
 class _Ty2> inline
 typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
  && ::std:: is_arithmetic<_Ty2>::value,
  typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
 pow(const _Ty1 _Left, const _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: pow(type(_Left), type(_Right)));
 }


extern "C" double __cdecl acos( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double __cdecl asin( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double __cdecl atan( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double __cdecl atan2( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl ceil( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double __cdecl cos( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double __cdecl cosh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double __cdecl exp( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" double __cdecl fabs( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl floor( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double __cdecl fmod( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl frexp( double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl ldexp( double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double __cdecl log( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double __cdecl log10( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double __cdecl sin( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double __cdecl sinh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double __cdecl sqrt( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double __cdecl tan( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double __cdecl tanh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xtgmath.h" 3
inline float _Fma(float _Left, float _Middle, float _Right)
 {
 return (:: fmaf(_Left, _Middle, _Right));
 }

inline double _Fma(double _Left, double _Middle, double _Right)
 {
 return (:: fma(_Left, _Middle, _Right));
 }

inline long double _Fma(long double _Left, long double _Middle,
 long double _Right)
 {
 return (:: fmal(_Left, _Middle, _Right));
 }

template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (_Fma((type)_Left, (type)_Middle, (type)_Right));
 }



inline float _Remquo(float _Left, float _Right, int *_Pquo)
 {
 return (:: remquof(_Left, _Right, _Pquo));
 }

inline double _Remquo(double _Left, double _Right, int *_Pquo)
 {
 return (:: remquo(_Left, _Right, _Pquo));
 }

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
 {
 return (:: remquol(_Left, _Right, _Pquo));
 }

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
 remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (_Remquo((type)_Left, (type)_Right, _Pquo));
 }

extern "C" __declspec(dllimport) double __cdecl acosh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl asinh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl atanh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl cbrt( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl copysign( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl erf( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl erfc( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl expm1( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl exp2( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl fdim( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" __declspec(dllimport) double __cdecl fmax( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl fmin( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl hypot( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) int __cdecl ilogb( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl lgamma( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" __declspec(dllimport) long long __cdecl llrint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" __declspec(dllimport) long long __cdecl llround( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl log1p( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl log2( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl logb( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" __declspec(dllimport) long __cdecl lrint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" __declspec(dllimport) long __cdecl lround( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl nearbyint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl nextafter( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl nexttoward( double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl remainder( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" __declspec(dllimport) double __cdecl rint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl round( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl scalbln( double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl scalbn( double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl tgamma( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl trunc( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }

#pragma warning(pop)
#pragma pack(pop)
# 617 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cmath" 2 3


namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 2 3




#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
# 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 3
typedef enum
 {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1}
  float_denorm_style;


typedef enum
 {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3}
  float_round_style;


struct _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(false);
 static constexpr bool has_quiet_NaN = (bool)(false);
 static constexpr bool has_signaling_NaN = (bool)(false);
 static constexpr bool is_bounded = (bool)(false);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(false);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr bool is_specialized = (bool)(false);
 static constexpr bool tinyness_before = (bool)(false);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
 static constexpr int digits = (int)(0);
 static constexpr int digits10 = (int)(0);

 static constexpr int max_digits10 = (int)(0);

 static constexpr int max_exponent = (int)(0);
 static constexpr int max_exponent10 = (int)(0);
 static constexpr int min_exponent = (int)(0);
 static constexpr int min_exponent10 = (int)(0);
 static constexpr int radix = (int)(0);
 };


template<class _Ty>
 class numeric_limits
  : public _Num_base
 {
public:
 static constexpr _Ty (min)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty (max)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty lowest() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty round_error() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty infinity() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (_Ty());
  }
 };

template<class _Ty>
 class numeric_limits<const _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<const volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };


struct _Num_int_base
 : public _Num_base
 {
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(true);
 static constexpr bool is_integer = (bool)(true);
 static constexpr bool is_modulo = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr int radix = (int)(2);
 };


struct _Num_float_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
 static constexpr bool has_denorm_loss = (bool)(true);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


template<> class numeric_limits<char>
 : public _Num_int_base
 {
public:
 typedef char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-128));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (127);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)((-128) != 0);
 static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
 static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<wchar_t>
 : public _Num_int_base
 {
public:
 typedef wchar_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((_Ty)0x0000);
  }

 static constexpr _Ty (max)() noexcept
  {
  return ((_Ty)0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(0x0000 != 0);
 static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));

 static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<bool>
 : public _Num_int_base
 {
public:
 typedef bool _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (false);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (true);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(1);
 static constexpr int digits10 = (int)(0);
 };


template<> class numeric_limits<signed char>
 : public _Num_int_base
 {
public:
 typedef signed char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-128));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (127);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 - 1);
 static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
 };


template<> class numeric_limits<unsigned char>
 : public _Num_int_base
 {
public:
 typedef unsigned char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8);
 static constexpr int digits10 = (int)(8 * 301L / 1000);
 };


template<> class numeric_limits<short>
 : public _Num_int_base
 {
public:
 typedef short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-32768));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (32767);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (short) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

 };



template<> class numeric_limits<unsigned short>
 : public _Num_int_base
 {
public:
 typedef unsigned short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned short));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

 };



template<> class numeric_limits<char16_t>
 : public _Num_int_base
 {
public:
 typedef char16_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char16_t));
 static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);

 };


template<> class numeric_limits<int>
 : public _Num_int_base
 {
public:
 typedef int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-2147483647 - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (2147483647);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (int) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned int>
 : public _Num_int_base
 {
public:
 typedef unsigned int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned int));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

 };


template<> class numeric_limits<long>
 : public _Num_int_base
 {
public:
 typedef long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-2147483647L - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (2147483647L);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long>
 : public _Num_int_base
 {
public:
 typedef unsigned long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffUL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

 };


template<> class numeric_limits<char32_t>
 : public _Num_int_base
 {
public:
 typedef char32_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char32_t));
 static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);

 };


template<> class numeric_limits<long long>
 : public _Num_int_base
 {
public:
 typedef long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-9223372036854775807i64 - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (9223372036854775807i64);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long long>
 : public _Num_int_base
 {
public:
 typedef unsigned long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffffui64);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);

 };


template<> class numeric_limits<float>
 : public _Num_float_base
 {
public:
 typedef float _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (1.175494351e-38F);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (3.402823466e+38F);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.192092896e-07F);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5F);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (1.401298464e-45F);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_valf());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanf("0"));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansf("1"));
  }

 static constexpr int digits = (int)(24);
 static constexpr int digits10 = (int)(6);

 static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)128);
 static constexpr int max_exponent10 = (int)((int)38);
 static constexpr int min_exponent = (int)((int)(-125));
 static constexpr int min_exponent10 = (int)((int)(-37));
 };


template<> class numeric_limits<double>
 : public _Num_float_base
 {
public:
 typedef double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014e-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623158e+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131e-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (4.9406564584124654e-324);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan("0"));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans("1"));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);

 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)(-1021));
 static constexpr int min_exponent10 = (int)((int)(-307));
 };


template<> class numeric_limits<long double>
 : public _Num_float_base
 {
public:
 typedef long double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014e-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623158e+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131e-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5L);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (4.9406564584124654e-324);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan("0"));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans("1"));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);

 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)(-1021));
 static constexpr int min_exponent10 = (int)((int)(-307));
 };
# 1482 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\limits" 3
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\new" 1 3








#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)






namespace std {




typedef void (__cdecl * new_handler) ();



__declspec(dllimport) new_handler __cdecl set_new_handler( new_handler)
 noexcept;

__declspec(dllimport) new_handler __cdecl get_new_handler()
 noexcept;
}


#pragma warning(pop)
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 1 3







# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\utility" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\utility" 3
#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<class _Ty>

 constexpr const _Ty& _Min_value(const _Ty& _Left, const _Ty& _Right)
  noexcept(noexcept(_Right < _Left))
 {
 return (_Right < _Left ? _Right : _Left);
 }


template<class _Ty>

 constexpr const _Ty& _Max_value(const _Ty& _Left, const _Ty& _Right)
  noexcept(noexcept(_Left < _Right))
 {
 return (_Left < _Right ? _Right : _Left);
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
 {
 swap(*_Left, *_Right);
 }


template<class _Ty,
 size_t _Size,
 class> inline
 void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
  noexcept(_Is_nothrow_swappable<_Ty>::value)
 {
 if (&_Left != &_Right)
  {
  _Ty *_First1 = _Left;
  _Ty *_Last1 = _First1 + _Size;
  _Ty *_First2 = _Right;
  for (; _First1 != _Last1; ++_First1, ++_First2)
   ::std:: iter_swap(_First1, _First2);
  }
 }

template<class _Ty,
 class> inline
 void swap(_Ty& _Left, _Ty& _Right)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)

 {
 _Ty _Tmp = ::std:: move(_Left);
 _Left = ::std:: move(_Right);
 _Right = ::std:: move(_Tmp);
 }


template<class _Ty> inline
 void _Swap_adl(_Ty& _Left, _Ty& _Right)
  noexcept(_Is_nothrow_swappable<_Ty>::value)
 {
 swap(_Left, _Right);
 }


struct piecewise_construct_t
 {
 };

constexpr piecewise_construct_t piecewise_construct{};


template<class...>
 class tuple;

template<class _Ty1,
 class _Ty2>
 struct pair
 {
 typedef pair<_Ty1, _Ty2> _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 template<class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t<is_default_constructible<_Uty1>::value
      && is_default_constructible<_Uty2>::value> >
  constexpr pair()
  : first(), second()
  {
  }

 template<class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t<is_copy_constructible<_Uty1>::value
      && is_copy_constructible<_Uty2>::value>,
  enable_if_t<is_convertible<const _Uty1&, _Uty1>::value
    && is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
  constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
  : first(_Val1), second(_Val2)
  {
  }

 template<class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t<is_copy_constructible<_Uty1>::value
      && is_copy_constructible<_Uty2>::value>,
  enable_if_t<!is_convertible<const _Uty1&, _Uty1>::value
    || !is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
  constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
  : first(_Val1), second(_Val2)
  {
  }

 pair(const pair&) = default;
 pair(pair&&) = default;

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
      && is_constructible<_Ty2, const _Other2&>::value>,
  enable_if_t<is_convertible<const _Other1&, _Ty1>::value
    && is_convertible<const _Other2&, _Ty2>::value, int> = 0>
  constexpr pair(const pair<_Other1, _Other2>& _Right)
  : first(_Right.first), second(_Right.second)
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
      && is_constructible<_Ty2, const _Other2&>::value>,
  enable_if_t<!is_convertible<const _Other1&, _Ty1>::value
    || !is_convertible<const _Other2&, _Ty2>::value, int> = 0>
  constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
  : first(_Right.first), second(_Right.second)
  {
  }

 template<class _Other1,
  class _Other2>
  _Myt& operator=(const pair<_Other1, _Other2>& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }

 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   index_sequence<_Indexes1...>,
   index_sequence<_Indexes2...>);

 template<class... _Types1,
  class... _Types2> inline
  pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2);

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<is_convertible<_Other1, _Ty1>::value
    && is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<!is_convertible<_Other1, _Ty1>::value
    || !is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<is_convertible<_Other1, _Ty1>::value
    && is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr pair(pair<_Other1, _Other2>&& _Right)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Right.first)),
   second(::std:: forward<_Other2>(_Right.second))
  {
  }

 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_constructible<_Ty1, _Other1>::value
      && is_constructible<_Ty2, _Other2>::value>,
  enable_if_t<!is_convertible<_Other1, _Ty1>::value
    || !is_convertible<_Other2, _Ty2>::value, int> = 0>
  constexpr explicit pair(pair<_Other1, _Other2>&& _Right)
   noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))

  : first(::std:: forward<_Other1>(_Right.first)),
   second(::std:: forward<_Other2>(_Right.second))
  {
  }

 template<class _Other1,
  class _Other2>
  _Myt& operator=(pair<_Other1, _Other2>&& _Right)
  {
  first = ::std:: forward<_Other1>(_Right.first);
  second = ::std:: forward<_Other2>(_Right.second);
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right)
  noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))

  {
  first = ::std:: forward<_Ty1>(_Right.first);
  second = ::std:: forward<_Ty2>(_Right.second);
  return (*this);
  }

 _Myt& operator=(const _Myt& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }

 void swap(_Myt& _Right)
  noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)

  {
  if (this != ::std:: addressof(_Right))
   {
   _Swap_adl(first, _Right.first);
   _Swap_adl(second, _Right.second);
   }
  }

 _Ty1 first;
 _Ty2 second;
 };



template<class _Ty1,
 class _Ty2,
 class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline
 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
  noexcept(noexcept(_Left.swap(_Right)))
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first == _Right.first && _Left.second == _Right.second);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first < _Right.first ||
  (!(_Right.first < _Left.first) && _Left.second < _Right.second));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _Ty1,
 class _Ty2> inline
 constexpr pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type>
  make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
 {
 typedef pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type> _Mypair;
 return (_Mypair(::std:: forward<_Ty1>(_Val1),
  ::std:: forward<_Ty2>(_Val2)));
 }


 namespace rel_ops
  {
template<class _Ty> inline
 bool operator!=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty> inline
 bool operator>(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty> inline
 bool operator<=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty> inline
 bool operator>=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left < _Right));
 }
  }
}

namespace std {
template<class _Ty,
 size_t _Size>
 class array;


template<class _Tuple>
 struct tuple_size;

template<class _Ty,
 size_t _Size>
 struct tuple_size<array<_Ty, _Size> >
  : integral_constant<size_t, _Size>
 {
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_size<pair<_Ty1, _Ty2> >
 : integral_constant<size_t, 2>
 {
 };

template<class... _Types>
 struct tuple_size<tuple<_Types...> >
 : integral_constant<size_t, sizeof...(_Types)>
 {
 };


template<class _Tuple>
 struct tuple_size<const _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Tuple>
 struct tuple_size<volatile _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Tuple>
 struct tuple_size<const volatile _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Ty>
 constexpr size_t tuple_size_v = tuple_size<_Ty>::value;


template<size_t _Index,
 class _Tuple>
 struct tuple_element;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 struct tuple_element<_Idx, array<_Ty, _Size> >
 {
 static_assert(_Idx < _Size, "array index out of bounds");

 typedef _Ty type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<0, pair<_Ty1, _Ty2> >
 {
 typedef _Ty1 type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<1, pair<_Ty1, _Ty2> >
 {
 typedef _Ty2 type;
 };

template<size_t _Index>
 struct tuple_element<_Index, tuple<> >
 {
 static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
  "tuple index out of bounds");
 };

template<class _This,
 class... _Rest>
 struct tuple_element<0, tuple<_This, _Rest...> >
 {
 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<size_t _Index,
 class _This,
 class... _Rest>
 struct tuple_element<_Index, tuple<_This, _Rest...> >
  : public tuple_element<_Index - 1, tuple<_Rest...> >
 {
 };


template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;


template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 0>) noexcept
 {
 return (_Pr.first);
 }

template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 1>) noexcept
 {
 return (_Pr.second);
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
 return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  _Ctype;
 return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
  get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
 return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<0>(::std:: move(_Pr)));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<1>(::std:: move(_Pr)));
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
  get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
 return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<0>(::std:: move(_Pr)));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<1>(::std:: move(_Pr)));
 }


template<class _Ty,
 class _Other = _Ty> inline
 _Ty exchange(_Ty& _Val, _Other&& _New_val)
 {
 _Ty _Old_val = ::std:: move(_Val);
 _Val = ::std:: forward<_Other>(_New_val);
 return (_Old_val);
 }


template<class _Ty> inline
 constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
 {
 return (_Val);
 }

template<class _Ty>
 void as_const(const _Ty&&) = delete;



struct in_place_t
 {
 explicit in_place_t() = default;
 };
             constexpr in_place_t in_place{};

template<class>
 struct in_place_type_t
 {
 explicit in_place_type_t() = default;
 };
template<class _Ty>
              constexpr in_place_type_t<_Ty> in_place_type{};

template<size_t>
 struct in_place_index_t
 {
 explicit in_place_index_t() = default;
 };
template<size_t _Idx>
              constexpr in_place_index_t<_Idx> in_place_index{};

}
# 683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\utility" 3
#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
# 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
 {
 void _Orphan_all()
  {
  }

 void _Swap_all(_Container_base0&)
  {
  }
 };

struct _Iterator_base0
 {
 void _Adopt(const void *)
  {
  }

 const _Container_base0 *_Getcont() const
  {
  return (0);
  }
 };


struct _Container_proxy
 {
 _Container_proxy()
  : _Mycont(0), _Myfirstiter(0)
  {
  }

 const _Container_base12 *_Mycont;
 _Iterator_base12 *_Myfirstiter;
 };

struct _Container_base12
 {
public:
 _Container_base12()
  : _Myproxy(0)
  {
  }

 _Container_base12(const _Container_base12&)
  : _Myproxy(0)
  {
  }

 _Container_base12& operator=(const _Container_base12&)
  {
  return (*this);
  }

 ~_Container_base12() noexcept
  {
  _Orphan_all();
  }

 _Iterator_base12 **_Getpfirst() const
  {
  return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
  }

 void _Orphan_all();
 void _Swap_all(_Container_base12&);

 _Container_proxy *_Myproxy;
 };

struct _Iterator_base12
 {
public:
 _Iterator_base12()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 _Iterator_base12(const _Iterator_base12& _Right)
  : _Myproxy(0), _Mynextiter(0)
  {
  *this = _Right;
  }

 _Iterator_base12& operator=(const _Iterator_base12& _Right)
  {
  if (_Myproxy == _Right._Myproxy)
   ;
  else if (_Right._Myproxy != 0)
   _Adopt(_Right._Myproxy->_Mycont);
  else
   {




   }

  return (*this);
  }

 ~_Iterator_base12() noexcept
  {




  }

 void _Adopt(const _Container_base12 *_Parent)
  {
  if (_Parent == 0)
   {




   }
  else
   {
   _Container_proxy *_Parent_proxy = _Parent->_Myproxy;
# 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
   _Myproxy = _Parent_proxy;

   }
  }

 void _Clrcont()
  {
  _Myproxy = 0;
  }

 const _Container_base12 *_Getcont() const
  {
  return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
  }

 _Iterator_base12 **_Getpnext()
  {
  return (&_Mynextiter);
  }

 void _Orphan_me()
  {
# 230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
  }

 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;
 };


inline void _Container_base12::_Orphan_all()
 {
# 250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
 }

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
 {




 _Container_proxy *_Temp = _Myproxy;
 _Myproxy = _Right._Myproxy;
 _Right._Myproxy = _Temp;

 if (_Myproxy != 0)
  _Myproxy->_Mycont = (_Container_base12 *)this;
 if (_Right._Myproxy != 0)
  _Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
 }


typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;







struct _Zero_then_variadic_args_t
 {
 };

struct _One_then_variadic_args_t
 {
 };

template<class _Ty1,
 class _Ty2,
 bool = is_empty<_Ty1>::value && !is_final<_Ty1>::value>
 class _Compressed_pair final
  : private _Ty1

 {
private:
 _Ty2 _Myval2;

 typedef _Ty1 _Mybase;

public:
 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Ty1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }


 _Ty1& _Get_first() noexcept
  {
  return (*this);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (*this);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (*this);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (*this);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };

template<class _Ty1,
 class _Ty2>
 class _Compressed_pair<_Ty1, _Ty2, false> final

 {
private:
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public:
 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Myval1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }


 _Ty1& _Get_first() noexcept
  {
  return (_Myval1);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (_Myval1);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (_Myval1);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (_Myval1);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };


template<class _Ty,
 class = void>
 struct _Is_checked_helper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_checked_helper<_Ty, void_t<
  typename _Ty::_Unchecked_type> >
  : true_type
 {
 };


template<class _Iter> inline
 typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
 {
 return {};
 }


template<class _Iter>
 constexpr _Iter _Unchecked(_Iter _Src)
 {
 return (_Src);
 }







template<class _Iter> inline
 decltype(_Unchecked(::std:: declval<_Iter>())) _Unchecked_idl0(_Iter _Src)
 {
 return (_Unchecked(_Src));
 }
# 477 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _Iter,
 class _UIter>
 constexpr _Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
 {
 _Dest = _Src;
 return (_Dest);
 }
# 508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
struct input_iterator_tag
 {
 };

struct _Mutable_iterator_tag
 {
 };

struct output_iterator_tag
 : _Mutable_iterator_tag
 {
 };

struct forward_iterator_tag
 : input_iterator_tag, _Mutable_iterator_tag
 {
 };

struct bidirectional_iterator_tag
 : forward_iterator_tag
 {
 };

struct random_access_iterator_tag
 : bidirectional_iterator_tag
 {
 };


struct _General_ptr_iterator_tag
 {
 };

struct _Trivially_copyable_ptr_iterator_tag
 : _General_ptr_iterator_tag
 {
 };

struct _Really_trivial_ptr_iterator_tag
 : _Trivially_copyable_ptr_iterator_tag
 {
 };


struct _Any_tag
 {
 constexpr _Any_tag() noexcept = default;
 template<class _Ty>
  constexpr _Any_tag(_Ty&&) noexcept {}
 };


template<class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty&>
 struct iterator
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;

 typedef _Pointer pointer;
 typedef _Reference reference;
 };

template<class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base>
 struct _Iterator012
  : public _Base
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;

 typedef _Pointer pointer;
 typedef _Reference reference;
 };


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;


template<class,
 class = void>
 struct _Iterator_traits_base
 {
 };

template<class _Iter>
 struct _Iterator_traits_base<_Iter, void_t<
  typename _Iter::iterator_category,
  typename _Iter::value_type,
  typename _Iter::difference_type,
  typename _Iter::pointer,
  typename _Iter::reference
  > >
 {
 typedef typename _Iter::iterator_category iterator_category;
 typedef typename _Iter::value_type value_type;
 typedef typename _Iter::difference_type difference_type;

 typedef typename _Iter::pointer pointer;
 typedef typename _Iter::reference reference;
 };

template<class _Iter>
 struct iterator_traits
  : _Iterator_traits_base<_Iter>
 {
 };

template<class _Ty>
 struct iterator_traits<_Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;

 typedef _Ty *pointer;
 typedef _Ty& reference;
 };

template<class _Ty>
 struct iterator_traits<const _Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;

 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 };


template<class _Iter>
 using _Iter_value_t = typename iterator_traits<_Iter>::value_type;


template<class _Iter>
 using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;


template<class _Iter>
 using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;


template<class _Ty,
 class = void>
 struct _Is_iterator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty, void_t<
  typename iterator_traits<_Ty>::iterator_category
  > >
  : true_type
 {
 };



struct _Distance_unknown {};


template<class _Iter> inline
 _Distance_unknown _Idl_distance(const _Iter&, const _Iter&)
 {
 return {};
 }
# 708 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _Iter,
 class _Diff> inline
 auto _Unchecked_n(_Iter _Src, _Diff)
 {
 return (_Unchecked(_Src));
 }
# 752 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _Iter,
 class _Diff> inline
 auto _Unchecked_n_backward(_Iter _Src, _Diff)
 {
 return (_Unchecked(_Src));
 }
# 795 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _Ty1,
 class _Ty2>
 struct _Is_same_size
  : bool_constant<sizeof(_Ty1) == sizeof(_Ty2)>
 {
 };


template<class _Elem,
 bool _Is_enum = is_enum<_Elem>::value>
 struct _Unwrap_enum
 {
 typedef underlying_type_t<_Elem> type;
 };

template<class _Elem>
 struct _Unwrap_enum<_Elem, false>
 {
 typedef _Elem type;
 };


template<class _Ty1,
 class _Ty2>
 struct _Both_or_neither_bool
  : bool_constant<is_same<bool, _Ty1>::value == is_same<bool, _Ty2>::value>
 {
 };


template<class _Source,
 class _Dest>
 struct _Ptr_cat_helper
 {
 typedef typename _Unwrap_enum<_Source>::type _USource;
 typedef typename _Unwrap_enum<_Dest>::type _UDest;
 typedef conditional_t<
  conjunction<
   _Is_same_size<_USource, _UDest>,
   is_integral<_USource>,
   is_integral<_UDest>,
   _Both_or_neither_bool<_USource, _UDest>,

   negation<is_volatile<_Source>>,
   negation<is_volatile<_Dest>>
  >::value,
  _Really_trivial_ptr_iterator_tag,
  _General_ptr_iterator_tag> type;
 };

template<class _Elem>
 struct _Ptr_cat_helper<_Elem, _Elem>
 {
 typedef conditional_t<
  is_trivially_copyable<_Elem>::value,
  conditional_t<is_trivial<_Elem>::value,
   _Really_trivial_ptr_iterator_tag,
   _Trivially_copyable_ptr_iterator_tag>,
  _General_ptr_iterator_tag> type;
 };

template<class _Anything>
 struct _Ptr_cat_helper<_Anything *, const _Anything *>
 {
 typedef _Really_trivial_ptr_iterator_tag type;
 };

template<class _Source,
 class _Dest> inline
 _General_ptr_iterator_tag _Ptr_copy_cat(const _Source&, const _Dest&)
 {
 return {};
 }

template<class _Source,
 class _Dest> inline
 conditional_t<is_trivially_assignable<_Dest&, _Source&>::value,
  typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
  _General_ptr_iterator_tag>
  _Ptr_copy_cat(_Source * const&, _Dest * const&)
 {
 return {};
 }

template<class _Source,
 class _Dest> inline
 _General_ptr_iterator_tag _Ptr_move_cat(const _Source&, const _Dest&)
 {
 return {};
 }

template<class _Source,
 class _Dest> inline
 conditional_t<is_trivially_assignable<_Dest&, _Source>::value,
  typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
  _General_ptr_iterator_tag>
  _Ptr_move_cat(_Source * const&, _Dest * const&)
 {
 return {};
 }
# 1049 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _InIt,
 class _Diff> inline
 void _Advance1(_InIt& _Where, _Diff _Off, input_iterator_tag)
 {
# 1061 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _BidIt,
 class _Diff> inline
 void _Advance1(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
 {
 for (; 0 < _Off; --_Off)
  ++_Where;
 for (; _Off < 0; ++_Off)
  --_Where;
 }

template<class _RanIt,
 class _Diff> inline
 void _Advance1(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
 {
 _Where += _Off;
 }

template<class _InIt,
 class _Diff> inline
 void advance(_InIt& _Where, _Diff _Off)
 {

 _Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
 }


template<class _InIt> inline
 _Iter_diff_t<_InIt>
  _Distance1(_InIt _First, _InIt _Last, input_iterator_tag)
 {
 _Iter_diff_t<_InIt> _Off = 0;
 for (; _First != _Last; ++_First)
  ++_Off;

 return (_Off);
 }

template<class _RanIt> inline
 _Iter_diff_t<_RanIt>
  _Distance1(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
 {
 return (_Last - _First);
 }

template<class _InIt> inline
 _Iter_diff_t<_InIt>
  distance(_InIt _First, _InIt _Last)
 {
 return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
 }


template<class _InIt> inline
 _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
 {
 static_assert(is_base_of<input_iterator_tag, _Iter_cat_t<_InIt>>::value,
  "next requires input iterator");

 ::std:: advance(_First, _Off);
 return (_First);
 }


template<class _BidIt> inline
 _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
 {
 static_assert(is_base_of<bidirectional_iterator_tag, _Iter_cat_t<_BidIt>>::value,
  "prev requires bidirectional iterator");

 ::std:: advance(_First, -_Off);
 return (_First);
 }


template<class _Ty>
 struct pointer_traits;

template<class _Iterator>
 constexpr _Iterator _Operator_arrow(_Iterator _Target, true_type)
 {
 return (_Target);
 }

template<class _Iterator>
 constexpr decltype(auto) _Operator_arrow(_Iterator&& _Target, false_type)
 {
 return (::std:: forward<_Iterator>(_Target).operator->());
 }

template<class _RanIt>
 class reverse_iterator
  : public iterator<
   typename iterator_traits<_RanIt>::iterator_category,
   typename iterator_traits<_RanIt>::value_type,
   typename iterator_traits<_RanIt>::difference_type,
   typename iterator_traits<_RanIt>::pointer,
   typename iterator_traits<_RanIt>::reference>
 {
 typedef reverse_iterator<_RanIt> _Myt;

public:
 typedef typename iterator_traits<_RanIt>::difference_type difference_type;
 typedef typename iterator_traits<_RanIt>::pointer pointer;
 typedef typename iterator_traits<_RanIt>::reference reference;
 typedef _RanIt iterator_type;

 constexpr reverse_iterator()
  : current()
  {
  }

 constexpr explicit reverse_iterator(_RanIt _Right)
  : current(_Right)
  {
  }

 template<class _Other>
  constexpr reverse_iterator(const reverse_iterator<_Other>& _Right)
  : current(_Right.base())
  {
  }

 template<class _Other>
  constexpr _Myt& operator=(const reverse_iterator<_Other>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

 constexpr _RanIt base() const
  {
  return (current);
  }

 constexpr reference operator*() const
  {
  _RanIt _Tmp = current;
  return (*--_Tmp);
  }

 constexpr pointer operator->() const
  {
  _RanIt _Tmp = current;
  --_Tmp;
  return (_Operator_arrow(_Tmp, is_pointer<_RanIt>()));
  }

 constexpr _Myt& operator++()
  {
  --current;
  return (*this);
  }

 constexpr _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 constexpr _Myt& operator--()
  {
  ++current;
  return (*this);
  }

 constexpr _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }



 constexpr _Myt& operator+=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

 constexpr _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

 constexpr _Myt& operator-=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

 constexpr _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

 constexpr reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

protected:
 _RanIt current;
 };

template<class _RanIt>
 struct _Is_checked_helper<reverse_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt>
 constexpr reverse_iterator<_RanIt> operator+(
  typename reverse_iterator<_RanIt>::difference_type _Off,
  const reverse_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr auto operator-(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr bool operator==(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left.base() == _Right.base());
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr bool operator!=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr bool operator<(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right.base() < _Left.base());
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr bool operator>(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr bool operator<=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2>
 constexpr bool operator>=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt>
 constexpr reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
 {
 return (reverse_iterator<_RanIt>(_Iter));
 }



template<class _Container>
 auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
 auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
 auto inline end(_Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Container>
 auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array + _Size);
 }


template<class _Container>
 constexpr auto inline cbegin(const _Container& _Cont)
  noexcept(noexcept(::std:: begin(_Cont)))
  -> decltype(::std:: begin(_Cont))
 {
 return (::std:: begin(_Cont));
 }

template<class _Container>
 constexpr auto inline cend(const _Container& _Cont)
  noexcept(noexcept(::std:: end(_Cont)))
  -> decltype(::std:: end(_Cont))
 {
 return (::std:: end(_Cont));
 }


template<class _Container>
 auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
 auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
 auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Container>
 auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Ty,
 size_t _Size> inline
 reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array + _Size));
 }

template<class _Ty,
 size_t _Size> inline
 reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array));
 }

template<class _Elem> inline
 reverse_iterator<const _Elem *>
  rbegin(initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.end()));
 }

template<class _Elem> inline
 reverse_iterator<const _Elem *>
  rend(initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.begin()));
 }


template<class _Container>
 auto inline crbegin(const _Container& _Cont)
  -> decltype(::std:: rbegin(_Cont))
 {
 return (::std:: rbegin(_Cont));
 }

template<class _Container>
 auto inline crend(const _Container& _Cont)
  -> decltype(::std:: rend(_Cont))
 {
 return (::std:: rend(_Cont));
 }


template<class _Container>
 constexpr auto inline size(const _Container& _Cont)
  -> decltype(_Cont.size())
 {
 return (_Cont.size());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr size_t size(const _Ty(&)[_Size]) noexcept
 {
 return (_Size);
 }

template<class _Container>
 constexpr auto inline empty(const _Container& _Cont)
  -> decltype(_Cont.empty())
 {
 return (_Cont.empty());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr bool empty(const _Ty(&)[_Size]) noexcept
 {
 return (false);
 }

template<class _Elem> inline
 constexpr bool empty(
  initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.size() == 0);
 }

template<class _Container>
 constexpr auto inline data(_Container& _Cont)
  -> decltype(_Cont.data())
 {
 return (_Cont.data());
 }

template<class _Container>
 constexpr auto inline data(const _Container& _Cont)
  -> decltype(_Cont.data())
 {
 return (_Cont.data());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Elem> inline
 constexpr const _Elem *data(
  initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Ty,
 size_t _Size>
 class _Array_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty&,
   _Iterator_base>
 {
public:
 typedef _Array_const_iterator<_Ty, _Size> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 enum {_EEN_SIZE = _Size};

 _Array_const_iterator()
  : _Ptr(0)
  {
  }

 explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
  : _Ptr(_Parg + _Off)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

 reference operator*() const
  {
  return (*_Ptr);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  return (_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  return (_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }

 pointer _Ptr;
# 1882 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size>&
  _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
   typename _Array_const_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size> operator+(
  typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
  _Array_const_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _Ty,
 size_t _Size>
 class _Array_iterator
  : public _Array_const_iterator<_Ty, _Size>
 {
public:
 typedef _Array_iterator<_Ty, _Size> _Myiter;
 typedef _Array_const_iterator<_Ty, _Size> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;

 _Array_iterator()
  {
  }

 explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
  : _Mybase(_Parg, _Off)
  {
  }
 enum {_EEN_SIZE = _Size};
 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  ((_Mybase *)this)->_Rechecked(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return ((pointer)((_Mybase *)this)->_Unchecked());
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size>&
  _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
   typename _Array_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size> operator+(
  typename _Array_iterator<_Ty, _Size>::difference_type _Off,
  _Array_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _RanIt>
 class move_iterator
 {
public:
 typedef move_iterator<_RanIt> _Myt;
 typedef typename iterator_traits<_RanIt>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_RanIt>::value_type
  value_type;
 typedef typename iterator_traits<_RanIt>::difference_type
  difference_type;
 typedef _RanIt pointer;
 typedef typename iterator_traits<_RanIt>::reference _Ref0;
 typedef conditional_t<is_reference<_Ref0>::value,
  remove_reference_t<_Ref0>&&, _Ref0> reference;
 typedef _RanIt iterator_type;

 move_iterator()
  : current()
  {
  }

 explicit move_iterator(iterator_type _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2>
  move_iterator(const move_iterator<_RanIt2>& _Right)
  : current(_Right.base())
  {
  }

 template<class _RanIt2>
  _Myt& operator=(const move_iterator<_RanIt2>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

 _RanIt base() const
  {
  return (current);
  }

 reference operator*() const
  {
  return (static_cast<reference>(*current));
  }

 pointer operator->() const
  {
  return (current);
  }

 _Myt& operator++()
  {
  ++current;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  --current;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 template<class _RanIt2>
  bool _Equal(const move_iterator<_RanIt2>& _Right) const
  {
  return (current == _Right.base());
  }



 _Myt& operator+=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

 _Myt& operator-=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

 _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

 reference operator[](difference_type _Off) const
  {
  return (::std:: move(current[_Off]));
  }

 template<class _RanIt2>
  bool _Less(const move_iterator<_RanIt2>& _Right) const
  {
  return (current < _Right.base());
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (current - _Right.base());
  }

protected:
 iterator_type current;
 };

template<class _RanIt>
 struct _Is_checked_helper<move_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
 move_iterator<_RanIt>
  operator+(_Diff _Off,
  const move_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
 auto inline operator-(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
   -> decltype(_Left.base() - _Right.base())
 {
 return (_Left.base() - _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator==(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator!=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
 move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
 {
 return (move_iterator<_RanIt>(_Iter));
 }


template<class _Traits>
 struct _Char_traits_eq
 {
 typedef typename _Traits::char_type _Elem;

 bool operator()(_Elem _Left, _Elem _Right) const
  {
  return (_Traits::eq(_Left, _Right));
  }
 };


template<class _Traits>
 struct _Char_traits_lt
 {
 typedef typename _Traits::char_type _Elem;

 bool operator()(_Elem _Left, _Elem _Right) const
  {
  return (_Traits::lt(_Left, _Right));
  }
 };


template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_memmove(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 const char * const _First_ch = reinterpret_cast<const char *>(_First);
 const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
 char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
 const size_t _Count = _Last_ch - _First_ch;
 :: memmove(_Dest_ch, _First_ch, _Count);
 return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {

 return (_Copy_unchecked1(_First, _Last,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
                            ;
 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked_n(_Dest, _Idl_distance(_UFirst, _ULast));
 return (_Rechecked(_Dest,
  _Copy_unchecked(_UFirst, _ULast, _UDest)));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt copy(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Copy_no_deprecate(_First, _Last, _Dest));
 }
# 2368 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag)
 {
 if (0 < _Count)
  {
  *_Dest = *_First;
  while (0 < --_Count)
   *++_Dest = *++_First;
  return (++_Dest);
  }

 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
  _OutIt _Dest, _General_ptr_iterator_tag)
 {


 return (_Copy_n_unchecked2(_First, _Count,
  _Dest, _Iter_cat_t<_InIt>()));
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 if (0 < _Count)
  return (_Copy_memmove(_First, _First + _Count, _Dest));
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n_unchecked(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 return (_Copy_n_unchecked1(_First, _Count,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {

 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Rechecked(_Dest,
  _Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
 }
# 2482 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 const char * const _First_ch = reinterpret_cast<const char *>(_First);
 const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
 char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
 const size_t _Count = _Last_ch - _First_ch;
 return (static_cast<_BidIt2>(
  :: memmove(_Dest_ch - _Count, _First_ch, _Count)));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = *--_Last;
 return (_Dest);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_backward_memmove(_First, _Last, _Dest));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                            ;
 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked_n_backward(_Dest, _Idl_distance(_UFirst, _ULast));
 return (_Rechecked(_Dest,
  _Copy_backward_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest))));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = ::std:: move(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_unchecked(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {

 return (_Move_unchecked1(_First, _Last,
  _Dest, _Ptr_move_cat(_First, _Dest)));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_no_deprecate(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {

                            ;
 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked_n(_Dest, _Idl_distance(_UFirst, _ULast));
 return (_Rechecked(_Dest,
  _Move_unchecked(_UFirst, _ULast, _UDest)));
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Move_no_deprecate(_First, _Last, _Dest));
 }
# 2593 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = ::std:: move(*--_Last);
 return (_Dest);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
 {
 return (_Copy_backward_memmove(_First, _Last, _Dest));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {

 return (_Move_backward_unchecked1(_First, _Last,
  _Dest, _Ptr_move_cat(_First, _Dest)));
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                            ;
 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked_n_backward(_Dest, _Idl_distance(_UFirst, _ULast));
 return (_Rechecked(_Dest,
  _Move_backward_unchecked(_UFirst, _ULast, _UDest)));
 }


template<class _Ty>
 struct _Is_character
  : false_type
  {
  };

template<>
 struct _Is_character<char>
  : true_type
  {
  };

template<>
 struct _Is_character<signed char>
  : true_type
  {
  };

template<>
 struct _Is_character<unsigned char>
  : true_type
  {
  };

template<class _FwdIt,
 class _Ty>
 struct _Fill_memset_is_safe_helper
 {
 typedef _Iter_value_t<_FwdIt> _Value_type;
 typedef _Conjunction_t<
  is_pointer<_FwdIt>,
  disjunction<
   conjunction<
    _Is_character<_Ty>,
    _Is_character<_Value_type>>,
   conjunction<
    is_same<bool, _Ty>,
    is_same<bool, _Value_type>>
  >> type;
 };

template<class _FwdIt,
 class _Ty> inline
 typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
 _Fill_memset_is_safe(const _FwdIt&, const _Ty&)
 {
 return {};
 }

template<class _FwdIt,
 class _Ty> inline
 void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  *_First = _Val;
 }

template<class _FwdIt,
 class _Ty> inline
 void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Ty> inline
 void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
 }

template<class _FwdIt,
 class _Ty> inline
 void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 _Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, false_type)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest)
  *_Dest = _Val;
 return (_Dest);
 }

template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, true_type)
 {
 if (0 < _Count)
  {
  :: memset(_Dest, _Val, _Count);
  return (_Dest + _Count);
  }

 return (_Dest);
 }

template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n_unchecked(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {

 return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));
 }

template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 return (_Rechecked(_Dest,
  _Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
 }


template<class _Elem1,
 class _Elem2>
 struct _Value_equality_is_bitwise_equality
  : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
 {



 };

template<class _Elem1,
 class _Elem2,
 class _Pr>
 struct _Equal_memcmp_is_safe_helper
  : false_type
 {

 };

template<class _Elem1,
 class _Elem2>
 struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
  : _Conjunction_t<
   _Is_same_size<_Elem1, _Elem2>,
   is_integral<_Elem1>,
   is_integral<_Elem2>,
   negation<is_same<bool, _Elem1>>,
   negation<is_same<bool, _Elem2>>,
   negation<is_volatile<_Elem1>>,
   negation<is_volatile<_Elem2>>,


   _Value_equality_is_bitwise_equality<_Elem1, _Elem2>
  >
 {
 };

template<class _Elem1,
 class _Elem2>
 struct _Equal_memcmp_is_safe_helper<_Elem1 *, _Elem2 *, equal_to<>>
  : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
 {
 };

template<class _Elem>
 struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
  : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
 {
 };

template<class _Elem>
 struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
  : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
 {

 };

template<class _Iter1,
 class _Iter2,
 class _Pr> inline
 false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
 {
 return {};
 }

template<class _Obj1,
 class _Obj2,
 class _Pr> inline
 typename _Equal_memcmp_is_safe_helper<
  remove_const_t<_Obj1>,
  remove_const_t<_Obj2>,
  _Pr>::type
  _Equal_memcmp_is_safe(_Obj1 * const&, _Obj2 * const&, const _Pr&)
 {
 return {};
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred, false_type)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (true);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr&, true_type)
 {
 const char * const _First1_ch = reinterpret_cast<const char *>(_First1);
 const char * const _First2_ch = reinterpret_cast<const char *>(_First2);
 const size_t _Count = reinterpret_cast<const char *>(_Last1) - _First1_ch;
 return (:: memcmp(_First1_ch, _First2_ch, _Count) == 0);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred)
 {
 return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,
  _Equal_memcmp_is_safe(_First1, _First2, _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr& _Pred)
 {
                              ;
 const auto _UFirst1 = _Unchecked(_First1);
 const auto _ULast1 = _Unchecked(_Last1);
 const auto _UFirst2 = _Unchecked_n(_First2, _Idl_distance(_UFirst1, _ULast1));
 return (_Equal_unchecked(_UFirst1, _ULast1, _UFirst2, _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
 return (_Equal_no_deprecate(_First1, _Last1, _First2, _Pred));
 }
# 2908 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2)
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }
# 2930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
   input_iterator_tag, input_iterator_tag)
 {

 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
   random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
 return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
 }


template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: equal(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _Elem1,
 class _Elem2,
 class _FTy>
 struct _Lex_compare_check_element_types_helper
  : _Conjunction_t<
   _Is_character<_Elem1>,
   _Is_character<_Elem2>,
   _Is_character<_FTy>,
   is_unsigned<_FTy>
  >
 {
 };

template<class _Elem1,
 class _Elem2>
 struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
  : _Conjunction_t<
   _Is_character<_Elem1>,
   _Is_character<_Elem2>,
   is_unsigned<_Elem1>,
   is_unsigned<_Elem2>
  >
 {
 };

template<class _Memcmp_pr>
 struct _Lex_compare_optimize
 {
 };

template<class _Memcmp_pr,
 class _Obj1,
 class _Obj2,
 class _FTy>
 using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
  _Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
  _Memcmp_pr, void>>;

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 _Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
 {

 return {};
 }

template<class _Obj1,
 class _Obj2,
 class _FTy> inline
 _Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
  _Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const less<_FTy>&)
 {
 return {};
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred, _Lex_compare_optimize<void>)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  {
  if (_Pred(*_First1, *_First2))
   return (true);
  else if (_Pred(*_First2, *_First1))
   return (false);
  }

 return (_First1 == _Last1 && _First2 != _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr,
 class _Memcmp_pr> inline
 bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr&, _Lex_compare_optimize<_Memcmp_pr>)
 {
 const size_t _Num1 = _Last1 - _First1;
 const size_t _Num2 = _Last2 - _First2;
 const int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
 return (_Memcmp_pr{}(_Ans, 0) || _Ans == 0 && _Num1 < _Num2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
 {
 return (_Lex_compare_unchecked1(_First1, _Last1, _First2, _Last2, _Pred,
  _Lex_compare_memcmp_classify(_First1, _First2, _Pred)));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Lex_compare_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _InIt1,
 class _InIt2> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: lexicographical_compare(_First1, _Last1,
  _First2, _Last2, less<>()));
 }


template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
 {
 return ((-128) <= _Val && _Val <= 127);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
 {
 return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
 {
 return (_Val <= 127);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
 {
 return (0 <= _Val && _Val <= 0xff);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
 {
 return (_Val <= 0xff);
 }

template<class _InIt,
 class _Ty> inline
 bool _Within_limits(_InIt, const _Ty& _Val)
 {
 typedef typename remove_pointer<_InIt>::type _Elem;
 return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
  integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
 }

template<class _InIt> inline
 bool _Within_limits(_InIt, const bool&)
 {
 return (true);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
 {
 if (!_Within_limits(_First, _Val))
  return (_Last);
 _First = static_cast<_InIt>(:: memchr(
  _First, static_cast<unsigned char>(_Val), _Last - _First));
 return (_First ? _First : _Last);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   break;
 return (_First);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
 {

 typedef integral_constant<bool,
  (is_same<_InIt, char *>::value
  || is_same<_InIt, signed char *>::value
  || is_same<_InIt, unsigned char *>::value
  || is_same<_InIt, const char *>::value
  || is_same<_InIt, const signed char *>::value
  || is_same<_InIt, const unsigned char *>::value)
  && is_integral<_Ty>::value
 > _Memchr_opt;
 return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));
 }

template<class _InIt,
 class _Ty> inline
 _InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   break;
 return (_First);
 }


template<class _InIt,
 class _Ty> inline
 _Iter_diff_t<_InIt>
  _Count_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
 _Iter_diff_t<_InIt> _Count = 0;

 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Ty> inline
 _Iter_diff_t<_InIt>
  count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Count_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _Iter_diff_t<_InIt>
  _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
 {
 _Iter_diff_t<_InIt> _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   ++_Count;
 return (_Count);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr&,
  forward_iterator_tag, forward_iterator_tag)
 {
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr& _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag)
 {

 while (_Pred(*--_Last1, *--_Last2))
  ;
 ++_Last1;
 ++_Last2;
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
 {
 _Trim_matching_suffixes(_Last1, _Last2, _Pred,
  _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
 for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
  if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
   {
   _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
   if (_Count2 == 0)
    return (false);
   _FwdIt1 _Skip1 = ::std:: next(_Next1);
   _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
   if (_Count2 != _Count1)
    return (false);
   }

 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr& _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   _FwdIt2 _Last2 = ::std:: next(_First2,
    ::std:: distance(_First1, _Last1));
   return (_Check_match_counts(_First1, _Last1,
    _First2, _Last2, _Pred));
   }

 return (true);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_no_deprecate(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr& _Pred)
 {
                              ;
 const auto _UFirst1 = _Unchecked(_First1);
 const auto _ULast1 = _Unchecked(_Last1);
 const auto _UFirst2 = _Unchecked_n(_First2, _Idl_distance(_UFirst1, _ULast1));
 return (_Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
 return (_Is_permutation_no_deprecate(_First1, _Last1, _First2, _Pred));
 }
# 3345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, equal_to<>()));
 }
# 3367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
  forward_iterator_tag, forward_iterator_tag)
 {

 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   if (::std:: distance(_First1, _Last1)
    != ::std:: distance(_First2, _Last2))
    return (false);
   else
    return (_Check_match_counts(_First1, _Last1,
     _First2, _Last2, _Pred));
   }

 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
  random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
 return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {

                              ;
                              ;
 return (_Is_permutation_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
  _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, _Last2, equal_to<>()));
 }


template<class _BidIt> inline
 void _Reverse_unchecked(_BidIt _First, _BidIt _Last)
 {
 for (; _First != _Last && _First != --_Last; ++_First)
  ::std:: iter_swap(_First, _Last);
 }

template<class _BidIt> inline
 void reverse(_BidIt _First, _BidIt _Last)
 {
                            ;
 _Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));
 }


template<class _FwdIt> inline
 _FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag)
 {
 for (_FwdIt _Next = _Mid, _Res = _Last; ; )
  {
  ::std:: iter_swap(_First, _Next);
  if (++_First == _Mid)
   {
   if (++_Next == _Last)
    return (_Res == _Last ? _Mid : _Res);
   else
    _Mid = _Next;
   }
  else if (++_Next == _Last)
   {
   if (_Res == _Last)
    _Res = _First;
   _Next = _Mid;
   }
  }
 }

template<class _BidIt> inline
 pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last)
 {
 while (_First != _Sentinel && _Last != _Sentinel)
  ::std:: iter_swap(_First++, --_Last);
 return (::std:: make_pair(_First, _Last));
 }

template<class _BidIt> inline
 _BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag)
 {
 _Reverse_unchecked(_First, _Mid);
 _Reverse_unchecked(_Mid, _Last);
 pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
 _Reverse_unchecked(_Tmp.first, _Tmp.second);
 return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
 }

template<class _RanIt> inline
 _RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag)
 {
 _Reverse_unchecked(_First, _Mid);
 _Reverse_unchecked(_Mid, _Last);
 _Reverse_unchecked(_First, _Last);
 return (_First + (_Last - _Mid));
 }

template<class _FwdIt> inline
 _FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
 if (_First == _Mid)
  return (_Last);
 if (_Mid == _Last)
  return (_First);
 return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
 }

template<class _FwdIt> inline
 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
                           ;
                          ;
 return (_Rechecked(_First,
  _Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
  _Unchecked(_Last))));
 }


template<class _Diff,
 class _Urng>
 class _Rng_from_urng
 {
public:
 typedef typename make_unsigned<_Diff>::type _Ty0;
 typedef typename _Urng::result_type _Ty1;

 typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
  _Ty0, _Ty1>::type _Udiff;


 explicit _Rng_from_urng(_Urng& _Func)
  : _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
  {
  for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
   --_Bits;
  }

 _Diff operator()(_Diff _Index)
  {
  for (; ; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while (_Mask < _Udiff(_Index - 1))
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits();
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if (_Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff(_Index - 1))
    return (_Ret % _Index);
   }
  }

 _Udiff _Get_all_bits()
  {
  _Udiff _Ret = 0;

  for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
   _Num += _Bits)
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits();
   }

  return (_Ret);
  }

 _Rng_from_urng(const _Rng_from_urng&) = delete;
 _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
 _Udiff _Get_bits()
  {
  for (; ; )
   {
   _Udiff _Val = _Ref() - (_Urng::min)();

   if (_Val <= _Bmask)
    return (_Val);
   }
  }

 _Urng& _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };


template<class _Elem>
 class __declspec(dllimport) _Yarn
 {
public:
 typedef _Yarn<_Elem> _Myt;

                    _Yarn()
  : _Myptr(0), _Nul(0)
  {
  }

                    _Yarn(const _Myt& _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

                    _Yarn(const _Elem * _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  return (*this = _Right._Myptr);
  }

 _Myt& operator=(const _Elem * _Right)
  {
  if (_Myptr != _Right)
   {
   _Tidy();

   if (_Right != 0)
    {
    const _Elem *_Ptr = _Right;
    while (*_Ptr != (_Elem)0)
     ++_Ptr;
    size_t _Count = ((const char *)++_Ptr - (const char *)_Right);






    _Myptr = (_Elem *):: malloc(_Count);


    if (_Myptr != 0)
     :: memcpy(_Myptr, _Right, _Count);
    }
   }

  return (*this);
  }

                    ~_Yarn() noexcept
  {
  _Tidy();
  }

 bool empty() const
  {
  return (_Myptr == 0);
  }

         const _Elem * c_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

 bool _Empty() const
  {
  return (_Myptr == 0);
  }

         const _Elem * _C_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

private:
 void _Tidy()
  {
  if (_Myptr != 0)





   :: free(_Myptr);


  _Myptr = 0;
  }

 _Elem * _Myptr;
 _Elem _Nul;
 };



template<class _Container>
 class back_insert_iterator
  : public _Outit
 {
public:
 using container_type = _Container;

 explicit back_insert_iterator(_Container& _Cont)
  : container(::std:: addressof(_Cont))
  {
  }

 back_insert_iterator& operator=(const typename _Container::value_type& _Val)
  {
  container->push_back(_Val);
  return (*this);
  }

 back_insert_iterator& operator=(typename _Container::value_type&& _Val)
  {
  container->push_back(::std:: move(_Val));
  return (*this);
  }

 back_insert_iterator& operator*()
  {
  return (*this);
  }

 back_insert_iterator& operator++()
  {
  return (*this);
  }

 back_insert_iterator operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<back_insert_iterator<_Container> >
  : public true_type
 {
 };



template<class _Container> inline
 back_insert_iterator<_Container> back_inserter(_Container& _Cont)
 {
 return (back_insert_iterator<_Container>(_Cont));
 }



template<class _Ty,
 class _Alloc,
 class = void>
 struct _Has_allocator_type
  : false_type
 {
 };

template<class _Ty,
 class _Alloc>
 struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
  : is_convertible<_Alloc, typename _Ty::allocator_type>::type
 {
 };


struct allocator_arg_t
 {
 };

constexpr allocator_arg_t allocator_arg{};

[[noreturn]] __declspec(dllimport) void __cdecl _Xbad_alloc();
[[noreturn]] __declspec(dllimport) void __cdecl _Xinvalid_argument( const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xlength_error( const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xout_of_range( const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xoverflow_error( const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xruntime_error( const char *);
}

namespace std {

template<class _Ty,
 class _Alloc>
 struct uses_allocator
  : _Has_allocator_type<_Ty, _Alloc>::type
 {
 };

template<class _Ty,
 class _Alloc>
 constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
}

#pragma warning(pop)
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



#pragma warning(disable: 4494)






namespace std {
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 3
inline
 __declspec(allocator) void *_Allocate(size_t _Count, size_t _Sz,
  bool _Try_aligned_allocation = true)
 {
 void *_Ptr = 0;

 if (_Count == 0)
  return (_Ptr);


 if ((size_t)(-1) / _Sz < _Count)
  _Xbad_alloc();
 const size_t _User_size = _Count * _Sz;


 if (_Try_aligned_allocation
  && 4096 <= _User_size)
  {
  static_assert(sizeof (void *) < 32,
   "Big allocations should at least match vector register size");
  const size_t _Block_size = (sizeof(void *) + 32 - 1) + _User_size;
  if (_Block_size <= _User_size)
   _Xbad_alloc();
  const uintptr_t _Ptr_container =
   reinterpret_cast<uintptr_t>(::operator new(_Block_size));
  { if (!(_Ptr_container != 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  _Ptr = reinterpret_cast<void *>((_Ptr_container + (sizeof(void *) + 32 - 1))
   & ~(32 - 1));
  static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;




  }
 else




  {
  _Ptr = ::operator new(_User_size);
  { if (!(_Ptr != 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  }
 return (_Ptr);
 }


inline
 void _Deallocate(void * _Ptr, size_t _Count, size_t _Sz)
 {

 { if (!(_Count <= (size_t)(-1) / _Sz)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
 const size_t _User_size = _Count * _Sz;
 if (4096 <= _User_size)
  {
  const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
  { if (!((_Ptr_user & (32 - 1)) == 0)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

  const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
  const uintptr_t _Ptr_container =
   *reinterpret_cast<uintptr_t *>(_Ptr_ptr);
# 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 3
  { if (!(_Ptr_container < _Ptr_user)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };






  { if (!(sizeof(void *) <= _Ptr_user - _Ptr_container)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };



  { if (!(_Ptr_user - _Ptr_container <= (sizeof(void *) + 32 - 1))) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };


  _Ptr = reinterpret_cast<void *>(_Ptr_container);
  }






 ::operator delete(_Ptr);
 }


template<class _Ty,
 class... _Types> inline
 void _Construct_in_place(_Ty& _Obj, _Types&&... _Args)
  noexcept((is_nothrow_constructible<_Ty, _Types...>::value))
 {
 ::new (const_cast<void *>(static_cast<const volatile void *>(::std:: addressof(_Obj))))
  _Ty(::std:: forward<_Types>(_Args)...);
 }


template<class _Alty>
 struct _Is_simple_alloc
  : _Cat_base<is_same<typename _Alty::size_type, size_t>::value
  && is_same<typename _Alty::difference_type, ptrdiff_t>::value
  && is_same<typename _Alty::pointer,
   typename _Alty::value_type *>::value
  && is_same<typename _Alty::const_pointer,
   const typename _Alty::value_type *>::value
  && is_same<typename _Alty::reference,
   typename _Alty::value_type&>::value
  && is_same<typename _Alty::const_reference,
   const typename _Alty::value_type&>::value>
 {
 };


template<class _Value_type>
 struct _Simple_types
 {
 typedef _Value_type value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 };


template<class _Ty>
 struct _Get_first_parameter;

template<template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Get_first_parameter<_Ty<_First, _Rest...> >
 {
 typedef _First type;
 };


template<class _Newfirst,
 class _Ty>
 struct _Replace_first_parameter;

template<class _Newfirst,
 template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
 {
 typedef _Ty<_Newfirst, _Rest...> type;
 };


template<class _Ty,
 class = void>
 struct _Get_element_type
 {
 typedef typename _Get_first_parameter<_Ty>::type type;
 };

template<class _Ty>
 struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>>
 {
 typedef typename _Ty::element_type type;
 };


template<class _Ty,
 class = void>
 struct _Get_ptr_difference_type
 {
 typedef ptrdiff_t type;
 };

template<class _Ty>
 struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>>
 {
 typedef typename _Ty::difference_type type;
 };


template<class _Ty,
 class _Other,
 class = void>
 struct _Get_rebind_alias
 {
 typedef typename _Replace_first_parameter<_Other, _Ty>::type type;
 };

template<class _Ty,
 class _Other>
 struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>>
 {
 typedef typename _Ty::template rebind<_Other> type;
 };


template<class _Ty>
 struct pointer_traits
 {
 typedef typename _Get_element_type<_Ty>::type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

 template<class _Other>
  using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

 typedef typename _If<is_void<element_type>::value,
  char&,
  typename add_lvalue_reference<element_type>::type>::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (_Ty::pointer_to(_Val));
  }
 };


template<class _Ty>
 struct pointer_traits<_Ty *>
 {
 typedef _Ty element_type;
 typedef _Ty *pointer;
 typedef ptrdiff_t difference_type;

 template<class _Other>
  using rebind = _Other *;

 typedef typename _If<is_void<_Ty>::value,
  char&,
  typename add_lvalue_reference<_Ty>::type>::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (::std:: addressof(_Val));
  }
 };


template<class _Ty> inline
 void _Destroy_in_place(_Ty& _Obj) noexcept
 {
 _Obj.~_Ty();
 }


template<class _Ptrty> inline
 auto _Const_cast(_Ptrty _Ptr)
 {
 using _Elem = typename pointer_traits<_Ptrty>::element_type;
 using _Modifiable = remove_const_t<_Elem>;
 using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

 return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr)));
 }

template<class _Ty> inline
 auto _Const_cast(_Ty * _Ptr)
 {
 return (const_cast<remove_const_t<_Ty> *>(_Ptr));
 }


template<class _Ty,
 class = void>
 struct _Get_pointer_type
 {
 typedef typename _Ty::value_type * type;
 };

template<class _Ty>
 struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>>
 {
 typedef typename _Ty::pointer type;
 };


template<class _Ty,
 class = void>
 struct _Get_const_pointer_type
 {
 typedef typename _Get_pointer_type<_Ty>::type _Ptrty;
 typedef typename _Ty::value_type _Valty;
 typedef typename pointer_traits<_Ptrty>::template rebind<const _Valty> type;
 };

template<class _Ty>
 struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>>
 {
 typedef typename _Ty::const_pointer type;
 };


template<class _Ty,
 class = void>
 struct _Get_void_pointer_type
 {
 typedef typename _Get_pointer_type<_Ty>::type _Ptrty;
 typedef typename pointer_traits<_Ptrty>::template rebind<void> type;
 };

template<class _Ty>
 struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>>
 {
 typedef typename _Ty::void_pointer type;
 };


template<class _Ty,
 class = void>
 struct _Get_const_void_pointer_type
 {
 typedef typename _Get_pointer_type<_Ty>::type _Ptrty;
 typedef typename pointer_traits<_Ptrty>::template rebind<const void> type;
 };

template<class _Ty>
 struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>>
 {
 typedef typename _Ty::const_void_pointer type;
 };


template<class _Ty,
 class = void>
 struct _Get_difference_type
 {
 typedef typename _Get_pointer_type<_Ty>::type _Ptrty;
 typedef typename pointer_traits<_Ptrty>::difference_type type;
 };

template<class _Ty>
 struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>>
 {
 typedef typename _Ty::difference_type type;
 };


template<class _Ty,
 class = void>
 struct _Get_size_type
 {
 typedef make_unsigned_t<typename _Get_difference_type<_Ty>::type> type;
 };

template<class _Ty>
 struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>>
 {
 typedef typename _Ty::size_type type;
 };


template<class _Ty,
 class = void>
 struct _Get_propagate_on_container_copy
 {
 typedef false_type type;
 };

template<class _Ty>
 struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>>
 {
 typedef typename _Ty::propagate_on_container_copy_assignment type;
 };


template<class _Ty,
 class = void>
 struct _Get_propagate_on_container_move
 {
 typedef false_type type;
 };

template<class _Ty>
 struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>>
 {
 typedef typename _Ty::propagate_on_container_move_assignment type;
 };


template<class _Ty,
 class = void>
 struct _Get_propagate_on_container_swap
 {
 typedef false_type type;
 };

template<class _Ty>
 struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>>
 {
 typedef typename _Ty::propagate_on_container_swap type;
 };


template<class _Ty,
 class = void>
 struct _Get_is_always_equal
 {
 typedef typename is_empty<_Ty>::type type;
 };

template<class _Ty>
 struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>>
 {
 typedef typename _Ty::is_always_equal type;
 };


template<class _Ty,
 class _Other,
 class = void>
 struct _Get_rebind_type
 {
 typedef typename _Replace_first_parameter<_Other, _Ty>::type type;
 };

template<class _Ty,
 class _Other>
 struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>>
 {
 typedef typename _Ty::template rebind<_Other>::other type;
 };


template<class _Ty>
 class allocator;
template<class _Alloc>
 struct _Wrap_alloc;

template<class _Alloc>
 struct _Unwrap_alloc
 {
 typedef _Alloc type;
 };

template<class _Alloc>
 struct _Unwrap_alloc<_Wrap_alloc<_Alloc>>
 {
 typedef _Alloc type;
 };



template<class _Alloc>
 using _Unwrap_alloc_t = typename _Unwrap_alloc<_Alloc>::type;



template<class _Alloc,
 class = void>
 struct _Is_default_allocator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
  : true_type
 {
 };


struct _Alloc_allocate
 {


 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint)
   -> decltype(_Al.allocate(_Count, _Hint))
  {
  return (_Al.allocate(_Count, _Hint));
  }

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(_Wrap_int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer)
   -> decltype(_Al.allocate(_Count))
  {
  return (_Al.allocate(_Count));
  }
 };


struct _Has_no_alloc_construct_tag
 {
 };

template<class _Void,
 class... _Types>
 struct _Has_no_alloc_construct
  : true_type
 {
 };

template<class _Alloc,
 class _Ptr,
 class... _Args>
 struct _Has_no_alloc_construct<
  void_t<
   _Has_no_alloc_construct_tag,
   decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>,
  _Alloc, _Ptr, _Args...>
  : false_type
 {
 };

template<class _Alloc,
 class _Ptr,
 class... _Args>
 using _Uses_default_construct = disjunction<
  _Is_default_allocator<_Alloc>,
  _Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;

template<class _Alloc,
 class _Ptr,
 class... _Args>
 using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;



struct _Has_no_alloc_destroy_tag
 {
 };

template<class _Alloc,
 class _Ptr,
 class = void>
 struct _Has_no_alloc_destroy
  : true_type
 {
 };

template<class _Alloc,
 class _Ptr>
 struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<
   _Has_no_alloc_destroy_tag,
   decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
  : false_type
 {
 };

template<class _Alloc,
 class _Ptr>
 using _Uses_default_destroy = disjunction<
  _Is_default_allocator<_Alloc>,
  _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template<class _Alloc,
 class _Ptr>
 using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;



struct _Alloc_max_size
 {
 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al) noexcept
   -> decltype(_Al.max_size())
  {
  return (_Al.max_size());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty&) noexcept
   -> typename _Get_size_type<_Ty>::type
  {
  return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)()
   / sizeof(typename _Ty::value_type));
  }
 };


struct _Alloc_select
 {


 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype((_Ty)_Al.select_on_container_copy_construction())
  {
  return (_Al.select_on_container_copy_construction());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty& _Al)
   -> _Ty
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct allocator_traits
 {
 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef typename _Get_pointer_type<_Alloc>::type
  pointer;
 typedef typename _Get_const_pointer_type<_Alloc>::type
  const_pointer;
 typedef typename _Get_void_pointer_type<_Alloc>::type
  void_pointer;
 typedef typename _Get_const_void_pointer_type<_Alloc>::type
  const_void_pointer;

 typedef typename _Get_size_type<_Alloc>::type size_type;
 typedef typename _Get_difference_type<_Alloc>::type difference_type;

 typedef typename _Get_propagate_on_container_copy<_Alloc>::type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move<_Alloc>::type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap<_Alloc>::type
  propagate_on_container_swap;
 typedef typename _Get_is_always_equal<_Alloc>::type
  is_always_equal;

 template<class _Other>
  using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

 template<class _Other>
  using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  static void _Construct1(true_type, _Alloc&, _Ty *_Ptr,
   _Types&&... _Args)
  {
  ::new (static_cast<void *>(_Ptr))
   _Ty(::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class... _Types>
  static void _Construct1(false_type, _Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class... _Types>
  static void construct(_Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
   _Al, _Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  static void _Destroy1(_Alloc&, _Ty *_Ptr, true_type)
  {
  _Ptr->~_Ty();
  }

 template<class _Ty>
  static void _Destroy1(_Alloc& _Al, _Ty *_Ptr, false_type)
  {
  _Al.destroy(_Ptr);
  }

 template<class _Ty>
  static void destroy(_Alloc& _Al, _Ty *_Ptr)
  {
  _Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Alloc_max_size::_Fn(0, _Al));
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Alloc_select::_Fn(0, _Al));
  }
 };


template<class _Ty>
 class allocator
 {
public:
 static_assert(!is_const<_Ty>::value,
  "The C++ Standard forbids containers of const elements "
  "because allocator<const T> is ill-formed.");

 typedef void _Not_user_specialized;

 typedef _Ty value_type;

 typedef value_type *pointer;
 typedef const value_type *const_pointer;

 typedef value_type& reference;
 typedef const value_type& const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef true_type propagate_on_container_move_assignment;
 typedef true_type is_always_equal;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 pointer address(reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 allocator() noexcept
  {
  }

 allocator(const allocator<_Ty>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<_Ty>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Deallocate(_Ptr, _Count, sizeof (_Ty));
  }

 __declspec(allocator) pointer allocate( size_type _Count)
  {
  return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
  }

 __declspec(allocator) pointer allocate( size_type _Count, const void *)
  {
  return (allocate(_Count));
  }

 template<class _Objty,
  class... _Types>
  void construct(_Objty *_Ptr, _Types&&... _Args)
  {
  ::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
  void destroy(_Uty *_Ptr)
  {
  _Ptr->~_Uty();
  }

 size_t max_size() const noexcept
  {
  return ((size_t)(-1) / sizeof (_Ty));
  }
 };


template<>
 class allocator<void>
 {
public:
 typedef void _Not_user_specialized;

 typedef void value_type;

 typedef void *pointer;
 typedef const void *const_pointer;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 allocator() noexcept
  {
  }

 allocator(const allocator<void>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<void>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const allocator<_Ty>&,
  const allocator<_Other>&) noexcept
 {
 return (true);
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const allocator<_Ty>&,
  const allocator<_Other>&) noexcept
 {
 return (false);
 }


template<class _Ty>
 struct allocator_traits<allocator<_Ty> >
 {
 typedef allocator<_Ty> _Alloc;

 typedef _Alloc allocator_type;
 typedef _Ty value_type;

 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef true_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;
 typedef true_type is_always_equal;

 template<class _Other>
  using rebind_alloc = allocator<_Other>;

 template<class _Other>
  using rebind_traits = allocator_traits<allocator<_Other> >;

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Al.allocate(_Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Objty,
  class... _Types>
  static void construct(_Alloc& _Al, _Objty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
  static void destroy(_Alloc& _Al, _Uty *_Ptr)
  {
  _Al.destroy(_Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Al.max_size());
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct _Wrap_alloc
  : public _Alloc
 {
 typedef _Alloc _Mybase;
 typedef allocator_traits<_Alloc> _Mytraits;

 typedef typename _Mytraits::value_type value_type;

 typedef typename _Mytraits::pointer pointer;
 typedef typename _Mytraits::const_pointer const_pointer;
 typedef typename _Mytraits::void_pointer void_pointer;
 typedef typename _Mytraits::const_void_pointer const_void_pointer;

 typedef typename _If<is_void<value_type>::value,
  int, value_type>::type& reference;
 typedef typename _If<is_void<const value_type>::value,
  const int, const value_type>::type& const_reference;

 typedef typename _Mytraits::size_type size_type;
 typedef typename _Mytraits::difference_type difference_type;

 typedef typename _Mytraits::propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits::propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits::propagate_on_container_swap
  propagate_on_container_swap;
 typedef typename _Mytraits::is_always_equal
  is_always_equal;

 _Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
  {
  return (_Mytraits::select_on_container_copy_construction(*this));
  }

 template<class _Other>
  struct rebind
  {
  typedef typename _Mytraits::template rebind_alloc<_Other>
   _Other_alloc;
  typedef _Wrap_alloc<_Other_alloc> other;
  };

 pointer address(reference _Val) const
  {
  return (pointer_traits<pointer>::pointer_to(_Val));
  }

 const_pointer address(const_reference _Val) const
  {
  return (pointer_traits<const_pointer>::pointer_to(_Val));
  }

 _Wrap_alloc() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase()
  {
  }

 _Wrap_alloc(const _Wrap_alloc& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc(_Wrap_alloc&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }

 template<class _Other>
  _Wrap_alloc(_Other&& _Right) noexcept
  : _Mybase(::std:: forward<_Other>(_Right))
  {
  }

 _Wrap_alloc& operator=(const _Wrap_alloc& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 _Wrap_alloc& operator=(_Wrap_alloc&& _Right)
  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 template<class _Other>
  _Wrap_alloc& operator=(_Other&& _Right)
  {
  _Mybase::operator=(::std:: forward<_Other>(_Right));
  return (*this);
  }

 __declspec(allocator) pointer allocate( size_type _Count)
  {
  return (_Mybase::allocate(_Count));
  }

 __declspec(allocator) pointer allocate( size_type _Count,
  const_void_pointer _Hint, _Nil = _Nil())
  {
  return (_Mytraits::allocate(*this, _Count, _Hint));
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Mybase::deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  void construct(_Ty *_Ptr,
   _Types&&... _Args)
  {
  _Mytraits::construct(*this, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  void destroy(_Ty *_Ptr)
  {
  _Mytraits::destroy(*this, _Ptr);
  }

 size_type max_size(_Nil = _Nil()) const noexcept
  {
  return (_Mytraits::max_size(*this));
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (static_cast<const _Ty&>(_Left)
  == static_cast<const _Other&>(_Right));
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
 {
 _Left = _Right;
 }

template<class _Alty> inline
 void _Pocca(_Alty&, const _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_copy_assignment _Tag;
 _Pocca(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Left = ::std:: move(_Right);
 }

template<class _Alty> inline
 void _Pocma(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_move_assignment _Tag;
 _Pocma(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Swap_adl(_Left, _Right);
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, false_type) noexcept
 {
 if (_Left != _Right)
  {



  ::std:: terminate();

  }
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_swap _Tag;
 _Pocs(_Left, _Right, _Tag);
 }



template<class _Alloc,
 class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
 void _Destroy_range1(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al, false_type)
 {
 for (; _First != _Last; ++_First)
  _Al.destroy(_Unfancy(_First));
 }

template<class _Alloc,
 class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
 void _Destroy_range1(_Ptr, _Ptr, _Wrap_alloc<_Alloc>&, true_type)
 {

 }

template<class _Alloc,
 class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
 void _Destroy_range(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al)
 {


 typedef typename _Alloc::value_type _Val;
 _Destroy_range1(_First, _Last, _Al, _Conjunction_t<
  is_trivially_destructible<_Val>,
  _Uses_default_destroy<_Alloc, _Val *>>());
 }



template<class _FwdIt> inline
 void _Destroy_range1(_FwdIt _First, _FwdIt _Last, false_type)
 {
 for (; _First != _Last; ++_First)
  _Destroy_in_place(*_First);
 }

template<class _FwdIt> inline
 void _Destroy_range1(_FwdIt, _FwdIt, true_type)
 {

 }

template<class _FwdIt> inline
 void _Destroy_range(_FwdIt _First, _FwdIt _Last)
 {


 _Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt>>());
 }

}



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xatomic0.h" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

typedef enum memory_order {
 memory_order_relaxed,
 memory_order_consume,
 memory_order_acquire,
 memory_order_release,
 memory_order_acq_rel,
 memory_order_seq_cst
 } memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;
# 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xatomic0.h" 3
typedef _Atomic_integral_t _Atomic_counter_t;

inline _Atomic_integral_t
 _Get_atomic_count(const _Atomic_counter_t& _Counter)
 {
 return (_Counter);
 }
# 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xatomic0.h" 3
}

#pragma warning(pop)
#pragma pack(pop)
# 1249 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 2 3



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\intrin0.h" 1 3
# 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\intrin0.h" 3
extern "C" {
# 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\intrin0.h" 3
long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






long _InterlockedDecrement(long volatile * _Addend);

long _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);
# 179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\intrin0.h" 3
long _InterlockedIncrement(long volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
# 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\intrin0.h" 3
unsigned char _interlockedbittestandset(long volatile *, long);
# 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\intrin0.h" 3
}
# 1252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 2 3
# 1269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory0" 3
#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
template<class _Traits>
 using _Traits_ch_t = typename _Traits::char_type;

template<class _Traits>
 using _Traits_ptr_t = const typename _Traits::char_type *;

template<class _Traits>
 constexpr bool _Traits_equal( const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
                          const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
 {
 return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);
 }

template<class _Traits>
 constexpr int _Traits_compare( const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
                          const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
 {
 const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));

 if (_Ans != 0)
  {
  return (_Ans);
  }

 if (_Left_size < _Right_size)
  {
  return (-1);
  }

 if (_Left_size > _Right_size)
  {
  return (1);
  }

 return (0);
 }

template<class _Traits>
 constexpr size_t _Traits_find(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
                           const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
 {
 if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)
  {







  return (static_cast<size_t>(-1));
  }

 if (_Needle_size == 0)
  {
  return (_Start_at);
  }

 const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
 for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)
  {
  _Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);
  if (!_Match_try)
   {
   return (static_cast<size_t>(-1));
   }

  if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
   {
   return (_Match_try - _Haystack);
   }
  }
 }

template<class _Traits>
 constexpr size_t _Traits_find_ch(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t<_Traits> _Ch) noexcept
 {
 if (_Start_at < _Hay_size)
  {
  const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
  if (_Found_at)
   {
   return (_Found_at - _Haystack);
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_rfind(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
                           const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
 {
 if (_Needle_size == 0)
  {
  return (_Min_value(_Start_at, _Hay_size));
  }

 if (_Needle_size <= _Hay_size)
  {
  for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size); ; --_Match_try)
   {
   if (_Traits::eq(*_Match_try, *_Needle)
    && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
    {
    return (_Match_try - _Haystack);
    }

   if (_Match_try == _Haystack)
    {
    break;
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_rfind_ch(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t<_Traits> _Ch) noexcept
 {
 if (_Hay_size != 0)
  {
  for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
   {
   if (_Traits::eq(*_Match_try, _Ch))
    {
    return (_Match_try - _Haystack);
    }

   if (_Match_try == _Haystack)
    {
    break;
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_find_first_of(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
                           const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
 {
 if (_Needle_size != 0 && _Start_at < _Hay_size)
  {
  const auto _End = _Haystack + _Hay_size;
  for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
   {
   if (_Traits::find(_Needle, _Needle_size, *_Match_try))
    {
    return (_Match_try - _Haystack);
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_find_last_of(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
                           const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
 {
 if (_Needle_size != 0 && _Hay_size != 0)
  {
  for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
   {
   if (_Traits::find(_Needle, _Needle_size, *_Match_try))
    {
    return (_Match_try - _Haystack);
    }

   if (_Match_try == _Haystack)
    {
    break;
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_find_first_not_of(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
                           const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
 {
 if (_Start_at < _Hay_size)
  {
  const auto _End = _Haystack + _Hay_size;
  for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
   {
   if (!_Traits::find(_Needle, _Needle_size, *_Match_try))
    {
    return (_Match_try - _Haystack);
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_find_not_ch(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t<_Traits> _Ch) noexcept
 {
 if (_Start_at < _Hay_size)
  {
  const auto _End = _Haystack + _Hay_size;
  for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
   {
   if (!_Traits::eq(*_Match_try, _Ch))
    {
    return (_Match_try - _Haystack);
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_find_last_not_of(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
                           const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
 {
 if (_Hay_size != 0)
  {
  for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
   {
   if (!_Traits::find(_Needle, _Needle_size, *_Match_try))
    {
    return (_Match_try - _Haystack);
    }

   if (_Match_try == _Haystack)
    {
    break;
    }
   }
  }

 return (static_cast<size_t>(-1));
 }

template<class _Traits>
 constexpr size_t _Traits_rfind_not_ch(
                        const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t<_Traits> _Ch) noexcept
 {
 if (_Hay_size != 0)
  {
  for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
   {
   if (!_Traits::eq(*_Match_try, _Ch))
    {
    return (_Match_try - _Haystack);
    }

   if (_Match_try == _Haystack)
    {
    break;
    }
   }
  }

 return (static_cast<size_t>(-1));
 }




template<class _Elem,
 class _Traits = char_traits<_Elem>>
 class basic_string_view;

template<class _Traits>
 class _String_view_iterator
 {
public:
 using iterator_category = random_access_iterator_tag;
 using value_type = typename _Traits::char_type;
 using difference_type = ptrdiff_t;
 using pointer = const value_type *;
 using reference = const value_type&;

 using _Unchecked_type = pointer;

 constexpr _String_view_iterator() noexcept





  : _Myptr()

 {
 }

private:
 friend basic_string_view<value_type, _Traits>;
# 334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
 constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept
  : _Myptr(_Ptr)
 {
 }


public:
 friend constexpr _String_view_iterator& _Rechecked(
  _String_view_iterator& _Iter, _Unchecked_type _Right) noexcept
  {



  _Iter._Myptr = _Right;

  return (_Iter);
  }

 friend constexpr _Unchecked_type _Unchecked(_String_view_iterator _Iter) noexcept
  {



  return (_Iter._Myptr);

  }

 constexpr reference operator*() const noexcept
  {





  return (*_Myptr);

  }

 constexpr pointer operator->() const noexcept
  {





  return (_Myptr);

  }

 constexpr _String_view_iterator& operator++() noexcept
  {





  ++_Myptr;

  return (*this);
  }

 constexpr _String_view_iterator operator++(int) noexcept
  {
  _String_view_iterator _Tmp{*this};
  ++*this;
  return (_Tmp);
  }

 constexpr _String_view_iterator& operator--() noexcept
  {





  --_Myptr;

  return (*this);
  }

 constexpr _String_view_iterator operator--(int) noexcept
  {
  _String_view_iterator _Tmp{*this};
  --*this;
  return (_Tmp);
  }

 constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept
  {
# 444 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
  _Myptr += _Off;


  return (*this);
  }

 constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept
  {
  _String_view_iterator _Tmp{*this};
  _Tmp += _Off;
  return (_Tmp);
  }

 constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept
  {
# 480 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
  _Myptr -= _Off;


  return (*this);
  }

 constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept
  {
  _String_view_iterator _Tmp{*this};
  _Tmp -= _Off;
  return (_Tmp);
  }

 constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept
  {





  return (_Myptr - _Right._Myptr);

  }

 constexpr reference operator[](const difference_type _Off) const noexcept
  {
  return (*(*this + _Off));
  }

 constexpr bool operator==(const _String_view_iterator& _Right) const noexcept
  {





  return (_Myptr == _Right._Myptr);

  }

 constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 constexpr bool operator<(const _String_view_iterator& _Right) const noexcept
  {





  return (_Myptr < _Right._Myptr);

  }

 constexpr bool operator>(const _String_view_iterator& _Right) const noexcept
  {
  return (_Right < *this);
  }

 constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept
  {
  return (!(_Right < *this));
  }

 constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept
  {
  return (!(*this < _Right));
  }

private:





 pointer _Myptr;

 };


template<class _Traits>
 constexpr _String_view_iterator<_Traits> operator+(
  const typename _String_view_iterator<_Traits>::difference_type _Off,
  _String_view_iterator<_Traits> _Right) noexcept
 {
 _Right += _Off;
 return (_Right);
 }


template<class _Elem,
 class _Traits>
 class basic_string_view
 {
public:
 static_assert(is_same<_Elem, typename _Traits::char_type>::value, "Bad char_traits for basic_string_view; "
 "N4606 21.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");

 using traits_type = _Traits;
 using value_type = _Elem;
 using pointer = _Elem *;
 using const_pointer = const _Elem *;
 using reference = _Elem&;
 using const_reference = const _Elem&;
 using const_iterator = _String_view_iterator<_Traits>;
 using iterator = const_iterator;
 using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
 using reverse_iterator = const_reverse_iterator;
 using size_type = size_t;
 using difference_type = ptrdiff_t;

 static constexpr size_type npos{static_cast<size_type>(-1)};

 constexpr basic_string_view() noexcept
  : _Mydata(),
  _Mysize(0)
  {
  }

 constexpr basic_string_view(const basic_string_view&) noexcept = default;
 constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;

                constexpr basic_string_view( const const_pointer _Ntcts) noexcept
  : _Mydata(_Ntcts),
  _Mysize(_Traits::length(_Ntcts))
  {
  }

 constexpr basic_string_view( const const_pointer _Cts, const size_type _Count)
   noexcept
  : _Mydata(_Cts),
  _Mysize(_Count)
  {
                                                                    ;
  }

 constexpr const_iterator begin() const noexcept
  {



  return (const_iterator(_Mydata));

  }

 constexpr const_iterator end() const noexcept
  {



  return (const_iterator(_Mydata + _Mysize));

  }

 constexpr const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 constexpr const_iterator cend() const noexcept
  {
  return (end());
  }

 constexpr const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator{end()});
  }

 constexpr const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator{begin()});
  }

 constexpr const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 constexpr const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 constexpr size_type size() const noexcept
  {
  return (_Mysize);
  }

 constexpr size_type length() const noexcept
  {
  return (_Mysize);
  }

 constexpr bool empty() const noexcept
  {
  return (_Mysize == 0);
  }

 constexpr const_pointer data() const noexcept
  {
  return (_Mydata);
  }

 constexpr size_type max_size() const noexcept
  {


  return (_Min_value(static_cast<size_t>(9223372036854775807i64), static_cast<size_t>(-1) / sizeof(_Elem)));
  }

 constexpr const_reference operator[](const size_type _Off) const noexcept
  {
                                                                   ;
  return (_Mydata[_Off]);
  }

 constexpr const_reference at(const size_type _Off) const
  {
  _Check_offset_exclusive(_Off);
  return (_Mydata[_Off]);
  }

 constexpr const_reference front() const noexcept
  {
                                                                     ;
  return (_Mydata[0]);
  }

 constexpr const_reference back() const noexcept
  {
                                                                    ;
  return (_Mydata[_Mysize - 1]);
  }

 constexpr void remove_prefix(const size_type _Count) noexcept
  {
                                                                               ;
  _Mydata += _Count;
  _Mysize -= _Count;
  }

 constexpr void remove_suffix(const size_type _Count) noexcept
  {
                                                                               ;
  _Mysize -= _Count;
  }

 constexpr void swap(basic_string_view& _Other) noexcept
  {
  const basic_string_view _Tmp{_Other};
  _Other = *this;
  *this = _Tmp;
  }


 constexpr size_type copy( _Elem * const _Ptr, size_type _Count,
  const size_type _Off = 0) const
  {
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  _Traits::copy(_Ptr, _Mydata + _Off, _Count);
  return (_Count);
  }

                                       constexpr size_type _Copy_s(
                               _Elem * const _Dest, const size_type _Dest_size,
  size_type _Count, const size_type _Off = 0) const
  {
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
  return (_Count);
  }

 constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const
  {
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  return (basic_string_view(_Mydata + _Off, _Count));
  }

 constexpr bool _Equal(const basic_string_view _Right) const noexcept
  {
  return (_Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize));
  }

 constexpr int compare(const basic_string_view _Right) const noexcept
  {
  return (_Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize));
  }

 constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right) const
  {
  return (substr(_Off, _N0).compare(_Right));
  }

 constexpr int compare(const size_type _Off, const size_type _N0,
  const basic_string_view _Right, const size_type _Roff, const size_type _Count) const
  {
  return (substr(_Off, _N0).compare(_Right.substr(_Roff, _Count)));
  }

 constexpr int compare( const _Elem * const _Ptr) const
  {
  return (compare(basic_string_view(_Ptr)));
  }

 constexpr int compare(const size_type _Off, const size_type _N0,
         const _Elem * const _Ptr) const
  {
  return (substr(_Off, _N0).compare(basic_string_view(_Ptr)));
  }

 constexpr int compare(const size_type _Off, const size_type _N0,
                     const _Elem * const _Ptr, const size_type _Count) const
  {
  return (substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count)));
  }

 constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept
  {
  return (_Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
  }

 constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept
  {
  return (_Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
  }

 constexpr size_type find( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (_Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
  }

 constexpr size_type find( const _Elem * const _Ptr, const size_type _Off = 0) const
  noexcept
  {
  return (_Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
  }

 constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept
  {
  return (_Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
  }

 constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept
  {
  return (_Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
  }

 constexpr size_type rfind( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (_Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
  }

 constexpr size_type rfind( const _Elem * const _Ptr, const size_type _Off = npos) const
  noexcept
  {
  return (_Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
  }

 constexpr size_type find_first_of(const basic_string_view _Right, const size_type _Off = 0) const noexcept
  {
  return (_Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
  }

 constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
  {
  return (_Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
  }

 constexpr size_type find_first_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (_Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
  }

 constexpr size_type find_first_of( const _Elem * const _Ptr,
  const size_type _Off = 0) const noexcept
  {
  return (_Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
  }

 constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos)
   const noexcept
  {
  return (_Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
  }

 constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
  {
  return (_Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
  }

 constexpr size_type find_last_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (_Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
  }

 constexpr size_type find_last_of( const _Elem * const _Ptr, const size_type _Off = npos) const
  noexcept
  {
  return (_Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
  }

 constexpr size_type find_first_not_of(const basic_string_view _Right, const size_type _Off = 0) const noexcept
  {
  return (_Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
  }

 constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
  {
  return (_Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
  }

 constexpr size_type find_first_not_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (_Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
  }

 constexpr size_type find_first_not_of( const _Elem * const _Ptr, const size_type _Off = 0) const
  noexcept
  {
  return (_Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
  }

 constexpr size_type find_last_not_of(const basic_string_view _Right, const size_type _Off = npos) const noexcept
  {
  return (_Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize));
  }

 constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
  {
  return (_Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch));
  }

 constexpr size_type find_last_not_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (_Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count));
  }

 constexpr size_type find_last_not_of( const _Elem * const _Ptr, const size_type _Off = npos) const
  noexcept
  {
  return (_Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
  }

private:
 constexpr void _Check_offset(const size_type _Off) const
  {
  if (_Mysize < _Off)
   {
   _Xran();
   }
  }

 constexpr void _Check_offset_exclusive(const size_type _Off) const
  {
  if (_Mysize <= _Off)
   {
   _Xran();
   }
  }

 constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
  {
  return (_Min_value(_Size, _Mysize - _Off));
  }

 [[noreturn]] static void _Xran()
  {
  _Xout_of_range("invalid string_view position");
  }

 const_pointer _Mydata;
 size_type _Mysize;
 };



template<class _Elem,
 class _Traits>
 constexpr bool operator==(const basic_string_view<_Elem, _Traits> _Lhs,
  const basic_string_view<_Elem, _Traits> _Rhs) noexcept
 {
 return (_Lhs._Equal(_Rhs));
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator==(_Conv&& _Lhs, const basic_string_view<_Elem, _Traits> _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)))))
 {
 return (_Rhs._Equal(::std:: forward<_Conv>(_Lhs)));
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator==(const basic_string_view<_Elem, _Traits> _Lhs, _Conv&& _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Rhs)))))
 {
 return (_Lhs._Equal(::std:: forward<_Conv>(_Rhs)));
 }



template<class _Elem,
 class _Traits>
 constexpr bool operator!=(const basic_string_view<_Elem, _Traits> _Lhs,
  const basic_string_view<_Elem, _Traits> _Rhs) noexcept
 {
 return (!_Lhs._Equal(_Rhs));
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator!=(_Conv&& _Lhs, const basic_string_view<_Elem, _Traits> _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)))))
 {
 return (!_Rhs._Equal(::std:: forward<_Conv>(_Lhs)));
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator!=(const basic_string_view<_Elem, _Traits> _Lhs, _Conv&& _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Rhs)))))
 {
 return (!_Lhs._Equal(::std:: forward<_Conv>(_Rhs)));
 }



template<class _Elem,
 class _Traits>
 constexpr bool operator<(const basic_string_view<_Elem, _Traits> _Lhs,
 const basic_string_view<_Elem, _Traits> _Rhs) noexcept
 {
 return (_Lhs.compare(_Rhs) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator<(_Conv&& _Lhs, const basic_string_view<_Elem, _Traits> _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)))))
 {
 return (basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)).compare(_Rhs) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator<(const basic_string_view<_Elem, _Traits> _Lhs, _Conv&& _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Rhs)))))
 {
 return (_Lhs.compare(::std:: forward<_Conv>(_Rhs)) < 0);
 }



template<class _Elem,
 class _Traits>
 constexpr bool operator>(const basic_string_view<_Elem, _Traits> _Lhs,
 const basic_string_view<_Elem, _Traits> _Rhs) noexcept
 {
 return (_Lhs.compare(_Rhs) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator>(_Conv&& _Lhs, const basic_string_view<_Elem, _Traits> _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)))))
 {
 return (basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)).compare(_Rhs) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator>(const basic_string_view<_Elem, _Traits> _Lhs, _Conv&& _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Rhs)))))
 {
 return (_Lhs.compare(::std:: forward<_Conv>(_Rhs)) > 0);
 }



template<class _Elem,
 class _Traits>
 constexpr bool operator<=(const basic_string_view<_Elem, _Traits> _Lhs,
  const basic_string_view<_Elem, _Traits> _Rhs) noexcept
 {
 return (_Lhs.compare(_Rhs) <= 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator<=(_Conv&& _Lhs, const basic_string_view<_Elem, _Traits> _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)))))
 {
 return (basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)).compare(_Rhs) <= 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator<=(const basic_string_view<_Elem, _Traits> _Lhs, _Conv&& _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Rhs)))))
 {
 return (_Lhs.compare(::std:: forward<_Conv>(_Rhs)) <= 0);
 }



template<class _Elem,
 class _Traits>
 constexpr bool operator>=(const basic_string_view<_Elem, _Traits> _Lhs,
  const basic_string_view<_Elem, _Traits> _Rhs) noexcept
 {
 return (_Lhs.compare(_Rhs) >= 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator>=(_Conv&& _Lhs, const basic_string_view<_Elem, _Traits> _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)))))
 {
 return (basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Lhs)).compare(_Rhs) >= 0);
 }

template<class _Elem,
 class _Traits,
 class _Conv,
 class = enable_if_t<is_convertible<_Conv, basic_string_view<_Elem, _Traits>>::value>>
 constexpr bool operator>=(const basic_string_view<_Elem, _Traits> _Lhs, _Conv&& _Rhs)
  noexcept(noexcept((basic_string_view<_Elem, _Traits>(::std:: forward<_Conv>(_Rhs)))))
 {
 return (_Lhs.compare(::std:: forward<_Conv>(_Rhs)) >= 0);
 }



using string_view = basic_string_view<char>;
using u16string_view = basic_string_view<char16_t>;
using u32string_view = basic_string_view<char32_t>;
using wstring_view = basic_string_view<wchar_t>;



template<class _Elem,
 class _Traits>
 struct hash<basic_string_view<_Elem, _Traits> >
 {
 typedef basic_string_view<_Elem, _Traits> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Hash_seq(reinterpret_cast<const unsigned char *>(_Keyval.data()),
   _Keyval.size() * sizeof (_Elem)));
  }
 };



template<class _Mystr>
 class _String_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Mystr::value_type,
   typename _Mystr::difference_type,
   typename _Mystr::const_pointer,
   typename _Mystr::const_reference,
   _Iterator_base>
 {
public:
 typedef _String_const_iterator<_Mystr> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::const_pointer pointer;
 typedef typename _Mystr::const_reference reference;

 _String_const_iterator()
  : _Ptr()
  {
  }

 _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Ptr(_Parg)
  {
  this->_Adopt(_Pstring);
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

 reference operator*() const
  {
# 1226 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
                         ;
  return (*_Ptr);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 1246 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
  ++_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 1267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
  --_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(const difference_type _Off)
  {
# 1295 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(const difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(const difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(const difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr - _Right._Ptr);
  }

 reference operator[](const difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 1367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
 void _Compat(const _Myiter&) const
  {
  }


 pointer _Ptr;
 };

template<class _Mystr> inline
 typename _String_const_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_const_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr>
  _Rechecked(_String_const_iterator<_Mystr>& _Iter,
   typename _String_const_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr> operator+(
  typename _String_const_iterator<_Mystr>
   ::difference_type _Off,
  _String_const_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Mystr>
 class _String_iterator
  : public _String_const_iterator<_Mystr>
 {
public:
 typedef _String_iterator<_Mystr> _Myiter;
 typedef _String_const_iterator<_Mystr> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::pointer pointer;
 typedef typename _Mystr::reference reference;

 _String_iterator()
  {
  }

 _String_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Mybase(_Parg, _Pstring)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Const_cast(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(const difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(const difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(const difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(const difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](const difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Mystr> inline
 typename _String_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_iterator<_Mystr>
  _Rechecked(_String_iterator<_Mystr>& _Iter,
   typename _String_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_iterator<_Mystr> operator+(
  typename _String_iterator<_Mystr>
   ::difference_type _Off,
  _String_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _String_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _String_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _String_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _String_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _String_val
  : public _Container_base
 {
public:
 typedef _String_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _String_iterator<_Myt> iterator;
 typedef _String_const_iterator<_Myt> const_iterator;

 _String_val()
  : _Bx(),
  _Mysize(0),
  _Myres(0)
  {
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
   : 16 / sizeof (value_type)};
 enum
  {
  _ALLOC_MASK = sizeof (value_type) <= 1 ? 15
   : sizeof (value_type) <= 2 ? 7
   : sizeof (value_type) <= 4 ? 3
   : sizeof (value_type) <= 8 ? 1 : 0
  };

 value_type *_Myptr()
  {
  return (_Large_string_engaged()
   ? _Unfancy(_Bx._Ptr)
   : _Bx._Buf);
  }

 const value_type *_Myptr() const
  {
  return (_Large_string_engaged()
   ? _Unfancy(_Bx._Ptr)
   : _Bx._Buf);
  }

 bool _Large_string_engaged() const
  {
  return (this->_BUF_SIZE <= _Myres);
  }

 union _Bxty
  {
  _Bxty()
   {
   }

  ~_Bxty() noexcept
   {
   }

  value_type _Buf[_BUF_SIZE];
  pointer _Ptr;
  char _Alias[_BUF_SIZE];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };


template<class _Alloc_types>
 class _String_alloc
 {
public:
 typedef _String_alloc<_Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alty _Alty;
 typedef typename _Alloc_types::_Val_types _Val_types;
 typedef _String_val<_Val_types> _Mydata_t;
 typedef typename _Mydata_t::_Bxty _Bxty;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _String_iterator<_Mydata_t> iterator;
 typedef _String_const_iterator<_Mydata_t> const_iterator;

 enum
  {
  _BUF_SIZE = _Mydata_t::_BUF_SIZE
  };

 enum
  {
  _ALLOC_MASK = _Mydata_t::_ALLOC_MASK
  };

 value_type *_Myptr()
  {
  return (_Get_data()._Myptr());
  }

 const value_type *_Myptr() const
  {
  return (_Get_data()._Myptr());
  }


 _String_alloc()
  : _Mypair(_Zero_then_variadic_args_t())
  {
  }

 template<class _Any_alloc,
  class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
  _String_alloc(_Any_alloc&& _Al)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Any_alloc>(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Getal(), _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Getal(), _Al);
  }
# 1807 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
 void _Orphan_all()
  {
  _Get_data()._Orphan_all();
  }

 void _Swap_all(_Myt& _Right)
  {
  _Get_data()._Swap_all(_Right._Get_data());
  }

 _Alty& _Getal() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Mypair._Get_first());
  }

 _Mydata_t& _Get_data() noexcept
  {
  return (_Mypair._Get_second());
  }

 const _Mydata_t& _Get_data() const noexcept
  {
  return (_Mypair._Get_second());
  }

 size_type& _Mysize() noexcept
  {
  return (_Get_data()._Mysize);
  }

 const size_type& _Mysize() const noexcept
  {
  return (_Get_data()._Mysize);
  }

 size_type& _Myres() noexcept
  {
  return (_Get_data()._Myres);
  }

 const size_type& _Myres() const noexcept
  {
  return (_Get_data()._Myres);
  }

private:
 _Compressed_pair<_Alty, _Mydata_t> _Mypair;
 };



template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem>>
 class basic_string
  : public _String_alloc<_String_base_types<_Elem, _Alloc> >
 {
public:
 typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
 typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Mydata_t _Mydata_t;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;

 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;
# 1902 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
 using _Use_memcpy_move = bool_constant<
  _Is_specialization<_Traits, char_traits>::value && is_trivial<pointer>::value>;

 static constexpr size_t _Memcpy_move_offset = ((size_t)&reinterpret_cast<char const volatile&>((((_Mydata_t*)0)->_Bx)));
 static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;

 template<class _Iter>
  using _Is_elem_cptr = _Disjunction_t<
   is_same<_Iter, const _Elem * const>,
   is_same<_Iter, _Elem * const>,
   is_same<_Iter, const _Elem *>,
   is_same<_Iter, _Elem *>>;


 template<class _StringViewIsh>
  using _Is_string_view_ish = enable_if_t<conjunction<
   is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
   negation<is_convertible<const _StringViewIsh&, const _Elem *>>>::value>;



 basic_string(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  _Tidy_init();
  _Assign_lv_contents(_Right);
  }

 basic_string(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy_init();
  _Assign_lv_contents(_Right);
  }

 basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase()
  {
  _Tidy_init();
  }

 explicit basic_string(const _Alloc& _Al) noexcept
  : _Mybase(_Al)
  {
  _Tidy_init();
  }

 basic_string(const _Myt& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  _Tidy_init();
  assign(_Right, _Roff, npos);
  }

 basic_string(const _Myt& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  _Tidy_init();
  assign(_Right, _Roff, _Count);
  }

 basic_string( const _Elem * const _Ptr, const size_type _Count)
  : _Mybase()
  {
  _Tidy_init();
  assign(_Ptr, _Count);
  }

 basic_string( const _Elem * const _Ptr, const size_type _Count,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy_init();
  assign(_Ptr, _Count);
  }

 basic_string( const _Elem * const _Ptr)
  : _Mybase()
  {
  _Tidy_init();
  assign(_Ptr);
  }

 basic_string( const _Elem * const _Ptr, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy_init();
  assign(_Ptr);
  }

 basic_string( const size_type _Count, const _Elem _Ch)
  : _Mybase()
  {
  _Tidy_init();
  assign(_Count, _Ch);
  }

 basic_string( const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy_init();
  assign(_Count, _Ch);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value>>
  basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
                             ;
  _Tidy_init();
  _Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
  }

 template<class _Iter>
  void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag)
  {
  try {
  for (; _First != _Last; ++_First)
   push_back(static_cast<_Elem>(*_First));
  } catch (...) {
  _Tidy_deallocate();
  throw;
  }
  }

 template<class _Iter>
  void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag)
  {
  const size_type _Count = ::std:: distance(_First, _Last);
  reserve(_Count);
  _Construct(_First, _Last, input_iterator_tag());
  }

 void _Construct(_Elem * const _First, _Elem * const _Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   {
   assign(_First, _Last - _First);
   }
  }

 void _Construct(const _Elem * const _First, const _Elem * const _Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   {
   assign(_First, _Last - _First);
   }
  }

 basic_string(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Assign_rv_contents_with_alloc_always_equal(::std:: move(_Right), _Use_memcpy_move{});
  }

 basic_string(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv_contents(::std:: move(_Right), typename _Alty::is_always_equal{});
  }


 explicit basic_string(const basic_string_view<_Elem, _Traits> _Right,
  const _Alloc& _Al = _Alloc())
  : basic_string(_Right.data(), _Right.size(), _Al)
  {
  }


 _Myt& operator=(_Myt&& _Right)
  noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)

  {
  if (this != ::std:: addressof(_Right))
   {
   _Tidy_deallocate();
   this->_Move_alloc(_Right._Getal());


   _Assign_rv_contents(::std:: move(_Right),
    bool_constant<_Alty::propagate_on_container_move_assignment::value
    || _Alty::is_always_equal::value>{});
   }

  return (*this);
  }

 _Myt& assign(_Myt&& _Right) noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)

  {
  *this = ::std:: move(_Right);
  return (*this);
  }

 void _Assign_rv_contents(_Myt&& _Right, true_type)
  {



  _Assign_rv_contents_with_alloc_always_equal(::std:: move(_Right), _Use_memcpy_move{});
  }

 void _Assign_rv_contents(_Myt&& _Right, false_type)
  {



  if (this->_Getal() == _Right._Getal())
   {
   _Assign_rv_contents_with_alloc_always_equal(::std:: move(_Right), _Use_memcpy_move{});
   }
  else
   {
   _Tidy_init();
   _Assign_lv_contents(_Right);
   }
  }

 void _Assign_rv_contents_with_alloc_always_equal(_Myt&& _Right, true_type)
  {



  auto& _Right_data = _Right._Get_data();
# 2139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
  const auto _My_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(this->_Get_data()))
   + _Memcpy_move_offset;
  const auto _Right_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(_Right_data))
   + _Memcpy_move_offset;
  :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
  _Right._Tidy_init();
  }

 void _Assign_rv_contents_with_alloc_always_equal(_Myt&& _Right, false_type)
  {



  auto& _My_data = this->_Get_data();
  auto& _Right_data = _Right._Get_data();
  if (_Right_data._Large_string_engaged())
   {
   this->_Getal().construct(::std:: addressof(_My_data._Bx._Ptr), _Right_data._Bx._Ptr);
   _Right_data._Bx._Ptr = pointer();
   this->_Swap_all(_Right);
   }
  else
   {
   _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
   _Right._Orphan_all();
   }

  _My_data._Mysize = _Right_data._Mysize;
  _My_data._Myres = _Right_data._Myres;
  _Right._Tidy_init();
  }

 void _Assign_lv_contents(const _Myt& _Right)
  {

  assign(_Right, 0, npos);
  }

 basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Tidy_init();
  assign(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& operator+=(initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& assign(initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& append(initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 _Myt& replace(const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist)
  {
  return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
  }

 ~basic_string() noexcept
  {
  _Tidy_deallocate();
  }

          static const size_type npos;

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != ::std:: addressof(_Right))
   {
#pragma warning(push)
#pragma warning(disable: 4127)
 if (_Alty::propagate_on_container_copy_assignment::value
    && this->_Getal() != _Right._Getal())
    {
    _Tidy_deallocate();
    }
#pragma warning(pop)

 this->_Copy_alloc(_Right._Getal());

   _Assign_lv_contents(_Right);
   }

  return (*this);
  }


 _Myt& operator=(const basic_string_view<_Elem, _Traits> _Right)
  {
  return (assign(_Right));
  }


 _Myt& operator=( const _Elem * const _Ptr)
  {
  return (assign(_Ptr));
  }

 _Myt& operator=(const _Elem _Ch)
  {
  return (assign(1, _Ch));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  return (append(_Right));
  }


 _Myt& operator+=(const basic_string_view<_Elem, _Traits> _Right)
  {
  return (append(_Right));
  }


 _Myt& operator+=( const _Elem * const _Ptr)
  {
  return (append(_Ptr));
  }

 _Myt& operator+=(_Elem _Ch)
  {
  push_back(_Ch);
  return (*this);
  }

 _Myt& append(const _Myt& _Right)
  {
  return (append(_Right, 0, npos));
  }

 _Myt& append(const _Myt& _Right, const size_type _Roff, size_type _Count = npos)
  {
  _Right._Check_offset(_Roff);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);
  if (npos - this->_Mysize() <= _Count)
   {
   _Xlen();
   }

  const size_type _Num = this->_Mysize() + _Count;
  if (_Count != 0 && _Grow(_Num))
   {
   _Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }


 _Myt& append(const basic_string_view<_Elem, _Traits> _Right)
  {
  return (append(_Right.data(), _Right.size()));
  }

 template<class _StringViewIsh,
  class = _Is_string_view_ish<_StringViewIsh>>
  _Myt& append(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
  {
  basic_string_view<_Elem, _Traits> _As_view = _Right;
  return (append(_As_view.substr(_Roff, _Count)));
  }


 _Myt& append( const _Elem * const _Ptr, const size_type _Count)
  {
  if (_Inside(_Ptr))
   {
   return (append(*this, _Ptr - this->_Myptr(), _Count));
   }

  if (npos - this->_Mysize() <= _Count)
   {
   _Xlen();
   }

  const size_type _Num = this->_Mysize() + _Count;
  if (_Count != 0 && _Grow(_Num))
   {
   _Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
   _Eos(_Num);
   }

  return (*this);
  }

 _Myt& append( const _Elem * const _Ptr)
  {
  return (append(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& append( const size_type _Count, const _Elem _Ch)
  {
  if (npos - this->_Mysize() <= _Count)
   {
   _Xlen();
   }

  const size_type _Num = this->_Mysize() + _Count;
  if (_Count != 0 && _Grow(_Num))
   {
   _Chassign(this->_Mysize(), _Count, _Ch);
   _Eos(_Num);
   }

  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value>>
  _Myt& append(const _Iter _First, const _Iter _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& assign(const _Myt& _Right)
  {
  *this = _Right;
  return (*this);
  }

 _Myt& assign(const _Myt& _Right, const size_type _Roff, size_type _Count = npos)
  {
  _Right._Check_offset(_Roff);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);

  if (this == ::std:: addressof(_Right))
   {
   erase(_Roff + _Count);
   erase(0, _Roff);
   }
  else if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);
   _Eos(_Count);
   }

  return (*this);
  }


 _Myt& assign(const basic_string_view<_Elem, _Traits> _Right)
  {
  return (assign(_Right.data(), _Right.size()));
  }

 template<class _StringViewIsh,
  class = _Is_string_view_ish<_StringViewIsh>>
  _Myt& assign(const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
  {
  basic_string_view<_Elem, _Traits> _As_view = _Right;
  return (assign(_As_view.substr(_Roff, _Count)));
  }


 _Myt& assign( const _Elem * const _Ptr, const size_type _Count)
  {
  if (_Inside(_Ptr))
   {
   return (assign(*this, _Ptr - this->_Myptr(), _Count));
   }

  if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Ptr, _Count);
   _Eos(_Count);
   }

  return (*this);
  }

 _Myt& assign( const _Elem * const _Ptr)
  {
  return (assign(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& assign( const size_type _Count, const _Elem _Ch)
  {
  if (_Count == npos)
   {
   _Xlen();
   }

  if (_Grow(_Count))
   {
   _Chassign(0, _Count, _Ch);
   _Eos(_Count);
   }

  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value>>
  _Myt& assign(const _Iter _First, const _Iter _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& insert(const size_type _Off, const _Myt& _Right)
  {
  return (insert(_Off, _Right, 0, npos));
  }

 _Myt& insert(const size_type _Off, const _Myt& _Right, const size_type _Roff, size_type _Count = npos)
  {
  _Check_offset(_Off);
  _Right._Check_offset(_Roff);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);
  if (npos - this->_Mysize() <= _Count)
   {
   _Xlen();
   }

  const size_type _Num = this->_Mysize() + _Count;
  if (_Count != 0 && _Grow(_Num))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize() - _Off);
   if (this == ::std:: addressof(_Right))
    {
    _Traits::move(this->_Myptr() + _Off, this->_Myptr() + _Min_value(_Off, _Roff), _Count);
    }
   else
    {
    _Traits::copy(this->_Myptr() + _Off, _Right._Myptr() + _Roff, _Count);
    }

   _Eos(_Num);
   }

  return (*this);
  }


 _Myt& insert(const size_type _Off, const basic_string_view<_Elem, _Traits> _Right)
  {
  return (insert(_Off, _Right.data(), _Right.size()));
  }

 template<class _StringViewIsh,
  class = _Is_string_view_ish<_StringViewIsh>>
  _Myt& insert(const size_type _Off,
   const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
  {
  basic_string_view<_Elem, _Traits> _As_view = _Right;
  return (insert(_Off, _As_view.substr(_Roff, _Count)));
  }


 _Myt& insert(const size_type _Off, const _Elem * const _Ptr,
                     const size_type _Count)
  {
  if (_Inside(_Ptr))
   {
   return (insert(_Off, *this,
    _Ptr - this->_Myptr(), _Count));
   }

  _Check_offset(_Off);
  if (npos - this->_Mysize() <= _Count)
   {
   _Xlen();
   }

  const size_type _Num = this->_Mysize() + _Count;
  if (_Count != 0 && _Grow(_Num))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize() - _Off);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }

  return (*this);
  }

 _Myt& insert(const size_type _Off, const _Elem * const _Ptr)
  {
  return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& insert(const size_type _Off, const size_type _Count, const _Elem _Ch)
  {
  _Check_offset(_Off);
  if (npos - this->_Mysize() <= _Count)
   {
   _Xlen();
   }

  const size_type _Num = this->_Mysize() + _Count;
  if (_Count != 0 && _Grow(_Num))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize() - _Off);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }

  return (*this);
  }

 iterator insert(const const_iterator _Where, const _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, 1, _Ch);
  return (begin() + _Off);
  }

 iterator insert(const const_iterator _Where, const size_type _Count, const _Elem _Ch)
  {
  const size_type _Off = _Where - begin();
  insert(_Off, _Count, _Ch);
  return (begin() + _Off);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value>>
  iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last)
  {
  const size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 _Myt& erase(const size_type _Off = 0)
  {
  _Check_offset(_Off);
  _Eos(_Off);
  return (*this);
  }

 _Myt& erase(const size_type _Off, const size_type _Count)
  {
  _Check_offset(_Off);
  if (this->_Mysize() - _Off <= _Count)
   {
   _Eos(_Off);
   }
  else if (_Count != 0)
   {
   value_type *_Ptr = this->_Myptr() + _Off;
   size_type _Newsize = this->_Mysize() - _Count;
   _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
   _Eos(_Newsize);
   }

  return (*this);
  }

 iterator erase(const const_iterator _Where)
  {
  const size_type _Count = _Where - begin();
  erase(_Count, 1);
  return (begin() + _Count);
  }

 iterator erase(const const_iterator _First, const const_iterator _Last)
  {
                             ;
  const size_type _Count = _First - begin();
  erase(_Count, _Last - _First);
  return (begin() + _Count);
  }

 void clear() noexcept
  {
  _Eos(0);
  }

 _Myt& replace(const size_type _Off, const size_type _N0, const _Myt& _Right)
  {
  return (replace(_Off, _N0, _Right, 0, npos));
  }

 _Myt& replace(const size_type _Off, size_type _N0,
  const _Myt& _Right, const size_type _Roff, size_type _Count = npos)
  {
  _Check_offset(_Off);
  _Right._Check_offset(_Roff);
  _N0 = _Clamp_suffix_size(_Off, _N0);
  _Count = _Right._Clamp_suffix_size(_Roff, _Count);
  if (npos - _Count <= this->_Mysize() - _N0)
   {
   _Xlen();
   }

  const size_type _Nm = this->_Mysize() - _N0 - _Off;
  const size_type _Newsize = this->_Mysize() + _Count - _N0;
  if (this->_Mysize() < _Newsize)
   {
   _Grow(_Newsize);
   }

  if (_Count == _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (this != ::std:: addressof(_Right))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (_Count < _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }
  else if (_Roff <= _Off)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   }
  else if (_Off + _N0 <= _Roff)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + (_Roff + _Count - _N0),
    _Count);
   }
  else
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _N0);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off + _N0,
    this->_Myptr() + _Roff + _Count,
    _Count - _N0);
   }

  _Eos(_Newsize);
  return (*this);
  }


 _Myt& replace(const size_type _Off, const size_type _N0, const basic_string_view<_Elem, _Traits> _Right)
  {
  return (replace(_Off, _N0, _Right.data(), _Right.size()));
  }

 template<class _StringViewIsh,
  class = _Is_string_view_ish<_StringViewIsh>>
  _Myt& replace(const size_type _Off, const size_type _N0,
   const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos)
  {
  basic_string_view<_Elem, _Traits> _As_view = _Right;
  return (replace(_Off, _N0, _As_view.substr(_Roff, _Count)));
  }


 _Myt& replace(const size_type _Off, size_type _N0,
                     const _Elem * const _Ptr, const size_type _Count)
  {
  if (_Inside(_Ptr))
   {
   return (replace(_Off, _N0, *this,
    _Ptr - this->_Myptr(),
    _Count));
   }

  _Check_offset(_Off);
  _N0 = _Clamp_suffix_size(_Off, _N0);
  if (npos - _Count <= this->_Mysize() - _N0)
   {
   _Xlen();
   }

  size_type _Nm = this->_Mysize() - _N0 - _Off;
  if (_Count < _N0)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }

  const size_type _Num = this->_Mysize() + _Count - _N0;
  if ((_Count != 0 || _N0 != 0)
   && _Grow(_Num))
   {
   if (_N0 < _Count)
    {
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
    }
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }

  return (*this);
  }

 _Myt& replace(const size_type _Off, const size_type _N0, const _Elem * const _Ptr)
  {
  return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch)
  {
  _Check_offset(_Off);
  _N0 = _Clamp_suffix_size(_Off, _N0);
  if (npos - _Count <= this->_Mysize() - _N0)
   {
   _Xlen();
   }

  const size_type _Nm = this->_Mysize() - _N0 - _Off;
  if (_Count < _N0)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }

  const size_type _Num = this->_Mysize() + _Count - _N0;
  if ((_Count != 0 || _N0 != 0) && _Grow(_Num))
   {
   if (_N0 < _Count)
    {
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
    }
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(const const_iterator _First, const const_iterator _Last, const _Myt& _Right)
  {
  return (replace(_First - begin(), _Last - _First, _Right));
  }


 _Myt& replace(const const_iterator _First, const const_iterator _Last,
  const basic_string_view<_Elem, _Traits> _Right)
  {
  return (replace(_First - begin(), _Last - _First, _Right));
  }


 _Myt& replace(const const_iterator _First, const const_iterator _Last,
                     const _Elem * const _Ptr, const size_type _Count)
  {
  return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
  }

 _Myt& replace(const const_iterator _First, const const_iterator _Last, const _Elem * const _Ptr)
  {
  return (replace(_First - begin(), _Last - _First, _Ptr));
  }

 _Myt& replace(const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch)
  {
  return (replace(_First - begin(), _Last - _First, _Count, _Ch));
  }

 template<class _Iter>
  _Myt& _Replace_range(const const_iterator _First, const const_iterator _Last,
  const _Iter _First2, const _Iter _Last2, false_type)
  {
  const _Myt _Right(_First2, _Last2, get_allocator());
  replace(_First, _Last, _Right);
  return (*this);
  }

 template<class _Ptr>
  _Myt& _Replace_range(const const_iterator _First, const const_iterator _Last,
  const _Ptr _First2, const _Ptr _Last2, true_type)
  {
  if (_First2 == _Last2)
   {
   erase(_First - cbegin(), _Last - _First);
   }
  else
   {
   replace(_First - cbegin(), _Last - _First, _First2, _Last2 - _First2);
   }

  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value>>
  _Myt& replace(const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2)
  {
                               ;
  const auto _UFirst2 = _Unchecked(_First2);
  const auto _ULast2 = _Unchecked(_Last2);
  return (_Replace_range(_First, _Last, _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>()));
  }

 iterator begin() noexcept
  {
  auto _My_data = ::std:: addressof(this->_Get_data());
  return (iterator(this->_Getal().address(*_My_data->_Myptr()), _My_data));
  }

 const_iterator begin() const noexcept
  {
  auto _My_data = ::std:: addressof(this->_Get_data());
  return (const_iterator(this->_Getal().address(*_My_data->_Myptr()), _My_data));
  }

 iterator end() noexcept
  {
  auto _My_data = ::std:: addressof(this->_Get_data());
  return (iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));
  }

 const_iterator end() const noexcept
  {
  auto _My_data = ::std:: addressof(this->_Get_data());
  return (const_iterator(this->_Getal().address(*_My_data->_Myptr()) + _My_data->_Mysize, _My_data));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if ((size() | this->_ALLOC_MASK) < capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 reference at(const size_type _Off)
  {
  _Check_offset_exclusive(_Off);
  return (this->_Myptr()[_Off]);
  }

 const_reference at(const size_type _Off) const
  {
  _Check_offset_exclusive(_Off);
  return (this->_Myptr()[_Off]);
  }

 reference operator[](const size_type _Off)
  {
                                                                       ;
  return (this->_Myptr()[_Off]);
  }

 const_reference operator[](const size_type _Off) const
  {
                                                                       ;
  return (this->_Myptr()[_Off]);
  }


                operator basic_string_view<_Elem, _Traits>() const noexcept
  {
  return (basic_string_view<_Elem, _Traits>(this->_Myptr(), this->_Mysize()));
  }


 void push_back(const _Elem _Ch)
  {
  auto& _My_data = this->_Get_data();
  auto& _Sz = _My_data._Mysize;
  if (_Sz == _My_data._Myres)
   {
   _Grow(_Sz + 1);
   }

  auto _Ptr = _My_data._Myptr();
  _Traits::assign(_Ptr[_Sz], _Ch);
  ++_Sz;
  _Traits::assign(_Ptr[_Sz], _Elem());
  }

 void pop_back()
  {
  erase(this->_Mysize() - 1);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

         const _Elem * c_str() const noexcept
  {
  return (this->_Myptr());
  }

         const _Elem * data() const noexcept
  {
  return (this->_Myptr());
  }


         _Elem * data() noexcept
  {
  return (this->_Myptr());
  }


 size_type length() const noexcept
  {
  return (this->_Mysize());
  }

 size_type size() const noexcept
  {
  return (this->_Mysize());
  }

 size_type max_size() const noexcept
  {
  const size_type _Num = this->_Getal().max_size();
  return (_Num <= 1 ? 1 : _Num - 1);
  }

 void resize( const size_type _Newsize)
  {
  resize(_Newsize, _Elem());
  }

 void resize( const size_type _Newsize, const _Elem _Ch)
  {
  if (_Newsize <= this->_Mysize())
   {
   _Eos(_Newsize);
   }
  else
   {
   append(_Newsize - this->_Mysize(), _Ch);
   }
  }

 size_type capacity() const noexcept
  {
  return (this->_Myres());
  }

 void reserve( const size_type _Newcap = 0)
  {
  auto& _My_data = this->_Get_data();
  if (_My_data._Mysize > _Newcap)
   {
   return;
   }

  if (_My_data._Myres == _Newcap)
   {
   return;
   }

  if (_My_data._Myres < _Newcap)
   {
   _Copy(_Newcap);
   return;
   }

  if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())
   {
   this->_Orphan_all();
   pointer _Ptr = _My_data._Bx._Ptr;
   auto& _Al = this->_Getal();
   _Al.destroy(::std:: addressof(_My_data._Bx._Ptr));
   _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
   _Al.deallocate(_Ptr, _My_data._Myres + 1);
   _My_data._Myres = this->_BUF_SIZE - 1;
   return;
   }


  }

 bool empty() const noexcept
  {
  return (this->_Mysize() == 0);
  }


 size_type copy( _Elem * const _Ptr,
  size_type _Count, const size_type _Off = 0) const
  {
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  _Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

                                       size_type _Copy_s(
                               _Elem * const _Dest, const size_type _Dest_size,
  size_type _Count, const size_type _Off = 0) const
  {
  _Check_offset(_Off);
  _Count = _Clamp_suffix_size(_Off, _Count);
  _Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 void _Swap_data(_Myt& _Right, true_type)
  {
  const auto _My_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(this->_Get_data()))
   + _Memcpy_move_offset;
  const auto _Right_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(_Right._Get_data()))
   + _Memcpy_move_offset;
  unsigned char _Temp_mem[_Memcpy_move_size];
  :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_move_size);
  :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
  :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_move_size);
  }

 void _Swap_bx_large_with_small(_Mydata_t& _Starts_large, _Mydata_t& _Starts_small)
  {
  pointer _Ptr = _Starts_large._Bx._Ptr;
  auto& _Al = this->_Getal();
  _Al.destroy(::std:: addressof(_Starts_large._Bx._Ptr));
  _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, this->_BUF_SIZE);
  _Al.construct(::std:: addressof(_Starts_small._Bx._Ptr), _Ptr);
  }

 void _Swap_data(_Myt& _Right, false_type)
  {
  auto& _My_data = this->_Get_data();
  auto& _Right_data = _Right._Get_data();
  const bool _My_large = _My_data._Large_string_engaged();
  const bool _Right_large = _Right_data._Large_string_engaged();
  if (_My_large)
   {
   if (_Right_large)
    {
    _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
    }
   else
    {
    _Swap_bx_large_with_small(_My_data, _Right_data);
    }
   }
  else
   {
   if (_Right_large)
    {
    _Swap_bx_large_with_small(_Right_data, _My_data);
    }
   else
    {
    _Elem _Temp_buf[_Mybase::_BUF_SIZE];
    _Traits::copy(_Temp_buf, _My_data._Bx._Buf, this->_BUF_SIZE);
    _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, this->_BUF_SIZE);
    _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, this->_BUF_SIZE);
    }
   }

  ::std:: swap(this->_Mysize(), _Right._Mysize());
  ::std:: swap(this->_Myres(), _Right._Myres());
  }

 void swap(_Myt& _Right)
  noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)

  {
  if (this != ::std:: addressof(_Right))
   {
   _Pocs(this->_Getal(), _Right._Getal());
# 3200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xstring" 3
   }

  _Swap_data(_Right, _Use_memcpy_move{});
  }


 size_type find(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Right.data(), _Right.size())));
  }


 size_type find(const _Myt& _Right, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Right._Myptr(), _Right._Mysize())));
  }

 size_type find( const _Elem * const _Ptr, const size_type _Off, const size_type _Count) const
  noexcept
  {
  return (static_cast<size_type>(
   _Traits_find<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Count)));
  }

 size_type find( const _Elem * const _Ptr, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Traits::length(_Ptr))));
  }

 size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_ch<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ch)));
  }


 size_type rfind(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_rfind<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Right.data(), _Right.size())));
  }


 size_type rfind(const _Myt& _Right, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_rfind<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Right._Myptr(), _Right._Mysize())));
  }

 size_type rfind( const _Elem * const _Ptr, const size_type _Off, const size_type _Count) const
  noexcept
  {
  return (static_cast<size_type>(
   _Traits_rfind<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Count)));
  }

 size_type rfind( const _Elem * const _Ptr, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_rfind<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Traits::length(_Ptr))));
  }

 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_rfind_ch<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ch)));
  }


 size_type find_first_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_first_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right.data(), _Right.size())));
  }


 size_type find_first_of(const _Myt& _Right, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_first_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right._Myptr(), _Right._Mysize())));
  }

 size_type find_first_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_first_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Count)));
  }

 size_type find_first_of( const _Elem * const _Ptr, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_first_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Traits::length(_Ptr))));
  }

 size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_ch<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ch)));
  }


 size_type find_last_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_last_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right.data(), _Right.size())));
  }


 size_type find_last_of(const _Myt& _Right, size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_last_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right._Myptr(), _Right._Mysize())));
  }

 size_type find_last_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_last_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Count)));
  }

 size_type find_last_of( const _Elem * const _Ptr, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_last_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Traits::length(_Ptr))));
  }

 size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(_Traits_rfind_ch<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ch)));
  }


 size_type find_first_not_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = 0) const
  noexcept
  {
  return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right.data(), _Right.size())));
  }


 size_type find_first_not_of(const _Myt& _Right, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right._Myptr(), _Right._Mysize())));
  }

 size_type find_first_not_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_first_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Count)));
  }

 size_type find_first_not_of( const _Elem * const _Ptr, size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_first_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Traits::length(_Ptr))));
  }

 size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_not_ch<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ch)));
  }


 size_type find_last_not_of(const basic_string_view<_Elem, _Traits> _Right, const size_type _Off = npos) const
  noexcept
  {
  return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right.data(), _Right.size())));
  }


 size_type find_last_not_of(const _Myt& _Right, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Right._Myptr(), _Right._Mysize())));
  }

 size_type find_last_not_of( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_find_last_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ptr, _Count)));
  }

 size_type find_last_not_of( const _Elem * const _Ptr, const size_type _Off = npos) const
  noexcept
  {
  return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(this->_Myptr(), this->_Mysize(), _Off,
   _Ptr, _Traits::length(_Ptr))));
  }

 size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
  {
  return (static_cast<size_type>(
   _Traits_rfind_not_ch<_Traits>(this->_Myptr(), this->_Mysize(), _Off, _Ch)));
  }

 _Myt substr(const size_type _Off = 0, const size_type _Count = npos) const
  {
  return (_Myt(*this, _Off, _Count, get_allocator()));
  }

 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
  {
  return (_Min_value(_Size, this->_Mysize() - _Off));
  }

 bool _Equal(const _Myt& _Right) const noexcept
  {
  return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Right._Myptr(), _Right._Mysize()));
  }

 bool _Equal( const _Elem * const _Ptr) const noexcept
  {
  return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
  }


 int compare(const basic_string_view<_Elem, _Traits> _Right) const noexcept
  {
  return (_Traits_compare<_Traits>(this->_Myptr(), this->_Mysize(),
   _Right.data(), _Right.size()));
  }

 int compare(const size_type _Off, const size_type _N0,
  const basic_string_view<_Elem, _Traits> _Right) const
  {
  _Check_offset(_Off);
  return (_Traits_compare<_Traits>(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Right.data(), _Right.size()));
  }

 template<class _StringViewIsh,
  class = _Is_string_view_ish<_StringViewIsh>>
  int compare(const size_type _Off, const size_type _N0,
   const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) const
  {
  basic_string_view<_Elem, _Traits> _As_view = _Right;
  _Check_offset(_Off);
  const auto _With_substr = _As_view.substr(_Roff, _Count);
  return (_Traits_compare<_Traits>(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _With_substr.data(), _With_substr.size()));
  }


 int compare(const _Myt& _Right) const noexcept
  {
  return (_Traits_compare<_Traits>(this->_Myptr(), this->_Mysize(),
   _Right._Myptr(), _Right._Mysize()));
  }

 int compare(size_type _Off, size_type _N0, const _Myt& _Right) const
  {
  _Check_offset(_Off);
  return (_Traits_compare<_Traits>(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Right._Myptr(), _Right._Mysize()));
  }

 int compare(const size_type _Off, const size_type _N0, const _Myt& _Right,
  const size_type _Roff, const size_type _Count = npos) const
  {
  _Check_offset(_Off);
  _Right._Check_offset(_Roff);
  return (_Traits_compare<_Traits>(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Right._Myptr() + _Roff, _Right._Clamp_suffix_size(_Roff, _Count)));
  }

 int compare( const _Elem * const _Ptr) const noexcept
  {
  return (_Traits_compare<_Traits>(this->_Myptr(), this->_Mysize(),
   _Ptr, _Traits::length(_Ptr)));
  }

 int compare(const size_type _Off, const size_type _N0, const _Elem * const _Ptr) const
  {
  _Check_offset(_Off);
  return (_Traits_compare<_Traits>(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Ptr, _Traits::length(_Ptr)));
  }

 int compare(const size_type _Off, const size_type _N0, const _Elem * const _Ptr,
  const size_type _Count) const
  {
  _Check_offset(_Off);
  return (_Traits_compare<_Traits>(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
   _Ptr, _Count));
  }

 allocator_type get_allocator() const noexcept
  {
  allocator_type _Ret(this->_Getal());
  return (_Ret);
  }

 void _Chassign(const size_type _Off, const size_type _Count, const _Elem _Ch)
  {
  if (_Count == 1)
   {
   _Traits::assign(*(this->_Myptr() + _Off), _Ch);
   }
  else
   {
   _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
   }
  }

 void _Copy(const size_type _Newsize)
  {
  const auto _Max = max_size();
  if (_Newsize > _Max)
   {
   _Xlen();
   }

  auto& _My_data = this->_Get_data();
  const size_type _Oldres = _My_data._Myres;
  size_type _Newres = _Newsize | this->_ALLOC_MASK;
  if (_Max < _Newres)
   {
   _Newres = _Newsize;
   }
  else if (_Oldres / 2 <= _Newres / 3)
   ;
  else if (_Oldres <= _Max - _Oldres / 2)
   {
   _Newres = _Oldres + _Oldres / 2;
   }
  else
   {
   _Newres = _Max;
   }

  auto& _Al = this->_Getal();
  pointer _Ptr;
  try {
   _Ptr = _Al.allocate(_Newres + 1);
  } catch (...) {
   _Newres = _Newsize;
   _Ptr = _Al.allocate(_Newres + 1);
  }


  this->_Orphan_all();
  if (_My_data._Large_string_engaged())
   {
   _Traits::copy(_Unfancy(_Ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
   _Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);
   _My_data._Bx._Ptr = _Ptr;
   }
  else
   {
   _Traits::copy(_Unfancy(_Ptr), _My_data._Bx._Buf, _My_data._Mysize + 1);
   _Al.construct(::std:: addressof(_My_data._Bx._Ptr), _Ptr);
   }

  _My_data._Myres = _Newres;
  }

 void _Eos(const size_type _Newsize)
  {
  auto& _My_data = this->_Get_data();
  _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
  }

 bool _Grow(const size_type _Newsize)
  {
  if (_Newsize == 0)
   {
   _Eos(0);
   return (false);
   }

  if (this->_Myres() < _Newsize)
   {
   _Copy(_Newsize);
   }

  return (true);
  }

 bool _Inside(const _Elem * const _Ptr) const
  {
  const auto& _My_data = this->_Get_data();
  const _Elem * const _My_chars = _My_data._Myptr();
  return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);
  }

 void _Tidy_init()
  {
  auto& _My_data = this->_Get_data();
  _My_data._Mysize = 0;
  _My_data._Myres = this->_BUF_SIZE - 1;


  _Traits::assign(_My_data._Bx._Buf[0], _Elem());
  }

 void _Tidy_deallocate()
  {
  this->_Orphan_all();
  auto& _My_data = this->_Get_data();
  if (_My_data._Large_string_engaged())
   {
   pointer _Ptr = _My_data._Bx._Ptr;
   auto& _Al = this->_Getal();
   _Al.destroy(::std:: addressof(_My_data._Bx._Ptr));
   _Al.deallocate(_Ptr, _My_data._Myres + 1);
   }

  _My_data._Mysize = 0;
  _My_data._Myres = this->_BUF_SIZE - 1;


  _Traits::assign(_My_data._Bx._Buf[0], _Elem());
  }

 [[noreturn]] static void _Xlen()
  {
  _Xlength_error("string too long");
  }

 void _Check_offset(const size_type _Off) const
  {
  if (this->_Mysize() < _Off)
   {
   _Xran();
   }
  }

 void _Check_offset_exclusive(const size_type _Off) const
  {
  if (this->_Mysize() <= _Off)
   {
   _Xran();
   }
  }

 [[noreturn]] static void _Xran()
  {
  _Xout_of_range("invalid string position");
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
          const typename basic_string<_Elem, _Traits, _Alloc>::size_type
  basic_string<_Elem, _Traits, _Alloc>::npos =
   (typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);



template<class _Elem,
 class _Traits,
 class _Alloc> inline
 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>& _Right)
   noexcept(noexcept(_Left.swap(_Right)))
 {
 _Left.swap(_Right);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Traits::length(_Left) + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(1 + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Traits::length(_Right));
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + 1);
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 if (_Right.size() <= _Left.capacity() - _Left.size()
  || _Right.capacity() - _Right.size() < _Left.size())
  return (::std:: move(_Left.append(_Right)));
 else
  return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
         const _Elem * const _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
  size_type;
 return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
         const _Elem * const _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem _Right)
 {
 _Left.push_back(_Right);
 return (::std:: move(_Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left._Equal(_Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right._Equal(_Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
         const _Elem * const _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
         const _Elem * const _Right)
 {
 return (!(_Left < _Right));
 }

typedef basic_string<char, char_traits<char>, allocator<char> >
 string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
 wstring;


template<class _Elem,
 class _Traits,
 class _Alloc>
 struct hash<basic_string<_Elem, _Traits, _Alloc> >
 {
 typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
   _Keyval.size() * sizeof (_Elem)));
  }
 };

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
 u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
 u32string;
}


#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xfunctional" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
# 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xfunctional" 3
template<class _Ty = void>
 struct divides
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left / _Right);
  }
 };


template<class _Ty = void>
 struct modulus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left % _Right);
  }
 };


template<class _Ty = void>
 struct negate
 {
 typedef _Ty argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left) const
  {
  return (-_Left);
  }
 };





template<class _Ty = void>
 struct not_equal_to
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left != _Right);
  }
 };


template<class _Ty = void>
 struct greater
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left > _Right);
  }
 };





template<class _Ty = void>
 struct greater_equal
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left >= _Right);
  }
 };


template<class _Ty = void>
 struct less_equal
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left <= _Right);
  }
 };


template<class _Ty = void>
 struct logical_and
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left && _Right);
  }
 };


template<class _Ty = void>
 struct logical_or
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left || _Right);
  }
 };


template<class _Ty = void>
 struct logical_not
 {
 typedef _Ty argument_type;
 typedef bool result_type;

 constexpr bool operator()(const _Ty& _Left) const
  {
  return (!_Left);
  }
 };


template<class _Ty = void>
 struct bit_and
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left & _Right);
  }
 };


template<class _Ty = void>
 struct bit_or
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left | _Right);
  }
 };


template<class _Ty = void>
 struct bit_xor
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left ^ _Right);
  }
 };


template<class _Ty = void>
 struct bit_not
 {
 typedef _Ty argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator()(const _Ty& _Left) const
  {
  return (~_Left);
  }
 };
# 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xfunctional" 3
template<>
 struct divides<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct modulus<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct negate<void>
 {
 typedef int is_transparent;

 template<class _Ty>
  constexpr auto operator()(_Ty&& _Left) const
  -> decltype(-::std:: forward<_Ty>(_Left))
  {
  return (-::std:: forward<_Ty>(_Left));
  }
 };





template<>
 struct not_equal_to<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) != ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) != ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct greater<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) > ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) > ::std:: forward<_Ty2>(_Right));
  }
 };

template<class _Obj1,
 class _Obj2,
 class _FTy> inline
 _Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy>
  _Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const greater<_FTy>&)
 {
 return {};
 }





template<>
 struct greater_equal<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) >= ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) >= ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct less_equal<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) <= ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) <= ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct logical_and<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct logical_or<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct logical_not<void>
 {
 typedef int is_transparent;

 template<class _Ty>
  constexpr auto operator()(_Ty&& _Left) const
  -> decltype(!::std:: forward<_Ty>(_Left))
  {
  return (!::std:: forward<_Ty>(_Left));
  }
 };


template<>
 struct bit_and<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct bit_or<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct bit_xor<void>
 {
 typedef int is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right))
  {
  return (::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right));
  }
 };


template<>
 struct bit_not<void>
 {
 typedef int is_transparent;

 template<class _Ty>
  constexpr auto operator()(_Ty&& _Left) const
  -> decltype(~::std:: forward<_Ty>(_Left))
  {
  return (~::std:: forward<_Ty>(_Left));
  }
 };


template<class _Fn1>
 class unary_negate
 {
public:
 typedef typename _Fn1::argument_type argument_type;
 typedef bool result_type;

 constexpr explicit unary_negate(const _Fn1& _Func)
  : _Functor(_Func)
  {
  }

 constexpr bool operator()(const argument_type& _Left) const
  {
  return (!_Functor(_Left));
  }

private:
 _Fn1 _Functor;
 };


template<class _Fn1> inline
 constexpr unary_negate<_Fn1> not1(const _Fn1& _Func)
 {
 return (unary_negate<_Fn1>(_Func));
 }


template<class _Fn2>
 class binary_negate
 {
public:
 typedef typename _Fn2::first_argument_type first_argument_type;
 typedef typename _Fn2::second_argument_type second_argument_type;
 typedef bool result_type;

 constexpr explicit binary_negate(const _Fn2& _Func)
  : _Functor(_Func)
  {
  }

 constexpr bool operator()(const first_argument_type& _Left,
  const second_argument_type& _Right) const
  {
  return (!_Functor(_Left, _Right));
  }

private:
 _Fn2 _Functor;
 };


template<class _Fn2> inline
 constexpr binary_negate<_Fn2> not2(const _Fn2& _Func)
 {
 return (binary_negate<_Fn2>(_Func));
 }
# 982 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xfunctional" 3
}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\typeinfo" 1 3
# 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\typeinfo" 3
#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



#pragma warning(disable: 4275)


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_typeinfo.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_typeinfo.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_typeinfo.h" 2 3



#pragma pack(push, 8)







 struct __type_info_node;





    extern __type_info_node __type_info_root_node;




#pragma pack(push, 8)
# 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_typeinfo.h" 3
 extern "C" {


#pragma warning(push)
#pragma warning(disable: 4510 4512 4610)
struct __std_type_info_data
{
    char const* _UndecoratedName;
    char const _DecoratedName[1];
};
#pragma warning(pop)

__declspec(dllimport) int __cdecl __std_type_info_compare(
         __std_type_info_data const* _Lhs,
         __std_type_info_data const* _Rhs
    );

__declspec(dllimport) size_t __cdecl __std_type_info_hash(
         __std_type_info_data const* _Data
    );

__declspec(dllimport) char const* __cdecl __std_type_info_name(
            __std_type_info_data* _Data,
            __type_info_node* _RootNode
    );

}
# 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime_typeinfo.h" 3
#pragma pack(pop)



class type_info
{
public:

    type_info(type_info const&) = delete;
    type_info& operator=(type_info const&) = delete;

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    char const* name() const throw()
    {



        return __std_type_info_name(&_Data, &__type_info_root_node);

    }

    char const* raw_name() const throw()
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    mutable __std_type_info_data _Data;
};

namespace std {
 using ::type_info;
}



namespace std {

class bad_cast
    : public exception
{
public:

    bad_cast() throw()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() throw()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(char const* const _Message) throw()
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(char const* const _Message, int) throw()
        : bad_typeid(_Message, 1)
    {
    }
};

}



#pragma pack(pop)
# 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\typeinfo" 2 3


 namespace std {


constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof (void *);
# 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\typeinfo" 3
 }


#pragma pack(pop)
#pragma warning(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\tuple" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\tuple" 3
#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<bool _Same,
 class _Dest,
 class... _Srcs>
 struct _Tuple_implicit_val0
  : false_type
 {
 };

template<class... _Dests,
 class... _Srcs>
 struct _Tuple_implicit_val0<true, tuple<_Dests...>, _Srcs...>
  : _Conjunction_t<
   is_constructible<_Dests, _Srcs>...,
   is_convertible<_Srcs, _Dests>...
  >
 {
 };

template<class _Dest,
 class... _Srcs>
 struct _Tuple_implicit_val
  : _Tuple_implicit_val0<tuple_size<_Dest>::value == sizeof...(_Srcs), _Dest, _Srcs...>::type
 {
 };

template<class _Dest,
 class... _Srcs>
 using _Tuple_implicit_t = enable_if_t<_Tuple_implicit_val<_Dest, _Srcs...>::value, int>;


template<bool _Same,
 class _Dest,
 class... _Srcs>
 struct _Tuple_explicit_val0
  : false_type
 {
 };

template<class... _Dests,
 class... _Srcs>
 struct _Tuple_explicit_val0<true, tuple<_Dests...>, _Srcs...>
  : _Conjunction_t<
   is_constructible<_Dests, _Srcs>...,
   negation<conjunction<is_convertible<_Srcs, _Dests>...>>
  >
 {
 };

template<class _Dest,
 class... _Srcs>
 struct _Tuple_explicit_val
  : _Tuple_explicit_val0<tuple_size<_Dest>::value == sizeof...(_Srcs), _Dest, _Srcs...>::type
 {
 };

template<class _Dest,
 class... _Srcs>
 using _Tuple_explicit_t = enable_if_t<_Tuple_explicit_val<_Dest, _Srcs...>::value, int>;


template<class _Myt,
 class... _Other>
 struct _Tuple_convert_copy
 {
 typedef int type;
 };

template<class _This,
 class _Uty>
 struct _Tuple_convert_copy<tuple<_This>, _Uty>
  : enable_if<!is_same<_This, _Uty>::value
   && !is_constructible<_This, const tuple<_Uty>&>::value
   && !is_convertible<const tuple<_Uty>&, _This>::value, int>
 {
 };

template<class _Myt,
 class... _Other>
 using _Tuple_convert_copy_t = typename _Tuple_convert_copy<_Myt, _Other...>::type;


template<class _Myt,
 class... _Other>
 struct _Tuple_convert_move
 {
 typedef int type;
 };

template<class _This,
 class _Uty>
 struct _Tuple_convert_move<tuple<_This>, _Uty>
  : enable_if<!is_same<_This, _Uty>::value
   && !is_constructible<_This, tuple<_Uty> >::value
   && !is_convertible<tuple<_Uty>, _This>::value, int>
 {
 };

template<class _Myt,
 class... _Other>
 using _Tuple_convert_move_t = typename _Tuple_convert_move<_Myt, _Other...>::type;


template<class _Myt,
 class _This2,
 class... _Rest2>
 struct _Tuple_perfect_val
  : true_type
 {
 };

template<class _Myt,
 class _This2>
 struct _Tuple_perfect_val<_Myt, _This2>
  : negation<is_same<_Myt, remove_const_t<remove_reference_t<_This2>>>>::type
 {
 };


struct _Ignore
 {
 template<class _Ty>
  void operator=(const _Ty&) const
  {
  }
 };

constexpr _Ignore ignore{};


struct _Tuple_alloc_t
 {
 };

constexpr _Tuple_alloc_t _Tuple_alloc{};


template<class _Ty>
 struct _Tuple_val
 {
 constexpr _Tuple_val()
  : _Val()
  {
  }

 template<class _Other>
  constexpr _Tuple_val(_Other&& _Arg)
  : _Val(::std:: forward<_Other>(_Arg))
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc&,
   typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   typename enable_if<uses_allocator<_Ty, _Alloc>::value
    && is_constructible<_Ty,
     allocator_arg_t, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   typename enable_if<uses_allocator<_Ty, _Alloc>::value
    && !is_constructible<_Ty,
     allocator_arg_t, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)..., _Al)
  {
  }

 _Ty _Val;
 };


struct _Exact_args_t
 {
 };

struct _Unpack_tuple_t
 {
 };

struct _Alloc_exact_args_t
 {
 };

struct _Alloc_unpack_tuple_t
 {
 };

template<class... _Types>
 class tuple;

template<>
 class tuple<>
 {
public:
 typedef tuple<> _Myt;

 constexpr tuple() noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&) noexcept
  {
  }

 constexpr tuple(const tuple&) noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&, const _Myt&) noexcept
  {
  }

 template<class _Tag,
  enable_if_t<is_same<_Tag, _Exact_args_t>::value, int> = 0>
  constexpr tuple(_Tag) noexcept
  {
  }

 template<class _Tag,
  class _Alloc,
  enable_if_t<is_same<_Tag, _Alloc_exact_args_t>::value, int> = 0>
  tuple(_Tag, const _Alloc&) noexcept
  {
  }

 void swap(_Myt&) noexcept
  {
  }

 constexpr bool _Equals(const _Myt&) const noexcept
  {
  return (true);
  }

 constexpr bool _Less(const _Myt&) const noexcept
  {
  return (false);
  }
 };

template<class _This,
 class... _Rest>
 class tuple<_This, _Rest...>
  : private tuple<_Rest...>
 {
public:
 typedef _This _This_type;
 typedef tuple<_This, _Rest...> _Myt;
 typedef tuple<_Rest...> _Mybase;
 static constexpr size_t _Mysize = 1 + sizeof...(_Rest);

 template<class _Tag,
  class _This2,
  class... _Rest2,
  enable_if_t<is_same<_Tag, _Exact_args_t>::value, int> = 0>
  constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _Tag,
  class _Tpl,
  size_t... _Indices,
  enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0> inline
  constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

 template<class _Tag,
  class _Tpl,
  enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
  constexpr tuple(_Tag, _Tpl&& _Right)
  : tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
   make_index_sequence<tuple_size<remove_reference_t<_Tpl>>::value>{})
  {
  }

 template<class _Tag,
  class _Alloc,
  class _This2,
  class... _Rest2,
  enable_if_t<is_same<_Tag, _Alloc_exact_args_t>::value, int> = 0>
  tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(_Al, _Tuple_alloc, ::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _Tag,
  class _Alloc,
  class _Tpl,
  size_t... _Indices,
  enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int> = 0> inline
  tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

 template<class _Tag,
  class _Alloc,
  class _Tpl,
  enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int> = 0>
  tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
   make_index_sequence<tuple_size<remove_reference_t<_Tpl>>::value>{})
  {
  }

 template<class _This2 = _This,
  class = enable_if_t<conjunction<is_default_constructible<_This2>,
          is_default_constructible<_Rest>...>::value> >
  constexpr tuple()
  : _Mybase(), _Myfirst()
  {
  }

 template<class... _Other,
  _Tuple_implicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  constexpr tuple(const tuple<_Other...>& _Right)
   : tuple(_Unpack_tuple_t{}, _Right)
  {
  }

 template<class... _Other,
  _Tuple_explicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  constexpr explicit tuple(const tuple<_Other...>& _Right)
   : tuple(_Unpack_tuple_t{}, _Right)
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_implicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_explicit_t<_Myt, const _Other&...> = 0,
  _Tuple_convert_copy_t<_Myt, _Other...> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 template<class _This2 = _This,
  _Tuple_implicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
   : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
  {
  }

 template<class _This2 = _This,
  _Tuple_explicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
   : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
  {
  }

 template<class _Alloc,
  class _This2 = _This,
  _Tuple_implicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
  {
  }

 template<class _Alloc,
  class _This2 = _This,
  _Tuple_explicit_t<_Myt, const _This2&, const _Rest&...> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
  {
  }

 template<class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_implicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
   : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
  {
  }

 template<class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_explicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
   : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
  {
  }

 template<class _Alloc,
  class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_implicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
  {
  }

 template<class _Alloc,
  class _This2,
  class... _Rest2,
  enable_if_t<conjunction<
   _Tuple_perfect_val<_Myt, _This2, _Rest2...>,
   _Tuple_explicit_val<_Myt, _This2, _Rest2...>
  >::value, int> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
  {
  }

 template<class... _Other,
  _Tuple_implicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  constexpr tuple(tuple<_Other...>&& _Right)
   : tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
  {
  }

 template<class... _Other,
  _Tuple_explicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  constexpr explicit tuple(tuple<_Other...>&& _Right)
   : tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_implicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class _Alloc,
  class... _Other,
  _Tuple_explicit_t<_Myt, _Other...> = 0,
  _Tuple_convert_move_t<_Myt, _Other...> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class... _Other>
  _Myt& operator=(const tuple<_Other...>& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class... _Other>
  _Myt& operator=(tuple<_Other...>&& _Right)
  {
  _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>
   (_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<typename tuple<_Other...>::_Mybase>
   (_Right._Get_rest());
  return (*this);
  }

 template<class... _Other>
  constexpr bool _Equals(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other),
   "comparing tuple to object with different size");
  return (_Myfirst._Val == _Right._Myfirst._Val
   && _Mybase::_Equals(_Right._Get_rest()));
  }

 template<class... _Other>
  constexpr bool _Less(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other),
   "comparing tuple to object with different size");
  return (_Myfirst._Val < _Right._Myfirst._Val
   || (!(_Right._Myfirst._Val < _Myfirst._Val)
    && _Mybase::_Less(_Right._Get_rest())));
  }

 template<class _Alloc,
  class _This2 = _This,
  class = enable_if_t<conjunction<is_default_constructible<_This2>,
          is_default_constructible<_Rest>...>::value> >
  tuple(allocator_arg_t, const _Alloc& _Al)
  : _Mybase(allocator_arg, _Al), _Myfirst(_Al, _Tuple_alloc)
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _Myt& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 tuple(const _Myt&) = default;
 tuple(_Myt&&) = default;

 template<class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, const _First&, const _Second&> = 0>
  constexpr tuple(const pair<_First, _Second>& _Right)
   : tuple(_Unpack_tuple_t{}, _Right)
  {
  }

 template<class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, const _First&, const _Second&> = 0>
  constexpr explicit tuple(const pair<_First, _Second>& _Right)
   : tuple(_Unpack_tuple_t{}, _Right)
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, const _First&, const _Second&> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, const _First&, const _Second&> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
  {
  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(const pair<_First, _Second>& _Right)
  {
  static_assert(_Mysize == 2,
   "assigning to tuple from object with different size");
  _Myfirst._Val = _Right.first;
  _Get_rest()._Myfirst._Val = _Right.second;
  return (*this);
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _Myt&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, _First, _Second> = 0>
  constexpr tuple(pair<_First, _Second>&& _Right)
   : tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
  {
  }

 template<class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, _First, _Second> = 0>
  constexpr explicit tuple(pair<_First, _Second>&& _Right)
   : tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_implicit_t<_Myt, _First, _Second> = 0>
  tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 template<class _Alloc,
  class _First,
  class _Second,
  _Tuple_explicit_t<_Myt, _First, _Second> = 0>
  explicit tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)
  : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
  {
  }

 _Myt& operator=(_Myt&& _Right)
  noexcept(is_nothrow_move_assignable<_This>::value && is_nothrow_move_assignable<_Mybase>::value)

  {
  _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(pair<_First, _Second>&& _Right)
  {
  static_assert(_Mysize == 2,
   "assigning to tuple from object with different size");
  _Myfirst._Val = ::std:: forward<_First>(_Right.first);
  _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
  return (*this);
  }

 _Mybase& _Get_rest() noexcept
  {
  return (*this);
  }

 constexpr const _Mybase& _Get_rest() const noexcept
  {
  return (*this);
  }

 void swap(tuple& _Right)
  noexcept((conjunction<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>::value))

  {
  _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
  _Mybase::swap(_Right._Get_rest());
  }

 _Tuple_val<_This> _Myfirst;
 };




template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator==(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Equals(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator!=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Right < _Left);
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class... _Types,
 class = enable_if_t<conjunction<_Is_swappable<_Types>...>::value>> inline
 void swap(tuple<_Types...>& _Left,
  tuple<_Types...>& _Right)
   noexcept(noexcept(_Left.swap(_Right)))
 {
 return (_Left.swap(_Right));
 }



template<class _Ty,
 class _Tuple>
 struct _Tuple_element;

template<class _This,
 class... _Rest>
 struct _Tuple_element<_This, tuple<_This, _Rest...> >
 {
 typedef int _Check_type;
 static_assert(is_void<typename _Tuple_element<_This,
  tuple<_Rest...> >::_Check_type>::value,
  "duplicate type T in get<T>(tuple)");

 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<class _Ty,
 class _This,
 class... _Rest>
 struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
  : _Tuple_element<_Ty, tuple<_Rest...> >
 {
 };

template<class _Ty>
 struct _Tuple_element<_Ty, tuple<> >
 {
 typedef void _Check_type;
 };


template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&
  get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&
  get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&&
  get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
  _RRtype;
 return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
 }

template<size_t _Index,
 class... _Types> inline
 constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&&
  get(const tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 typedef const typename tuple_element<_Index, tuple<_Types...> >::type&&
  _RRtype;
 return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
 }


template<class _Ty,
 class... _Types> inline
 constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
 }

template<class _Ty,
 class... _Types> inline
 constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (::std:: forward<const _Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
 }


template<class _This,
 class... _Rest>
 template<class _Tag,
  class _Tpl,
  size_t... _Indices,
  enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int>> inline
  constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
  : tuple(_Exact_args_t{}, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...)
  {
  }

template<class _This,
 class... _Rest>
 template<class _Tag,
  class _Alloc,
  class _Tpl,
  size_t... _Indices,
  enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int>> inline
  tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
  : tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...)
  {
  }


template<class... _Types> inline
 constexpr tuple<typename _Unrefwrap<_Types>::type...>
  make_tuple(_Types&&... _Args)
 {
 typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
 return (_Ttype(::std:: forward<_Types>(_Args)...));
 }


template<class... _Types> inline
 constexpr tuple<_Types&...>
  tie(_Types&... _Args) noexcept
 {
 typedef tuple<_Types&...> _Ttype;
 return (_Ttype(_Args...));
 }




template<class... _Types> inline
 constexpr tuple<_Types&&...>
  forward_as_tuple(_Types&&... _Args) noexcept
 {
 return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
 }



template<class _Seq_type1,
 class _Seq_type2>
 struct _Cat_sequences;

template<size_t... _Indexes1,
 size_t... _Indexes2>
 struct _Cat_sequences<index_sequence<_Indexes1...>,
  index_sequence<_Indexes2...> >
 {
 typedef index_sequence<_Indexes1..., _Indexes2...> type;
 };


template<class _Ty,
 size_t _Size>
 class array;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;


template<class _Ty,
 class... _For_array>
 struct _View_as_tuple
 {
 static_assert(_Always_false<_Ty>::value,
  "Unsupported tuple_cat arguments.");
 };

template<class... _Types>
 struct _View_as_tuple<tuple<_Types...> >
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty1,
 class _Ty2>
 struct _View_as_tuple<pair<_Ty1, _Ty2> >
 {
 typedef tuple<_Ty1, _Ty2> type;
 };

template<class _Ty,
 class... _Types>
 struct _View_as_tuple<array<_Ty, 0>, _Types...>
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty,
 size_t _Size,
 class... _Types>
 struct _View_as_tuple<array<_Ty, _Size>, _Types...>
  : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
 {
 };


template<size_t _Nx,
 class _Ty>
 struct _Repeat_for
  : integral_constant<size_t, _Nx>
 {
 };


template<class _Ret,
 class _Kx_arg,
 class _Ix_arg,
 size_t _Ix_next,
 class... _Tuples>
 struct _Tuple_cat2
 {
 static_assert(sizeof...(_Tuples) == 0,
  "Unsupported tuple_cat arguments.");
 typedef _Ret type;
 typedef _Kx_arg _Kx_arg_seq;
 typedef _Ix_arg _Ix_arg_seq;
 };

template<class... _Types1,
 class _Kx_arg,
 size_t... _Ix,
 size_t _Ix_next,
 class... _Types2,
 class... _Rest>
 struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
  index_sequence<_Ix...>, _Ix_next,
  tuple<_Types2...>, _Rest...>
  : _Tuple_cat2<
   tuple<_Types1..., _Types2...>,
   typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
   index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
   _Ix_next + 1,
   _Rest...>
 {
 };

template<class... _Tuples>
 struct _Tuple_cat1
  : _Tuple_cat2<tuple<>, index_sequence<>,
    index_sequence<>, 0,
   typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
 {
 };

#pragma warning(push)
#pragma warning(disable: 4100)
template<class _Ret,
 size_t... _Kx,
 size_t... _Ix,
 class _Ty> inline
 constexpr _Ret _Tuple_cat(index_sequence<_Kx...>,
  index_sequence<_Ix...>, _Ty&& _Arg)
 {
 return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
 }
#pragma warning(pop)

template<class... _Tuples> inline
 constexpr typename _Tuple_cat1<_Tuples...>::type
  tuple_cat(_Tuples&&... _Tpls)
 {
 typedef _Tuple_cat1<_Tuples...> _Cat1;
 return (_Tuple_cat<typename _Cat1::type>(
  typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
  ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
 }



#pragma warning(push)
#pragma warning(disable: 4100)
template<class _Callable,
 class _Tuple,
 size_t... _Indices>
 constexpr decltype(auto) _Apply_impl(_Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>)
 {
 return (_C_invoke(::std:: forward<_Callable>(_Obj), ::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...));
 }
#pragma warning(pop)

template<class _Callable,
 class _Tuple>
 constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl)
 {
 return (_Apply_impl(::std:: forward<_Callable>(_Obj), ::std:: forward<_Tuple>(_Tpl),
  make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{}));
 }


#pragma warning(push)
#pragma warning(disable: 4100)
template<class _Ty,
 class _Tuple,
 size_t... _Indices>
 constexpr _Ty _Make_from_tuple_impl(_Tuple&& _Tpl, index_sequence<_Indices...>)
 {
 return (_Ty(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...));
 }
#pragma warning(pop)

template<class _Ty,
 class _Tuple>
 constexpr _Ty make_from_tuple(_Tuple&& _Tpl)
 {
 return (_Make_from_tuple_impl<_Ty>(::std:: forward<_Tuple>(_Tpl),
  make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{}));
 }



template<class _Tpl,
 class _Fx,
 size_t... _Indices> inline
 void _For_each_tuple_element_impl(_Tpl&& _Tuple,
  _Fx _Func, index_sequence<_Indices...>)
 {
 int _Ignored[] = { (static_cast<void>(_Func(
  ::std:: get<_Indices>(::std:: forward<_Tpl>(_Tuple))
  )), 0)... };
 (void)_Ignored;
 }

template<class _Tpl,
 class _Fx> inline
 void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
 {
 _For_each_tuple_element_impl(
  ::std:: forward<_Tpl>(_Tuple),
  _Func,
  make_index_sequence<tuple_size<remove_reference_t<_Tpl>>::value>()
  );
 }


#pragma warning(push)
#pragma warning(disable: 4100)

template<class _Ty1,
 class _Ty2>
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   index_sequence<_Indexes1...>,
   index_sequence<_Indexes2...>)
  : first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
   second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
  {
  }
#pragma warning(pop)


template<class _Ty1,
 class _Ty2>
 template<class... _Types1,
  class... _Types2> inline
  pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2)
  : pair(_Val1, _Val2,
   index_sequence_for<_Types1...>(),
   index_sequence_for<_Types2...>())
  {
  }

}

namespace std {

template<class... _Types,
 class _Alloc>
 struct uses_allocator<tuple<_Types...>, _Alloc>
  : true_type
 {
 };

}
# 1185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\tuple" 3
#pragma warning(pop)
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<class _Memptr>
 class _Mem_fn
  : public _Weak_types<_Memptr>::type
 {
private:
 _Memptr _Pm;

public:
 explicit _Mem_fn(_Memptr _Val) noexcept
  : _Pm(_Val)
  {
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...));
  }
 };

template<class _Rx,
 class _Ty> inline
 _Mem_fn<_Rx _Ty::*> mem_fn(_Rx _Ty::* _Pm) noexcept
 {
 return (_Mem_fn<_Rx _Ty::*>(_Pm));
 }




class bad_function_call
 : public exception
 {
public:
 bad_function_call() noexcept
  {
  }

 virtual const char * what() const noexcept
  {
  return ("bad function call");
  }
 };

[[noreturn]] __declspec(dllimport) void __cdecl _Xbad_function_call();


template<class _Fty>
 class function;

template<class _Ty> inline
 bool _Test_callable(const _Ty& _Arg, true_type) noexcept
 {
 return (!!_Arg);
 }

template<class _Ty> inline
 bool _Test_callable(const _Ty&, false_type) noexcept
 {
 return (true);
 }

template<class _Ty> inline
 bool _Test_callable(const _Ty& _Arg) noexcept
 {
 _Cat_base<is_member_pointer<_Ty>::value || (is_pointer<_Ty>::value
  && is_function<typename remove_pointer<_Ty>::type>::value)> _Testable;
 return (_Test_callable(_Arg, _Testable));
 }

template<class _Fty> inline
 bool _Test_callable(const function<_Fty>& _Arg) noexcept
 {
 return (!!_Arg);
 }

#pragma warning(push)
#pragma warning(disable: 4265)

template<class _Rx,
 class... _Types>
 class _Func_base
 {
public:
 typedef _Func_base<_Rx, _Types...> _Myt;

 virtual _Myt *_Copy(void *) const = 0;
 virtual _Myt *_Move(void *) = 0;
 virtual _Rx _Do_call(_Types&&...) = 0;
 virtual const type_info& _Target_type() const noexcept = 0;
 virtual void _Delete_this(bool) noexcept = 0;

 const void *_Target(const type_info& _Info) const noexcept
  {
  return (_Target_type() == _Info ? _Get() : 0);
  }

 _Func_base(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 _Func_base() = default;

 ~_Func_base() noexcept
  {
  }

private:
 virtual const void *_Get() const noexcept = 0;
 };
#pragma warning(pop)


constexpr size_t _Space_size = (_Small_object_num_ptrs - 1) * sizeof (void *);

template<class _Impl>
 struct _Is_large
  : bool_constant<_Space_size < sizeof (_Impl)
   || !_Impl::_Nothrow_move::value>
 {
 };

#pragma warning(push)
#pragma warning(disable: 4265)

template<class _Callable,
 class _Alloc,
 class _Rx,
 class... _Types>
 class _Func_impl final
  : public _Func_base<_Rx, _Types...>
 {
public:
 typedef _Func_impl<_Callable, _Alloc, _Rx, _Types...> _Myt;
 typedef _Func_base<_Rx, _Types...> _Mybase;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;
 typedef is_nothrow_move_constructible<_Callable> _Nothrow_move;

 template<class _Other1,
  class _Other2>
  _Func_impl(_Other1&& _Val, _Other2&& _Ax)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Other2>(_Ax), ::std:: forward<_Other1>(_Val))
  {
  }

 ~_Func_impl() noexcept
  {
  }

private:
 virtual _Mybase *_Copy(void *_Where) const
  {
  return (_Clone(_Where, _Is_large<_Myt>()));
  }

 template<class _Void>
  _Mybase *_Clone(_Void *, true_type) const
  {
  _Myalty _Al(_Myax());
  const auto _Ptr = _Al.allocate(1);

  try {
   _Al.construct(_Unfancy(_Ptr), _Callee(), _Myax());
  } catch (...) {
   _Al.deallocate(_Ptr, 1);
  throw;
  }

  return (_Unfancy(_Ptr));
  }

 template<class _Void>
  _Mybase *_Clone(_Void *_Where, false_type) const
  {
  _Myalty _Al(_Myax());
  _Myt * _Ptr = static_cast<_Myt *>(_Where);
  _Al.construct(_Ptr, _Callee(), _Myax());
  return (_Ptr);
  }

 virtual _Mybase *_Move(void *_Where)
  {
  _Myalty _Al(_Myax());
  _Myt *_Ptr = static_cast<_Myt *>(_Where);
  _Al.construct(_Ptr, ::std:: move(_Callee()), ::std:: move(_Myax()));
  return (_Ptr);
  }

 virtual _Rx _Do_call(_Types&&... _Args)
  {
  return (_Invoker_ret<_Rx>::_Call(_Callee(), ::std:: forward<_Types>(_Args)...));
  }

 virtual const type_info& _Target_type() const noexcept
  {
  return (typeid(_Callable));
  }

 virtual const void *_Get() const noexcept
  {
  return (::std:: addressof(_Callee()));
  }

 virtual void _Delete_this(bool _Deallocate) noexcept
  {
  _Myalty _Al(_Myax());
  _Al.destroy(this);
  if (_Deallocate)
   _Al.deallocate(_Al.address(*this), 1);
  }

 _Compressed_pair<_Alloc, _Callable> _Mypair;

 _Alloc& _Myax() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Alloc& _Myax() const noexcept
  {
  return (_Mypair._Get_first());
  }

 _Callable& _Callee() noexcept
  {
  return (_Mypair._Get_second());
  }

 const _Callable& _Callee() const noexcept
  {
  return (_Mypair._Get_second());
  }
 };
#pragma warning(pop)


template<class _Ret,
 class... _Types>
 class _Func_class
  : public _Arg_types<_Types...>
 {
public:
 typedef _Ret result_type;

 typedef _Func_class<_Ret, _Types...> _Myt;
 typedef _Func_base<_Ret, _Types...> _Ptrt;

 _Func_class() noexcept
  {
  _Set(0);
  }

 _Ret operator()(_Types... _Args) const
  {
  if (_Empty())
   _Xbad_function_call();
  return (_Getimpl()->_Do_call(::std:: forward<_Types>(_Args)...));
  }

 ~_Func_class() noexcept
  {
  _Tidy();
  }

protected:
 template<class _Fx>
  using _Enable_if_callable_t = enable_if_t<
   _Is_callable1<void, _Ret, _Fx, _Types...>::value>;

 bool _Empty() const noexcept
  {
  return (_Getimpl() == 0);
  }

 void _Reset_copy(const _Myt& _Right)
  {
  if (_Right._Empty())
   ;
  else
   _Set(_Right._Getimpl()->_Copy(_Getspace()));
  }

 void _Reset_move(_Myt&& _Right)
  {
  if (_Right._Empty())
   ;
  else if (_Right._Local())
   {
   _Set(_Right._Getimpl()->_Move(_Getspace()));
   _Right._Tidy();
   }
  else
   {
   _Set(_Right._Getimpl());
   _Right._Set(0);
   }
  }

 template<class _Fx>
  void _Reset(_Fx&& _Val)
  {
  _Reset_alloc(::std:: forward<_Fx>(_Val), allocator<int>());
  }

 template<class _Fx,
  class _Alloc>
  void _Reset_alloc(_Fx&& _Val, const _Alloc& _Ax)
  {
  if (!_Test_callable(_Val))
   {
   return;
   }

  typedef typename decay<_Fx>::type _Decayed;
  typedef _Func_impl<_Decayed, _Alloc, _Ret, _Types...> _Myimpl;
  _Myimpl *_Ptr = 0;

  typedef _Wrap_alloc<_Alloc> _Alimpl0;
  typedef typename _Alimpl0::template rebind<_Myimpl>::other _Alimpl;
  _Alimpl _Al(_Ax);

  _Reset_impl(::std:: forward<_Fx>(_Val), _Ax,
   _Ptr, _Al, _Is_large<_Myimpl>());
  }

 template<class _Fx,
  class _Alloc,
  class _Myimpl,
  class _Alimpl>
  void _Reset_impl(_Fx&& _Val, const _Alloc& _Ax,
   _Myimpl *, _Alimpl& _Al, true_type)
  {
  const auto _Ptr = _Al.allocate(1);

  try {
   _Al.construct(_Unfancy(_Ptr), ::std:: forward<_Fx>(_Val), _Ax);
  } catch (...) {
   _Al.deallocate(_Ptr, 1);
  throw;
  }

  _Set(_Unfancy(_Ptr));
  }

 template<class _Fx,
  class _Alloc,
  class _Myimpl,
  class _Alimpl>
  void _Reset_impl(_Fx&& _Val, const _Alloc& _Ax,
   _Myimpl *, _Alimpl& _Al, false_type)
  {
  _Myimpl *_Ptr = static_cast<_Myimpl *>(_Getspace());
  _Al.construct(_Ptr, ::std:: forward<_Fx>(_Val), _Ax);
  _Set(_Ptr);
  }

 void _Tidy() noexcept
  {
  if (!_Empty())
   {
   _Getimpl()->_Delete_this(!_Local());
   _Set(0);
   }
  }

 void _Swap(_Myt& _Right) noexcept
  {
  if (!_Local() && !_Right._Local())
   {
   _Ptrt *_Temp = _Getimpl();
   _Set(_Right._Getimpl());
   _Right._Set(_Temp);
   }
  else
   {
   _Myt _Temp;
   _Temp._Reset_move(::std:: move(*this));
   _Reset_move(::std:: move(_Right));
   _Right._Reset_move(::std:: move(_Temp));
   }
  }

 const type_info& _Target_type() const noexcept
  {
  return (_Getimpl() ? _Getimpl()->_Target_type() : typeid(void));
  }

 const void *_Target(const type_info& _Info) const noexcept
  {
  return (_Getimpl() ? _Getimpl()->_Target(_Info) : 0);
  }

private:
 bool _Local() const noexcept
  {
  return (_Getimpl() == _Getspace());
  }

 union _Storage
  {
  max_align_t _Dummy1;
  char _Dummy2[_Space_size];
  _Ptrt *_Ptrs[_Small_object_num_ptrs];
  };

 _Storage _Mystorage;
 enum {_EEN_IMPL = _Small_object_num_ptrs - 1};
 _Ptrt *_Getimpl() const noexcept
  {
  return (_Mystorage._Ptrs[_Small_object_num_ptrs - 1]);
  }

 void _Set(_Ptrt *_Ptr) noexcept
  {
  _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;
  }

 void *_Getspace() noexcept
  {
  return (&_Mystorage);
  }

 const void *_Getspace() const noexcept
  {
  return (&_Mystorage);
  }
 };


template<class _Tx>
 struct _Get_function_impl;
# 461 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 3
template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __cdecl (_Types...)> { typedef _Func_class<_Ret, _Types...> type; }; template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __vectorcall (_Types...)> { typedef _Func_class<_Ret, _Types...> type; };



template<class _Fty>
 class function
  : public _Get_function_impl<_Fty>::type
 {
private:
 typedef typename _Get_function_impl<_Fty>::type _Mybase;

public:
 typedef function<_Fty> _Myt;

 function() noexcept
  {
  }

 function(nullptr_t) noexcept
  {
  }

 function(const _Myt& _Right)
  {
  this->_Reset_copy(_Right);
  }

 template<class _Fx,
  class = typename _Mybase::template _Enable_if_callable_t<_Fx&>>
  function(_Fx _Func)
  {
  this->_Reset(::std:: move(_Func));
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc&) noexcept
  {
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept
  {
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc& _Ax, const _Myt& _Right)
  {
  this->_Reset_alloc(_Right, _Ax);
  }

 template<class _Fx,
  class _Alloc,
  class = typename _Mybase::template _Enable_if_callable_t<_Fx&>>
  function(allocator_arg_t, const _Alloc& _Ax, _Fx _Func)
  {
  this->_Reset_alloc(::std:: move(_Func), _Ax);
  }

 ~function() noexcept
  {
  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myt(_Right).swap(*this);
  return (*this);
  }

 function(_Myt&& _Right)
  {
  this->_Reset_move(::std:: move(_Right));
  }

 template<class _Alloc>
  function(allocator_arg_t, const _Alloc& _Al, _Myt&& _Right)
  {
  this->_Reset_alloc(::std:: move(_Right), _Al);
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != ::std:: addressof(_Right))
   {
   this->_Tidy();
   this->_Reset_move(::std:: move(_Right));
   }
  return (*this);
  }

 template<class _Fx,
  class = typename _Mybase::template _Enable_if_callable_t<decay_t<_Fx>&>>
  _Myt& operator=(_Fx&& _Func)
  {
  _Myt(::std:: forward<_Fx>(_Func)).swap(*this);
  return (*this);
  }
# 567 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 3
 _Myt& operator=(nullptr_t) noexcept
  {
  this->_Tidy();
  return (*this);
  }

 template<class _Fx>
  _Myt& operator=(reference_wrapper<_Fx> _Func) noexcept
  {
  this->_Tidy();
  this->_Reset(_Func);
  return (*this);
  }

 void swap(_Myt& _Right) noexcept
  {
  this->_Swap(_Right);
  }

 explicit operator bool() const noexcept
  {
  return (!this->_Empty());
  }

 const type_info& target_type() const noexcept
  {
  return (this->_Target_type());
  }

 template<class _Fx>
  _Fx *target() noexcept
  {
  return (static_cast<_Fx *>(const_cast<void *>(
   this->_Target(typeid(_Fx)))));
  }

 template<class _Fx>
  const _Fx *target() const noexcept
  {
  return (static_cast<const _Fx *>(this->_Target(typeid(_Fx))));
  }
 };


template<class _Fty> inline
 void swap(function<_Fty>& _Left, function<_Fty>& _Right) noexcept
 {
 _Left.swap(_Right);
 }


template<class _Fty> inline
 bool operator==(const function<_Fty>& _Other,
  nullptr_t) noexcept
 {
 return (!_Other);
 }

template<class _Fty> inline
 bool operator==(nullptr_t,
  const function<_Fty>& _Other) noexcept
 {
 return (!_Other);
 }

template<class _Fty> inline
 bool operator!=(const function<_Fty>& _Other,
  nullptr_t) noexcept
 {
 return (static_cast<bool>(_Other));
 }

template<class _Fty> inline
 bool operator!=(nullptr_t,
  const function<_Fty>& _Other) noexcept
 {
 return (static_cast<bool>(_Other));
 }



template<int _Nx>
 struct _Ph
 {
 };

template<class _Tx>
 struct is_placeholder
  : integral_constant<int, 0>
 {
 };

template<int _Nx>
 struct is_placeholder<_Ph<_Nx> >
  : integral_constant<int, _Nx>
 {
 };

template<class _Tx>
 struct is_placeholder<const _Tx>
  : is_placeholder<_Tx>
 {
 };

template<class _Tx>
 struct is_placeholder<volatile _Tx>
  : is_placeholder<_Tx>
 {
 };

template<class _Tx>
 struct is_placeholder<const volatile _Tx>
  : is_placeholder<_Tx>
 {
 };

template<class _Ty>
 constexpr int is_placeholder_v = is_placeholder<_Ty>::value;


template<class _Ret,
 class _Fx,
 class... _Types>
 class _Binder;


template<class _Tx>
 struct is_bind_expression
  : false_type
 {
 };

template<class _Ret,
 class _Fx,
 class... _Types>
 struct is_bind_expression<_Binder<_Ret, _Fx, _Types...> >
  : true_type
 {
 };

template<class _Tx>
 struct is_bind_expression<const _Tx>
  : is_bind_expression<_Tx>
 {
 };

template<class _Tx>
 struct is_bind_expression<volatile _Tx>
  : is_bind_expression<_Tx>
 {
 };

template<class _Tx>
 struct is_bind_expression<const volatile _Tx>
  : is_bind_expression<_Tx>
 {
 };

template<class _Ty>
 constexpr bool is_bind_expression_v = is_bind_expression<_Ty>::value;


template<class _Cv_TiD,
 bool = _Unrefwrap<_Cv_TiD>::_Is_refwrap,
 bool = is_bind_expression<_Cv_TiD>::value,
 int = is_placeholder<_Cv_TiD>::value>
 struct _Select_fixer;

template<class _Cv_TiD>
 struct _Select_fixer<_Cv_TiD, true, false, 0>
 {
 template<class _Untuple>
  static auto _Fix(_Cv_TiD& _Tid, _Untuple&&)
  -> typename _Cv_TiD::type&
  {
  return (_Tid.get());
  }
 };

template<class _Cv_TiD>
 struct _Select_fixer<_Cv_TiD, false, true, 0>
 {
#pragma warning(push)
#pragma warning(disable: 4100)
 template<class _Untuple,
  size_t... _Jx>
  static auto _Apply(_Cv_TiD& _Tid, _Untuple&& _Ut,
   index_sequence<_Jx...>)
  -> decltype(_Tid(::std:: get<_Jx>(::std:: move(_Ut))...))
  {
  return (_Tid(::std:: get<_Jx>(::std:: move(_Ut))...));
  }
#pragma warning(pop)

 template<class _Untuple>
  static auto _Fix(_Cv_TiD& _Tid, _Untuple&& _Ut)
  -> decltype(_Apply(_Tid, ::std:: move(_Ut),
   make_index_sequence<tuple_size<_Untuple>::value>()))
  {
  return (_Apply(_Tid, ::std:: move(_Ut),
   make_index_sequence<tuple_size<_Untuple>::value>()));
  }
 };

template<class _Cv_TiD>
 struct _Select_fixer<_Cv_TiD, false, false, 0>
 {
 template<class _Untuple>
  static _Cv_TiD& _Fix(_Cv_TiD& _Tid, _Untuple&&)
  {
  return (_Tid);
  }
 };

template<class _Cv_TiD,
 int _Jx>
 struct _Select_fixer<_Cv_TiD, false, false, _Jx>
 {
 static_assert(_Jx > 0, "invalid is_placeholder value");

 template<class _Untuple>
  static auto _Fix(_Cv_TiD&, _Untuple&& _Ut)
  -> decltype(::std:: get<_Jx - 1>(::std:: move(_Ut)))
  {
  return (::std:: get<_Jx - 1>(::std:: move(_Ut)));
  }
 };

template<class _Cv_TiD,
 class _Untuple> inline
 auto _Fix_arg(_Cv_TiD& _Tid, _Untuple&& _Ut)
 -> decltype(_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut)))
 {
 return (_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut)));
 }

#pragma warning(push)
#pragma warning(disable: 4100)

template<class _Ret,
 size_t... _Ix,
 class _Cv_FD,
 class _Cv_tuple_TiD,
 class _Untuple> inline
 auto _Call_binder(_Invoker_ret<_Ret>, index_sequence<_Ix...>,
  _Cv_FD& _Obj, _Cv_tuple_TiD& _Tpl, _Untuple&& _Ut)
 -> decltype(_Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...))
 {
 return (_Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...));
 }
#pragma warning(pop)


template<class _Ret>
 struct _Forced_result_type
 {
 typedef _Ret result_type;
 };

template<class _Ret,
 class _Fx>
 struct _Binder_result_type
 {
 typedef typename decay<_Fx>::type _Decayed;

 typedef typename _Weak_types<_Decayed>::type _All_weak_types;

 typedef typename _If<is_same<_Ret, _Unforced>::value,
  _Weak_result_type<_All_weak_types>,
  _Forced_result_type<_Ret> >::type type;
 };

template<class _Ret,
 class _Fx,
 class... _Types>
 class _Binder
  : public _Binder_result_type<_Ret, _Fx>::type
 {
private:
 typedef index_sequence_for<_Types...> _Seq;
 typedef typename decay<_Fx>::type _First;
 typedef tuple<typename decay<_Types>::type...> _Second;

 _Compressed_pair<_First, _Second> _Mypair;

public:
 explicit _Binder(_Fx&& _Func, _Types&&... _Args)
  : _Mypair(_One_then_variadic_args_t(),
   ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...)
  {
  }
# 871 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 3
template<class... _Unbound> auto operator()(_Unbound&&... _Unbargs) -> decltype(_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) { return (_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))); } template<class... _Unbound> auto operator()(_Unbound&&... _Unbargs) const -> decltype(_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) { return (_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))); }

 };


template<class _Fx,
 class... _Types> inline
 _Binder<_Unforced, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
 {
 return (_Binder<_Unforced, _Fx, _Types...>(
  ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...));
 }


template<class _Ret,
 class _Fx,
 class... _Types> inline
 _Binder<_Ret, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
 {
 return (_Binder<_Ret, _Fx, _Types...>(
  ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...));
 }


  namespace placeholders {
constexpr _Ph<1> _1{};
constexpr _Ph<2> _2{};
constexpr _Ph<3> _3{};
constexpr _Ph<4> _4{};
constexpr _Ph<5> _5{};
constexpr _Ph<6> _6{};
constexpr _Ph<7> _7{};
constexpr _Ph<8> _8{};
constexpr _Ph<9> _9{};
constexpr _Ph<10> _10{};
constexpr _Ph<11> _11{};
constexpr _Ph<12> _12{};
constexpr _Ph<13> _13{};
constexpr _Ph<14> _14{};
constexpr _Ph<15> _15{};
constexpr _Ph<16> _16{};
constexpr _Ph<17> _17{};
constexpr _Ph<18> _18{};
constexpr _Ph<19> _19{};
constexpr _Ph<20> _20{};
  }
# 933 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\functional" 3
}

namespace std {

template<class _Fty,
 class _Alloc>
 struct uses_allocator<function<_Fty>, _Alloc>
  : true_type
 {
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\chrono" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\ratio" 1 3








#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<intmax_t _Val>
 struct _Abs
 {
 static constexpr intmax_t value = _Val < 0 ? -_Val : _Val;
 };


template<intmax_t _Ax,
 intmax_t _Bx,
 bool _Sfinae = false,
 bool _Good = (_Abs<_Ax>::value
  <= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
 struct _Safe_mult
  : integral_constant<intmax_t, _Ax * _Bx>
 {
 };

template<intmax_t _Ax,
 intmax_t _Bx,
 bool _Sfinae>
 struct _Safe_mult<_Ax, _Bx, _Sfinae, false>
 {
 static_assert(_Sfinae,
  "integer arithmetic overflow");
 };


template<intmax_t _Val>
 struct _Sign_of
 {
 static constexpr intmax_t value = _Val < 0 ? -1 : 1;
 };


template<intmax_t _Ax,
 intmax_t _Bx,
 bool _Good,
 bool _Also_good>
 struct _Safe_addX
 {
 static constexpr intmax_t value = _Ax + _Bx;
 };

template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Safe_addX<_Ax, _Bx, false, false>
 {
 static_assert(_Always_false<_Safe_addX>::value,
  "integer arithmetic overflow");
 };

template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Safe_add
 {
 static constexpr intmax_t value = _Safe_addX<_Ax, _Bx,
  _Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
  (_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::value;
 };


template<intmax_t _Ax,
 intmax_t _Bx>
 struct _GcdX
 {
 static constexpr intmax_t value = _GcdX<_Bx, _Ax % _Bx>::value;
 };

template<intmax_t _Ax>
 struct _GcdX<_Ax, 0>
 {
 static constexpr intmax_t value = _Ax;
 };

template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Gcd
 {
 static constexpr intmax_t value =
  _GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::value;
 };

template<>
 struct _Gcd<0, 0>
 {
 static constexpr intmax_t value = 1;
 };


template<intmax_t _Nx,
 intmax_t _Dx = 1>
 struct ratio
 {
 static_assert(_Dx != 0,
  "zero denominator");
 static_assert(-9223372036854775807i64 <= _Nx,
  "numerator too negative");
 static_assert(-9223372036854775807i64 <= _Dx,
  "denominator too negative");

 static constexpr intmax_t num = _Sign_of<_Nx>::value
  * _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

 static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>
  ::value;

 typedef ratio<num, den> type;
 };


template<class _Ty1,
 class _Ty2>
 struct _Are_ratios
  : false_type
 {
 };

template<intmax_t _N1,
 intmax_t _D1,
 intmax_t _N2,
 intmax_t _D2>
 struct _Are_ratios<ratio<_N1, _D1>, ratio<_N2, _D2> >
  : true_type
 {
 };


template<class _R1,
 class _R2>
 struct _Ratio_add
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N1 = _R1::num;
 static constexpr intmax_t _D1 = _R1::den;
 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 static constexpr intmax_t _Gx = _Gcd<_D1, _D2>::value;


 typedef typename ratio<
  _Safe_add<
   _Safe_mult<_N1, _D2 / _Gx>::value,
   _Safe_mult<_N2, _D1 / _Gx>::value
   >::value,
  _Safe_mult<_D1, _D2 / _Gx>::value
  >::type type;
 };

template<class _R1,
 class _R2>
 using ratio_add = typename _Ratio_add<_R1, _R2>::type;


template<class _R1,
 class _R2>
 struct _Ratio_subtract
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 typedef ratio_add<_R1, ratio<-_N2, _D2> > type;
 };

template<class _R1,
 class _R2>
 using ratio_subtract = typename _Ratio_subtract<_R1, _R2>::type;


template<class _R1,
 class _R2>
 struct _Ratio_multiply
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N1 = _R1::num;
 static constexpr intmax_t _D1 = _R1::den;
 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 static constexpr intmax_t _Gx = _Gcd<_N1, _D2>::value;
 static constexpr intmax_t _Gy = _Gcd<_N2, _D1>::value;

 typedef _Safe_mult<_N1 / _Gx, _N2 / _Gy, true> _Num;
 typedef _Safe_mult<_D1 / _Gy, _D2 / _Gx, true> _Den;
 };

template<class _R1,
 class _R2,
 bool _Sfinae = true,
 class = void>
 struct _Ratio_multiply_sfinae
 {
 static_assert(_Sfinae,
  "integer arithmetic overflow");
 };

template<class _R1,
 class _R2,
 bool _Sfinae>
 struct _Ratio_multiply_sfinae<_R1, _R2, _Sfinae, void_t<
  typename _Ratio_multiply<_R1, _R2>::_Num::type,
  typename _Ratio_multiply<_R1, _R2>::_Den::type> >
 {
 typedef ratio<
  _Ratio_multiply<_R1, _R2>::_Num::value,
  _Ratio_multiply<_R1, _R2>::_Den::value> type;
 };

template<class _R1,
 class _R2>
 using ratio_multiply = typename _Ratio_multiply_sfinae<_R1, _R2, false>
  ::type;


template<class _R1,
 class _R2>
 struct _Ratio_divide
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 typedef ratio<_D2, _N2> _R2_inverse;
 };

template<class _R1,
 class _R2,
 bool _Sfinae = true>
 using _Ratio_divide_sfinae = typename _Ratio_multiply_sfinae<
  _R1, typename _Ratio_divide<_R1, _R2>::_R2_inverse, _Sfinae>::type;

template<class _R1,
 class _R2>
 using ratio_divide = _Ratio_divide_sfinae<_R1, _R2, false>;


template<class _R1,
 class _R2>
 struct ratio_equal
  : _Cat_base<_R1::num == _R2::num && _R1::den == _R2::den>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_not_equal
  : integral_constant<bool, !ratio_equal<_R1, _R2>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct _Ratio_less
 {
 static constexpr intmax_t _N1 = _R1::num;
 static constexpr intmax_t _D1 = _R1::den;
 static constexpr intmax_t _N2 = _R2::num;
 static constexpr intmax_t _D2 = _R2::den;

 static constexpr intmax_t _Gn = _Gcd<_N1, _N2>::value;
 static constexpr intmax_t _Gd = _Gcd<_D1, _D2>::value;

 static constexpr intmax_t _Left = _Safe_mult<_N1 / _Gn, _D2 / _Gd>::value;
 static constexpr intmax_t _Right = _Safe_mult<_N2 / _Gn, _D1 / _Gd>::value;

 typedef integral_constant<bool, (_Left < _Right)> type;
 };

template<class _R1,
 class _R2>
 struct ratio_less
  : _Ratio_less<_R1, _R2>::type
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_less_equal
  : integral_constant<bool, !ratio_less<_R2, _R1>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_greater
  : integral_constant<bool, ratio_less<_R2, _R1>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 struct ratio_greater_equal
  : integral_constant<bool, !ratio_less<_R1, _R2>::value>
 {
 static_assert(_Are_ratios<_R1, _R2>::value,
  "ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
 };


template<class _R1,
 class _R2>
 constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
template<class _R1,
 class _R2>
 constexpr bool ratio_greater_equal_v = ratio_greater_equal<_R1, _R2>::value;



typedef ratio<1, 1000000000000000000LL> atto;
typedef ratio<1, 1000000000000000LL> femto;
typedef ratio<1, 1000000000000LL> pico;

typedef ratio<1, 1000000000> nano;
typedef ratio<1, 1000000> micro;
typedef ratio<1, 1000> milli;
typedef ratio<1, 100> centi;
typedef ratio<1, 10> deci;
typedef ratio<10, 1> deca;
typedef ratio<100, 1> hecto;
typedef ratio<1000, 1> kilo;
typedef ratio<1000000, 1> mega;
typedef ratio<1000000000, 1> giga;

typedef ratio<1000000000000LL, 1> tera;
typedef ratio<1000000000000000LL, 1> peta;
typedef ratio<1000000000000000000LL, 1> exa;
}

#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\chrono" 2 3


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
 extern "C" {
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;
        long tv_nsec;
    };
# 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);




               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);




               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);




                             __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);




__declspec(dllimport) errno_t __cdecl _get_daylight(
          int* _Daylight
    );


__declspec(dllimport) errno_t __cdecl _get_dstbias(
          long* _DaylightSavingsBias
    );


__declspec(dllimport) errno_t __cdecl _get_timezone(
          long* _TimeZone
    );


__declspec(dllimport) errno_t __cdecl _get_tzname(
                                 size_t* _ReturnValue,
                                 char* _Buffer,
                                 size_t _SizeInBytes,
                                 int _Index
    );
# 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
         struct tm const* _Tm
    );




    __declspec(dllimport) errno_t __cdecl asctime_s(
                                                            char* _Buffer,
                                                            size_t _SizeInBytes,
                                                            struct tm const* _Tm
        );


extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(char (&_Buffer)[_Size], struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) clock_t __cdecl clock(void);



               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
         __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
                                                        char* _Buffer,
                                                        size_t _SizeInBytes,
                                                        __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(char (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }







               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
         __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
                                                          char* _Buffer,
                                                          size_t _SizeInBytes,
                                                          __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }






__declspec(dllimport) double __cdecl _difftime32(
         __time32_t _Time1,
         __time32_t _Time2
    );


__declspec(dllimport) double __cdecl _difftime64(
         __time64_t _Time1,
         __time64_t _Time2
    );


               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
         __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
          struct tm* _Tm,
          __time32_t const* _Time
    );


               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
         __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
          struct tm* _Tm,
          __time64_t const* _Time
    );


               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
         __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
          struct tm* _Tm,
          __time32_t const* _Time
    );


               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
         __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
          struct tm* _Tm,
          __time64_t const* _Time
    );


__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
            struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
            struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
            struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
            struct tm* _Tm
    );



__declspec(dllimport) size_t __cdecl strftime(
                                  char* _Buffer,
                                  size_t _SizeInBytes,
                                  char const* _Format,
                                  struct tm const* _Tm
    );



__declspec(dllimport) size_t __cdecl _strftime_l(
                                  char* _Buffer,
                                  size_t _MaxSize,
                                  char const* _Format,
                                  struct tm const* _Tm,
                                  _locale_t _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
                                                                                 char* _Buffer,
                                                                                 size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strdate( char *_Buffer);





__declspec(dllimport) errno_t __cdecl _strtime_s(
                                                                                 char* _Buffer,
                                                                                 size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);




__declspec(dllimport) __time32_t __cdecl _time32(
              __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
              __time64_t* _Time
    );



__declspec(dllimport) int __cdecl _timespec32_get(
          struct _timespec32* _Ts,
          int _Base
    );



__declspec(dllimport) int __cdecl _timespec64_get(
          struct _timespec64* _Ts,
          int _Base
    );
# 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
    __declspec(dllimport) void __cdecl _tzset(void);


    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
              struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
             struct tm* _Tm,
             unsigned _Milliseconds
        );
# 474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
                 time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _ctime64(_Time);
#pragma warning(pop)
 }


        static __inline double __cdecl difftime(
                 time_t const _Time1,
                 time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

                       __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
                 time_t const* const _Time)
        {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _gmtime64(_Time);
#pragma warning(pop)
 }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
                 time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
 return _localtime64(_Time);
#pragma warning(pop)
 }


        static __inline time_t __cdecl _mkgmtime(
                    struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }


        static __inline time_t __cdecl mktime(
                    struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
                      time_t* const _Time
            )
        {
            return _time64(_Time);
        }


        static __inline int __cdecl timespec_get(
                  struct timespec* const _Ts,
                  int const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }



            static __inline errno_t __cdecl ctime_s(
                                                                    char* const _Buffer,
                                                                    size_t const _SizeInBytes,
                                                                    time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }


            static __inline errno_t __cdecl gmtime_s(
                      struct tm* const _Tm,
                      time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }


            static __inline errno_t __cdecl localtime_s(
                      struct tm* const _Tm,
                      time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
# 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);






}
# 600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h" 3
#pragma pack(pop)
# 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\chrono" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xtimec.h" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthrcommon.h" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)
# 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthrcommon.h" 3
extern "C" {
# 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthrcommon.h" 3
typedef unsigned int _Thrd_id_t;
typedef struct
 {
 void *_Hnd;
 _Thrd_id_t _Id;
 } _Thrd_imp_t;





typedef unsigned int (__stdcall *_Thrd_callback_t)(void *);
# 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthrcommon.h" 3
typedef struct _Mtx_internal_imp_t *_Mtx_imp_t;

typedef struct _Cnd_internal_imp_t *_Cnd_imp_t;
typedef int _Tss_imp_t;


__declspec(dllimport) void __cdecl _Thrd_abort(const char *);
__declspec(dllimport) int __cdecl _Thrd_start(_Thrd_imp_t *, _Thrd_callback_t, void *);
void _Tss_destroy(void);
# 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthrcommon.h" 3
}
# 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthrcommon.h" 3
#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xtimec.h" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)




extern "C" {


typedef struct xtime
 {
 __time64_t sec;
 long nsec;
 } xtime;

__declspec(dllimport) int __cdecl xtime_get(xtime*, int);

__declspec(dllimport) long __cdecl _Xtime_diff_to_millis(const xtime *);
__declspec(dllimport) long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime *);
__declspec(dllimport) long long __cdecl _Xtime_get_ticks(void);



__declspec(dllimport) long long __cdecl _Query_perf_counter(void);
__declspec(dllimport) long long __cdecl _Query_perf_frequency(void);


}


#pragma warning(pop)
#pragma pack(pop)
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\chrono" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
namespace chrono {

template<class _Rep>
 struct treat_as_floating_point
  : is_floating_point<_Rep>
 {
 };

template<class _Rep>
 constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;


template<class _Rep>
 struct duration_values
 {
 static constexpr _Rep zero()
  {
  return (_Rep(0));
  }

 static constexpr _Rep (min)()
  {
  return (numeric_limits<_Rep>::lowest());
  }

 static constexpr _Rep (max)()
  {
  return ((numeric_limits<_Rep>::max)());
  }
 };


template<class _Ty>
 struct _Is_ratio
 {
 static constexpr bool value = false;
 };

template<intmax_t _R1,
 intmax_t _R2>
 struct _Is_ratio<ratio<_R1, _R2> >
 {
 static constexpr bool value = true;
 };


template<class _Rep,
 class _Period = ratio<1> >
 class duration;

template<class _Ty>
 struct _Is_duration
  : false_type
 {
 };

template<class _Rep,
 class _Period>
 struct _Is_duration<duration<_Rep, _Period> >
  : true_type
 {
 };

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  duration_cast(const duration<_Rep, _Period>&);

template<class _Rep,
 class _Period>
 class duration
 {
public:
 typedef duration<_Rep, _Period> _Myt;
 typedef _Rep rep;
 typedef _Period period;

 static_assert(!_Is_duration<_Rep>::value,
  "duration can't have duration as first template argument");
 static_assert(_Is_ratio<_Period>::value,
  "period not an instance of std::ratio");
 static_assert(0 < _Period::num,
  "period negative or zero");

 constexpr duration() = default;

 template<class _Rep2,
  class = typename enable_if<is_convertible<_Rep2, _Rep>::value
   && (treat_as_floating_point<_Rep>::value
    || !treat_as_floating_point<_Rep2>::value),
   void>::type>
  constexpr explicit duration(const _Rep2& _Val)
   : _MyRep(static_cast<_Rep>(_Val))
  {
  }

 template<class _Rep2,
  class _Period2,
  class = typename enable_if<treat_as_floating_point<_Rep>::value

   || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1

    && !treat_as_floating_point<_Rep2>::value),
   void>::type>
  constexpr duration(const duration<_Rep2, _Period2>& _Dur)
   : _MyRep(chrono::duration_cast<_Myt>(_Dur).count())
  {
  }

 constexpr _Rep count() const
  {
  return (_MyRep);
  }

 constexpr _Myt operator+() const
  {
  return (*this);
  }

 constexpr _Myt operator-() const
  {
  return (_Myt(0 - _MyRep));
  }

 _Myt& operator++()
  {
  ++_MyRep;
  return (*this);
  }

 _Myt operator++(int)
  {
  return (_Myt(_MyRep++));
  }

 _Myt& operator--()
  {
  --_MyRep;
  return (*this);
  }

 _Myt operator--(int)
  {
  return (_Myt(_MyRep--));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  _MyRep += _Right._MyRep;
  return (*this);
  }

 _Myt& operator-=(const _Myt& _Right)
  {
  _MyRep -= _Right._MyRep;
  return (*this);
  }

 _Myt& operator*=(const _Rep& _Right)
  {
  _MyRep *= _Right;
  return (*this);
  }

 _Myt& operator/=(const _Rep& _Right)
  {
  _MyRep /= _Right;
  return (*this);
  }

 _Myt& operator%=(const _Rep& _Right)
  {
  _MyRep %= _Right;
  return (*this);
  }

 _Myt& operator%=(const _Myt& _Right)
  {
  _MyRep %= _Right.count();
  return (*this);
  }

 static constexpr _Myt zero()
  {
  return (_Myt(duration_values<_Rep>::zero()));
  }

 static constexpr _Myt (min)()
  {
  return (_Myt((duration_values<_Rep>::min)()));
  }
 static constexpr _Myt (max)()
  {
  return (_Myt((duration_values<_Rep>::max)()));
  }

private:
 _Rep _MyRep;
 };

template<class _Clock,
 class _Duration = typename _Clock::duration>
 class time_point
 {
public:
 typedef _Clock clock;
 typedef _Duration duration;
 typedef typename _Duration::rep rep;
 typedef typename _Duration::period period;

 static_assert(_Is_duration<_Duration>::value,
  "duration must be an instance of std::duration");

 constexpr time_point()
  : _MyDur(_Duration::zero())
  {
  }

 constexpr explicit time_point(const _Duration& _Other)
  : _MyDur(_Other)
  {
  }

 template<class _Duration2,
  class = typename enable_if<is_convertible<_Duration2,
   _Duration>::value,
   void>::type>
  constexpr time_point(const time_point<_Clock, _Duration2>& _Tp)
  : _MyDur(_Tp.time_since_epoch())
  {
  }

 constexpr _Duration time_since_epoch() const
  {
  return (_MyDur);
  }

 time_point& operator+=(const _Duration& _Dur)
  {
  _MyDur += _Dur;
  return (*this);
  }

 time_point& operator-=(const _Duration& _Dur)
  {
  _MyDur -= _Dur;
  return (*this);
  }

 static constexpr time_point (min)()
  {
  return (time_point((_Duration::min)()));
  }
 static constexpr time_point (max)()
  {
  return (time_point((_Duration::max)()));
  }

private:
 _Duration _MyDur;
 };
}


template<intmax_t _Ax,
 intmax_t _Bx>
 struct _Lcm
 {
 static constexpr intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
 static constexpr intmax_t value = (_Ax / _Gx) * _Bx;
 };


template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2>
 struct common_type<
  chrono::duration<_Rep1, _Period1>,
  chrono::duration<_Rep2, _Period2> >
 {
 typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
  ratio<_Gcd<_Period1::num, _Period2::num>::value,
   _Lcm<_Period1::den, _Period2::den>::value> > type;
 };

template<class _Clock,
 class _Duration1,
 class _Duration2>
 struct common_type<
  chrono::time_point<_Clock, _Duration1>,
  chrono::time_point<_Clock, _Duration2> >
 {
 typedef chrono::time_point<
  _Clock, typename common_type<_Duration1, _Duration2>::type> type;
 };

namespace chrono {

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type
  operator+(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_CD(_Left).count() + _CD(_Right).count()));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type
  operator-(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_CD(_Left).count() - _CD(_Right).count()));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2> inline
 constexpr typename enable_if<is_convertible<_Rep2,
  typename common_type<_Rep1, _Rep2>::type>::value,
  duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
  operator*(
   const duration<_Rep1, _Period1>& _Left,
   const _Rep2& _Right)
 {
 typedef typename common_type<_Rep1, _Rep2>::type _CR;
 typedef duration<_CR, _Period1> _CD;
 return (_CD(_CD(_Left).count() * _Right));
 }

template<class _Rep1,
 class _Rep2,
 class _Period2> inline
 constexpr typename enable_if<is_convertible<_Rep1,
  typename common_type<_Rep1, _Rep2>::type>::value,
  duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
  operator*(
   const _Rep1& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 return (_Right * _Left);
 }

template<class _CR,
 class _Period1,
 class _Rep2,
 bool = is_convertible<_Rep2, _CR>::value>
 struct _Duration_div_mod1
 {
 typedef duration<_CR, _Period1> type;
 };

template<class _CR,
 class _Period1,
 class _Rep2>
 struct _Duration_div_mod1<_CR, _Period1, _Rep2, false>
 {
 };

template<class _Rep1,
 class _Period1,
 class _Rep2,
 bool = _Is_duration<_Rep2>::value>
 struct _Duration_div_mod
 {
 };

template<class _Rep1,
 class _Period1,
 class _Rep2>
 struct _Duration_div_mod<_Rep1, _Period1, _Rep2, false>
  : _Duration_div_mod1<typename common_type<_Rep1, _Rep2>::type,
   _Period1, _Rep2>
 {
 };

template<class _Rep1,
 class _Period1,
 class _Rep2> inline
 typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
  constexpr operator/(
   const duration<_Rep1, _Period1>& _Left,
   const _Rep2& _Right)
 {
 typedef typename common_type<_Rep1, _Rep2>::type _CR;
 typedef duration<_CR, _Period1> _CD;
 return (_CD(_CD(_Left).count() / _Right));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<_Rep1, _Rep2>::type
  operator/(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_Left).count() / _CD(_Right).count());
 }

template<class _Rep1,
 class _Period1,
 class _Rep2> inline
 constexpr typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
  operator%(
   const duration<_Rep1, _Period1>& _Left,
   const _Rep2& _Right)
 {
 typedef typename common_type<_Rep1, _Rep2>::type _CR;
 typedef duration<_CR, _Period1> _CD;
 return (_CD(_CD(_Left).count() % _Right));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
  operator%(
   const duration<_Rep1, _Period1>& _Left,
   const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
 return (_CD(_CD(_Left).count() % _CD(_Right).count()));
 }


template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator==(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type _CT;
 return (_CT(_Left).count() == _CT(_Right).count());
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator!=(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator<(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 typedef typename common_type<
  duration<_Rep1, _Period1>,
  duration<_Rep2, _Period2> >::type _CT;
 return (_CT(_Left).count() < _CT(_Right).count());
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator<=(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator>(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Rep1,
 class _Period1,
 class _Rep2,
 class _Period2> inline
 constexpr bool operator>=(
  const duration<_Rep1, _Period1>& _Left,
  const duration<_Rep2, _Period2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  duration_cast(const duration<_Rep, _Period>& _Dur)
 {
 typedef ratio_divide<_Period, typename _To::period> _CF;

 typedef typename _To::rep _ToRep;
 typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;

#pragma warning(push)
#pragma warning(disable: 6326)
 return (_CF::num == 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
  : _CF::num != 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(
    static_cast<_CR>(
     _Dur.count()) * static_cast<_CR>(_CF::num)))
  : _CF::num == 1 && _CF::den != 1
   ? static_cast<_To>(static_cast<_ToRep>(
    static_cast<_CR>(_Dur.count())
     / static_cast<_CR>(_CF::den)))
  : static_cast<_To>(static_cast<_ToRep>(
   static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
    / static_cast<_CR>(_CF::den))));
#pragma warning(pop)
 }


template<class _Dur>
 using _As_integral = duration<
  typename conditional<treat_as_floating_point<typename _Dur::rep>::value,
   intmax_t,
   typename _Dur::rep>::type,
  typename _Dur::period>;


template<class _Rep,
 class _Period,
 class _To_integral> inline
 constexpr _To_integral _Floor(const duration<_Rep, _Period>& _Dur,
  const _To_integral& _Dur_integral)
 {
 return (_Dur_integral <= _Dur
  ? _Dur_integral
  : _Dur_integral - static_cast<_To_integral>(1));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  floor(const duration<_Rep, _Period>& _Dur)
 {

 return (_Floor(_Dur, chrono::duration_cast<_As_integral<_To> >(_Dur)));
 }


template<class _Rep,
 class _Period,
 class _To_integral> inline
 constexpr _To_integral _Ceil(const duration<_Rep, _Period>& _Dur,
  const _To_integral& _Dur_integral)
 {
 return (_Dur <= _Dur_integral
  ? _Dur_integral
  : _Dur_integral + static_cast<_To_integral>(1));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  ceil(const duration<_Rep, _Period>& _Dur)
 {

 return (_Ceil(_Dur, chrono::duration_cast<_As_integral<_To> >(_Dur)));
 }


template<class _Rep> inline
 constexpr typename make_unsigned<_Rep>::type _Make_unsigned(_Rep _Val)
 {
 return (static_cast<typename make_unsigned<_Rep>::type>(_Val));
 }


template<class _Rep> inline
 constexpr bool _Is_even(_Rep _Val)
 {
 return (_Val % 2 == 0);
 }


template<class _Rep> inline
 constexpr _Rep _Bankers_divide_impl(_Rep _Truncated, _Rep _Mod,
  _Rep _Half_divisor, bool _Half_divisor_is_exact)
 {
 return (_Truncated + static_cast<_Rep>(

  _Mod > _Half_divisor

   || (_Mod == _Half_divisor

   && _Half_divisor_is_exact
   && !_Is_even(_Truncated)
  )));
 }

template<class _Rep> inline
 constexpr _Rep _Bankers_divide_tag(_Rep _Dividend, _Rep _Divisor, false_type)
 {
 return (_Bankers_divide_impl(
  _Dividend / _Divisor,
  _Dividend % _Divisor,
  _Divisor / static_cast<_Rep>(2),
  _Is_even(_Divisor)));
 }

template<class _Rep> inline
 constexpr _Rep _Bankers_divide_tag(_Rep _Dividend, _Rep _Divisor, true_type)
 {
 return (static_cast<_Rep>(duration_values<_Rep>::zero() <= _Dividend
  ? _Bankers_divide_tag(_Make_unsigned(_Dividend),
   _Make_unsigned(_Divisor), false_type())
  : duration_values<_Rep>::zero() - _Bankers_divide_tag(
   duration_values<_Rep>::zero() - _Make_unsigned(_Dividend),
   _Make_unsigned(_Divisor), false_type())));
 }

template<class _Rep> inline
 constexpr _Rep _Bankers_divide(_Rep _Dividend, _Rep _Divisor)
 {



 return (_Bankers_divide_tag(_Dividend, _Divisor, is_signed<_Rep>()));
 }


template<class _Rep> inline
 constexpr bool _Round_should_truncate(_Rep _Val, intmax_t _Val_trunc)
 {
 return (_Val - static_cast<_Rep>(_Val_trunc) < static_cast<_Rep>(_Val_trunc + 1) - _Val
  || (_Val - static_cast<_Rep>(_Val_trunc) == static_cast<_Rep>(_Val_trunc + 1) - _Val
   && _Is_even(_Val_trunc)));
 }

template<class _Rep> inline
 constexpr intmax_t _Round_fp_non_negative(_Rep _Val, intmax_t _Val_trunc)
 {
 return (_Round_should_truncate(_Val, _Val_trunc) ? _Val_trunc : _Val_trunc + 1);
 }

template<class _Rep> inline
 constexpr intmax_t _Round_fp_non_negative(_Rep _Val)
 {
 return (_Round_fp_non_negative(_Val, static_cast<intmax_t>(_Val)));
 }

template<class _Rep> inline
 constexpr _Rep _Round_fp(_Rep _Val)
 {

 static_assert(treat_as_floating_point<_Rep>::value,
  "_Round_fp needs floating input");
 return (static_cast<_Rep>(duration_values<_Rep>::zero() <= _Val
  ? _Round_fp_non_negative(_Val)
  : (duration_values<_Rep>::zero()
   - _Round_fp_non_negative(duration_values<_Rep>::zero() - _Val))
  ));
 }


template<class _To,
 class _Rep,
 class _Period> inline
 constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
  false_type, false_type)
 {
 typedef ratio_divide<_Period, typename _To::period> _CF;

 typedef typename _To::rep _ToRep;
 typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;

#pragma warning(push)
#pragma warning(disable: 6326)
 return (_CF::num == 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
  : _CF::num != 1 && _CF::den == 1
   ? static_cast<_To>(static_cast<_ToRep>(
    static_cast<_CR>(
     _Dur.count()) * static_cast<_CR>(_CF::num)))
  : _CF::num == 1 && _CF::den != 1
   ? static_cast<_To>(static_cast<_ToRep>(_Bankers_divide(
    static_cast<_CR>(_Dur.count()), static_cast<_CR>(_CF::den))))
  : static_cast<_To>(static_cast<_ToRep>(
   _Bankers_divide(
    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num),
    static_cast<_CR>(_CF::den)))));
#pragma warning(pop)
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
  false_type, true_type)
 {


 typedef duration<_Rep, typename _To::period> _FloatTo;
 return (static_cast<_To>(static_cast<typename _To::rep>(
  _Round_fp(chrono::duration_cast<_FloatTo>(_Dur).count()))));
 }

template<class _To,
 class _Rep,
 class _Period,
 class _Source_integral> inline
 constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
  true_type, _Source_integral)
 {

 return (static_cast<_To>(_Round_fp(chrono::duration_cast<_To>(_Dur).count())));
 }

template<class _To,
 class _Rep,
 class _Period> inline
 constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
  round(const duration<_Rep, _Period>& _Dur)
 {
 return (_Round<_To>(_Dur,
  treat_as_floating_point<typename _To::rep>(),
  treat_as_floating_point<_Rep>()));
 }


template<class _Rep,
 class _Period> inline
 constexpr typename enable_if<numeric_limits<_Rep>::is_signed,
  duration<_Rep, _Period> >::type
  abs(const duration<_Rep, _Period> _Dur)
 {
 return (_Dur < duration<_Rep, _Period>::zero()
  ? duration<_Rep, _Period>::zero() - _Dur
  : _Dur);
 }


typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<int, ratio<60> > minutes;
typedef duration<int, ratio<3600> > hours;


template<class _Clock,
 class _Duration,
 class _Rep,
 class _Period> inline
 constexpr time_point<_Clock,
  typename common_type<_Duration, duration<_Rep, _Period> >::type>
  operator+(
   const time_point<_Clock, _Duration>& _Left,
   const duration<_Rep, _Period>& _Right)
 {
 typedef time_point<_Clock, typename common_type<
  _Duration, duration<_Rep, _Period> >::type> _RT;
 return (_RT(_Left.time_since_epoch() + _Right));
 }

template<class _Rep,
 class _Period,
 class _Clock,
 class _Duration> inline
 constexpr time_point<_Clock,
  typename common_type<duration<_Rep, _Period>, _Duration>::type>
  operator+(
   const duration<_Rep, _Period>& _Left,
   const time_point<_Clock, _Duration>& _Right)
 {
 return (_Right + _Left);
 }

template<class _Clock,
 class _Duration,
 class _Rep,
 class _Period> inline
 constexpr time_point<_Clock,
  typename common_type<_Duration, duration<_Rep, _Period> >::type>
  operator-(
   const time_point<_Clock, _Duration>& _Left,
   const duration<_Rep, _Period>& _Right)
 {
 return (_Left + (-_Right));
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr typename common_type<_Duration1, _Duration2>::type
  operator-(
   const time_point<_Clock, _Duration1>& _Left,
   const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Left.time_since_epoch() - _Right.time_since_epoch());
 }


template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator==(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Left.time_since_epoch() == _Right.time_since_epoch());
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator!=(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator<(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Left.time_since_epoch() < _Right.time_since_epoch());
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator<=(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator>(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Clock,
 class _Duration1,
 class _Duration2> inline
 constexpr bool operator>=(
  const time_point<_Clock, _Duration1>& _Left,
  const time_point<_Clock, _Duration2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  time_point_cast(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::duration_cast<_To>(_Time.time_since_epoch())));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  floor(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::floor<_To>(_Time.time_since_epoch())));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  ceil(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::ceil<_To>(_Time.time_since_epoch())));
 }


template<class _To,
 class _Clock,
 class _Duration> inline
 constexpr typename enable_if<_Is_duration<_To>::value,
  time_point<_Clock, _To> >::type
  round(const time_point<_Clock, _Duration>& _Time)
 {
 return (time_point<_Clock, _To>(
  chrono::round<_To>(_Time.time_since_epoch())));
 }


struct system_clock

 {
 typedef long long rep;

 typedef ratio_multiply<ratio<100, 1>, nano> period;

 typedef chrono::duration<rep, period> duration;
 typedef chrono::time_point<system_clock> time_point;
 static constexpr bool is_steady = false;

 static time_point now() noexcept
  {
  return (time_point(duration(_Xtime_get_ticks())));
  }

 static __time64_t to_time_t(const time_point& _Time) noexcept
  {
  return ((__time64_t)(_Time.time_since_epoch().count()
   / (long long)10000000));
  }

 static time_point from_time_t(__time64_t _Tm) noexcept
  {
  return (time_point(duration(_Tm * (long long)10000000)));
  }
 };

struct steady_clock
 {
 typedef long long rep;
 typedef nano period;
 typedef nanoseconds duration;
 typedef chrono::time_point<steady_clock> time_point;
 static constexpr bool is_steady = true;

 static time_point now() noexcept
  {
  const long long _Freq = _Query_perf_frequency();
  const long long _Ctr = _Query_perf_counter();
  static_assert(period::num == 1, "This assumes period::num == 1.");
  const long long _Whole = (_Ctr / _Freq) * period::den;
  const long long _Part = (_Ctr % _Freq) * period::den / _Freq;
  return (time_point(duration(_Whole + _Part)));
  }
 };

typedef steady_clock high_resolution_clock;
}


template<class _Rep,
 class _Period> inline
 xtime _To_xtime(const chrono::duration<_Rep, _Period>& _Rel_time)
 {
 xtime _Xt;
 if (_Rel_time <= chrono::duration<_Rep, _Period>::zero())
  {
  _Xt.sec = 0;
  _Xt.nsec = 0;
  }
 else
  {
  chrono::nanoseconds _T0 =
   chrono::system_clock::now().time_since_epoch();
  _T0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);
  _Xt.sec = chrono::duration_cast<chrono::seconds>(_T0).count();
  _T0 -= chrono::seconds(_Xt.sec);
  _Xt.nsec = (long)_T0.count();
  }
 return (_Xt);
 }







#pragma warning(push)
#pragma warning(disable: 4455)

inline namespace literals {
inline namespace chrono_literals {
inline constexpr chrono::hours operator "" h(unsigned long long _Val)
 {
 return (chrono::hours(_Val));
 }

inline constexpr chrono::duration<double, ratio<3600> > operator "" h(
 long double _Val)
 {
 return (chrono::duration<double, ratio<3600> >(_Val));
 }

inline constexpr chrono::minutes (operator "" min)(unsigned long long _Val)
 {
 return (chrono::minutes(_Val));
 }

inline constexpr chrono::duration<double, ratio<60> > (operator "" min)(
 long double _Val)
 {
 return (chrono::duration<double, ratio<60> >(_Val));
 }

inline constexpr chrono::seconds operator "" s(unsigned long long _Val)
 {
 return (chrono::seconds(_Val));
 }

inline constexpr chrono::duration<double> operator "" s(long double _Val)
 {
 return (chrono::duration<double>(_Val));
 }

inline constexpr chrono::milliseconds operator "" ms(unsigned long long _Val)
 {
 return (chrono::milliseconds(_Val));
 }

inline constexpr chrono::duration<double, milli> operator "" ms(
 long double _Val)
 {
 return (chrono::duration<double, milli>(_Val));
 }

inline constexpr chrono::microseconds operator "" us(unsigned long long _Val)
 {
 return (chrono::microseconds(_Val));
 }

inline constexpr chrono::duration<double, micro> operator "" us(
 long double _Val)
 {
 return (chrono::duration<double, micro>(_Val));
 }

inline constexpr chrono::nanoseconds operator "" ns(unsigned long long _Val)
 {
 return (chrono::nanoseconds(_Val));
 }

inline constexpr chrono::duration<double, nano> operator "" ns(
 long double _Val)
 {
 return (chrono::duration<double, nano>(_Val));
 }
}
}

namespace chrono {
 using namespace literals::chrono_literals;
}

#pragma warning(pop)





}

#pragma warning(pop)
#pragma pack(pop)
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\xmemory" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<class _Ty> inline
 pair<_Ty *, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept
 {
 if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty))
  {
  for (; 0 < _Count; _Count /= 2)
   {
   _Ty * _Pbuf = static_cast<_Ty *>(::operator new(static_cast<size_t>(_Count) * sizeof(_Ty), nothrow));
   if (_Pbuf)
    {
    return {_Pbuf, _Count};
    }
   }
  }

 return {nullptr_t{}, 0};
 }


template<class _Ty> inline
 void return_temporary_buffer(_Ty *_Pbuf)
 {
 ::operator delete(_Pbuf);
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_move_unchecked1(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _General_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  {
  _Construct_in_place(*_Dest, ::std:: move(*_First));
  }

 } catch (...) {
 _Destroy_range(_Next, _Dest);
 throw;
 }

 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_move_unchecked1(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_move_unchecked(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Uninitialized_move_unchecked1(_First, _Last, _Dest, _Ptr_move_cat(_First, _Dest)));
 }



template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  {
  _Al.construct(_Unfancy(_Dest), *_First);
  }

 } catch (...) {
 _Destroy_range(_Next, _Dest, _Al);
 throw;
 }

 return (_Dest);
 }

template<class _Ty1,
 class _Ty2,
 class _Alloc> inline
 _Ty2 *_Uninitialized_copy_al_unchecked(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al)
 {


 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked(_Dest);
 return (_Rechecked(_Dest,
  _Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
   _Ptr_copy_cat(_UFirst, _UDest),
   _Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>())));
 }


template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  {
  _Al.construct(_Unfancy(_Dest), ::std:: move(*_First));
  }

 } catch (...) {
 _Destroy_range(_Next, _Dest, _Al);
 throw;
 }

 return (_Dest);
 }

template<class _Ty1,
 class _Ty2,
 class _Alloc> inline
 _Ty2 *_Uninitialized_move_al_unchecked(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al)
 {


 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked(_Dest);
 return (_Rechecked(_Dest,
  _Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
   _Ptr_move_cat(_UFirst, _UDest),
   _Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(::std:: move(*_UFirst))>())));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 _FwdIt _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
  _Wrap_alloc<_Alloc>& _Al, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, (void)++_First)
  {
  _Al.construct(_Unfancy(_First), _Val);
  }

 } catch (...) {
 _Destroy_range(_Next, _First, _Al);
 throw;
 }

 return (_First);
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 _FwdIt _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
  _Wrap_alloc<_Alloc>&, true_type)
 {
 :: memset(_First, _Val, _Count);
 return (_First + _Count);
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 _FwdIt _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Iter_value_t<_FwdIt>& _Val, _Wrap_alloc<_Alloc>& _Al)
 {
 return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,
  _Conjunction_t<decltype(_Fill_memset_is_safe(_First, _Val)),
   _Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>()));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 _FwdIt _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, (void)++_First)
  {
  _Al.construct(_Unfancy(_First));
  }

 } catch (...) {
 _Destroy_range(_Next, _First, _Al);
 throw;
 }

 return (_First);
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 _FwdIt _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>&, true_type)
 {
 :: memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));
 return (_First + _Count);
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 _FwdIt _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al)
 {
 typedef _Iter_value_t<_FwdIt> _Ty;
 return (_Uninitialized_default_fill_n1(_First, _Count, _Al,
  _Conjunction_t<
   is_pointer<_FwdIt>,
   is_scalar<_Ty>,
   negation<is_volatile<_Ty>>,
   negation<is_member_pointer<_Ty>>,
   _Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 2 3





#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _General_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, (void)++_First)
  {
  _Construct_in_place(*_Dest, *_First);
  }

 } catch (...) {
 _Destroy_range(_Next, _Dest);
 throw;
 }

 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
 {
 return (_Copy_memmove(_First, _Last, _Dest));
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
                            ;
 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 const auto _UDest = _Unchecked_n(_Dest, _Idl_distance(_UFirst, _ULast));
 return (_Rechecked(_Dest,
  _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest))));
 }
# 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _General_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  {
  _Construct_in_place(*_Dest, *_First);
  }

 } catch (...) {
 _Destroy_range(_Next, _Dest);
 throw;
 }

 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
 {
 if (0 < _Count)
  {
  return (_Copy_memmove(_First, _First + _Count, _Dest));
  }

 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n_unchecked(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_n_unchecked1(_First, _Count,
  _Dest, _Ptr_copy_cat(_First, _Dest)));
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {

 struct _Unchecked_iterators { static void _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
 return (_Rechecked(_Dest,
  _Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
 }
# 176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
template<class _FwdIt,
 class _Tval> inline
 void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; _First != _Last; ++_First)
  {
  _Construct_in_place(*_First, _Val);
  }

 } catch (...) {
 _Destroy_range(_Next, _First);
 throw;
 }
 }

template<class _FwdIt,
 class _Tval> inline
 void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, true_type)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Tval> inline
 void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
                            ;
 const auto _UFirst = _Unchecked(_First);
 const auto _ULast = _Unchecked(_Last);
 _Uninitialized_fill_unchecked(_UFirst, _ULast, _Val, _Fill_memset_is_safe(_UFirst, _Val));
 }



template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val, false_type)
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, (void)++_First)
  {
  _Construct_in_place(*_First, _Val);
  }

 } catch (...) {
 _Destroy_range(_Next, _First);
 throw;
 }

 return (_First);
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val, true_type)
 {
 if (0 < _Count)
  {
  :: memset(_First, _Val, _Count);
  return (_First + _Count);
  }

 return (_First);
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval& _Val)
 {
 const auto _UFirst = _Unchecked_n(_First, _Count);
 return (_Rechecked(_First,
  _Uninitialized_fill_n_unchecked(_UFirst, _Count, _Val, _Fill_memset_is_safe(_UFirst, _Val))));
 }



template<class _OutIt,
 class _Ty>
 class raw_storage_iterator
  : public _Outit
 {
public:
 explicit raw_storage_iterator(_OutIt _First)
  : _Next(_First)
  {
  }

 raw_storage_iterator& operator*()
  {
  return (*this);
  }

 raw_storage_iterator& operator=(const _Ty& _Val)
  {
  _Construct_in_place(*_Next, _Val);
  return (*this);
  }

 raw_storage_iterator& operator=(_Ty&& _Val)
  {
  _Construct_in_place(*_Next, ::std:: move(_Val));
  return (*this);
  }

 raw_storage_iterator& operator++()
  {
  ++_Next;
  return (*this);
  }

 raw_storage_iterator operator++(int)
  {
  raw_storage_iterator _Ans = *this;
  ++_Next;
  return (_Ans);
  }

 _OutIt base() const
  {
  return (_Next);
  }

private:
 _OutIt _Next;
 };
# 448 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
struct _No_bad_weak_ptr {};

template<class _Ty>
 struct default_delete;

template<class _Ty,
 class _Dx = default_delete<_Ty> >
 class unique_ptr;


class bad_weak_ptr
 : public exception
 {
public:
 bad_weak_ptr() noexcept
  {
  }

 virtual const char * what() const throw()
  {
  return ("bad_weak_ptr");
  }
 };


class _Ref_count_base
 {
private:
 virtual void _Destroy() noexcept = 0;
 virtual void _Delete_this() noexcept = 0;

private:
 _Atomic_counter_t _Uses;
 _Atomic_counter_t _Weaks;

protected:
 _Ref_count_base()
  : _Uses(1), _Weaks(1)
  {
  }

public:
 virtual ~_Ref_count_base() noexcept
  {
  }

 bool _Incref_nz()
  {
  for (; ; )
   {

   _Atomic_integral_t _Count =
    static_cast<volatile _Atomic_counter_t&>(_Uses);

   if (_Count == 0)
    return (false);

   if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
     reinterpret_cast<volatile long *>(&_Uses),
     _Count + 1, _Count)) == _Count)
    return (true);
# 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
   }
  }

 void _Incref()
  {
  _InterlockedIncrement(reinterpret_cast<volatile long *>(&_Uses));
  }

 void _Incwref()
  {
  _InterlockedIncrement(reinterpret_cast<volatile long *>(&_Weaks));
  }

 void _Decref()
  {
  if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Uses)) == 0)
   {
   _Destroy();
   _Decwref();
   }
  }

 void _Decwref()
  {
  if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Weaks)) == 0)
   _Delete_this();
  }

 long _Use_count() const noexcept
  {
  return (_Get_atomic_count(_Uses));
  }

 bool _Expired() const noexcept
  {
  return (_Use_count() == 0);
  }

 virtual void *_Get_deleter(const type_info&) const noexcept
  {
  return (0);
  }
 };


template<class _Ty>
 class _Ref_count
 : public _Ref_count_base
 {
public:
 _Ref_count(_Ty *_Px)
  : _Ref_count_base(), _Ptr(_Px)
  {
  }

private:
 virtual void _Destroy() noexcept
  {
  delete _Ptr;
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 _Ty * _Ptr;
 };


template<class _Ty,
 class _Dx>
 class _Ref_count_del
 : public _Ref_count_base
 {
public:
 _Ref_count_del(_Ty *_Px, _Dx _Dt)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt, _Px)
  {
  }

 virtual void *_Get_deleter(const type_info& _Typeid) const noexcept
  {
  return ((void *)(_Typeid == typeid(_Dx)
   ? ::std:: addressof(_Mypair._Get_first()) : 0));
  }

private:
 virtual void _Destroy() noexcept
  {
  _Mypair._Get_first()(_Mypair._Get_second());
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 _Compressed_pair<_Dx, _Ty *> _Mypair;
 };


template<class _Ty,
 class _Dx,
 class _Alloc>
 class _Ref_count_del_alloc
 : public _Ref_count_base
 {
public:
 typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myt;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;

 _Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, const _Alloc& _Ax)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt,
   _One_then_variadic_args_t(), _Ax, _Px)
  {
  }

 virtual void *_Get_deleter(const type_info& _Typeid) const noexcept
  {
  return ((void *)(_Typeid == typeid(_Dx)
   ? ::std:: addressof(_Mypair._Get_first()) : 0));
  }

private:
 virtual void _Destroy() noexcept
  {
  _Mypair._Get_first()(_Mypair._Get_second()._Get_second());
  }

 virtual void _Delete_this() noexcept
  {
  _Myalty _Al = _Mypair._Get_second()._Get_first();
  _Al.destroy(this);
  _Al.deallocate(_Al.address(*this), 1);
  }

 _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Ty *> > _Mypair;
 };


template<class _Ty>
 class weak_ptr;
template<class _Ty>
 class shared_ptr;
template<class _Ty>
 class enable_shared_from_this;

template<class _Ty1,
 class _Ty2>
 void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
  _Ref_count_base *);

template<class _Ty>
 inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
  typename _Ty::_EStype * = 0)
 {
 if (_Ptr)
  _Do_enable(_Ptr,
   (enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
 }

inline void _Enable_shared(const volatile void *, const volatile void *)
 {
 }


template<class _Ty>
 class _Ptr_base
 {
public:
 typedef _Ptr_base<_Ty> _Myt;
 typedef _Ty element_type;

 constexpr _Ptr_base() noexcept
  : _Ptr(0), _Rep(0)
  {
  }

 _Ptr_base(_Myt&& _Right)
  : _Ptr(_Right._Ptr), _Rep(_Right._Rep)
  {
  _Right._Ptr = 0;
  _Right._Rep = 0;
  }

 template<class _Ty2>
  _Ptr_base(_Ptr_base<_Ty2>&& _Right)
  : _Ptr(_Right._Ptr), _Rep(_Right._Rep)
  {
  _Right._Ptr = 0;
  _Right._Rep = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  _Assign_rv(::std:: move(_Right));
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Swap(_Right);
  }

 long use_count() const noexcept
  {
  return (_Rep ? _Rep->_Use_count() : 0);
  }

 void _Swap(_Ptr_base& _Right) noexcept
  {
  ::std:: swap(_Rep, _Right._Rep);
  ::std:: swap(_Ptr, _Right._Ptr);
  }

 template<class _Ty2>
  bool owner_before(const _Ptr_base<_Ty2>& _Right) const
  {
  return (_Rep < _Right._Rep);
  }

 void *_Get_deleter(const type_info& _Typeid) const noexcept
  {
  return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
  }

 _Ty *_Get() const noexcept
  {
  return (_Ptr);
  }

 bool _Expired() const noexcept
  {
  return (!_Rep || _Rep->_Expired());
  }

 void _Decref()
  {
  if (_Rep != 0)
   _Rep->_Decref();
  }

 void _Reset()
  {
  _Reset(0, 0);
  }

 template<class _Ty2>
  void _Reset(const _Ptr_base<_Ty2>& _Other)
  {
  _Reset(_Other._Ptr, _Other._Rep);
  }

 template<class _Ty2>
  bool _Reset_weak(const _Ptr_base<_Ty2>& _Other)
  {
  return (_Reset_weak(_Other._Ptr, _Other._Rep));
  }
# 792 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
 template<class _Ty2>
  void _Reset(_Ty *_Other_ptr, const _Ptr_base<_Ty2>& _Other)
  {
  _Reset(_Other_ptr, _Other._Rep);
  }

 void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Other_rep)
   _Other_rep->_Incref();
  _Reset0(_Other_ptr, _Other_rep);
  }

 bool _Reset_weak(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {

  if (_Other_rep && _Other_rep->_Incref_nz())
   {
   _Reset0(_Other_ptr, _Other_rep);
   return (true);
   }

  return (false);
  }

 void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Rep != 0)
   _Rep->_Decref();
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

 void _Decwref()
  {
  if (_Rep != 0)
   _Rep->_Decwref();
  }

 void _Resetw()
  {
  _Resetw((_Ty *)0, 0);
  }

 template<class _Ty2>
  void _Resetw(const _Ptr_base<_Ty2>& _Other)
  {
  _Resetw(_Other._Ptr, _Other._Rep);
  }

 template<class _Ty2>
  void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Other_rep)
   _Other_rep->_Incwref();
  if (_Rep != 0)
   _Rep->_Decwref();
  _Rep = _Other_rep;
  _Ptr = const_cast<remove_cv_t<_Ty2> *>(_Other_ptr);
  }

private:
 _Ty *_Ptr;
 _Ref_count_base *_Rep;
 template<class _Ty0>
  friend class _Ptr_base;
 };


template<class _Ty>
 class shared_ptr
  : public _Ptr_base<_Ty>
 {
public:
 typedef shared_ptr<_Ty> _Myt;
 typedef _Ptr_base<_Ty> _Mybase;


 typedef weak_ptr<_Ty> weak_type;


 constexpr shared_ptr() noexcept
  {
  }

 template<class _Ux>
  explicit shared_ptr(_Ux *_Px)
  {
  _Resetp(_Px);
  }

 template<class _Ux,
  class _Dx>
  shared_ptr(_Ux *_Px, _Dx _Dt)
  {
  _Resetp(_Px, _Dt);
  }

 constexpr shared_ptr(nullptr_t) noexcept
  {
  }

 template<class _Dx>
  shared_ptr(nullptr_t, _Dx _Dt)
  {
  _Resetp((_Ty *)0, _Dt);
  }

 template<class _Dx,
  class _Alloc>
  shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
  {
  _Resetp((_Ty *)0, _Dt, _Ax);
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  _Resetp(_Px, _Dt, _Ax);
  }

 template<class _Ty2>
  shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px) noexcept
  {
  this->_Reset(_Px, _Right);
  }

 shared_ptr(const _Myt& _Other) noexcept
  {
  this->_Reset(_Other);
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value>>
  shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept
  {
  this->_Reset(_Other);
  }

 template<class _Ty2>
  explicit shared_ptr(const weak_ptr<_Ty2>& _Other)
  {
  if (!this->_Reset_weak(_Other))
   {
   throw bad_weak_ptr();
   }
  }

 shared_ptr(_No_bad_weak_ptr, const weak_ptr<_Ty>& _Other) noexcept
  {
  (void)this->_Reset_weak(_Other);
  }
# 955 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
 shared_ptr(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value>>
  shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }


 template<class _Ux,
  class _Dx,
  class = enable_if_t<is_convertible<
   typename unique_ptr<_Ux, _Dx>::pointer, _Ty *>::value>>
  shared_ptr(unique_ptr<_Ux, _Dx>&& _Right)
  {
  _Resetp(_Right.release(), _Right.get_deleter());
  }

 template<class _Ux,
  class _Dx>
  _Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(shared_ptr<_Ty2>&& _Right) noexcept
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 ~shared_ptr() noexcept
  {
  this->_Decref();
  }

 _Myt& operator=(const _Myt& _Right) noexcept
  {
  shared_ptr(_Right).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(const shared_ptr<_Ty2>& _Right) noexcept
  {
  shared_ptr(_Right).swap(*this);
  return (*this);
  }
# 1025 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
 void reset() noexcept
  {
  shared_ptr().swap(*this);
  }

 template<class _Ux>
  void reset(_Ux *_Px)
  {
  shared_ptr(_Px).swap(*this);
  }

 template<class _Ux,
  class _Dx>
  void reset(_Ux *_Px, _Dx _Dt)
  {
  shared_ptr(_Px, _Dt).swap(*this);
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  shared_ptr(_Px, _Dt, _Ax).swap(*this);
  }

 void swap(_Myt& _Other) noexcept
  {
  this->_Swap(_Other);
  }

 _Ty *get() const noexcept
  {
  return (this->_Get());
  }

 typename add_lvalue_reference<_Ty>::type operator*() const noexcept
  {
  return (*this->_Get());
  }

 _Ty *operator->() const noexcept
  {
  return (this->_Get());
  }

 bool unique() const noexcept
  {
  return (this->use_count() == 1);
  }

 explicit operator bool() const noexcept
  {
  return (this->_Get() != 0);
  }

private:
 template<class _Ux>
  void _Resetp(_Ux *_Px)
  {
  try {
  _Resetp0(_Px, new _Ref_count<_Ux>(_Px));
  } catch (...) {
  delete _Px;
  throw;
  }
  }

 template<class _Ux,
  class _Dx>
  void _Resetp(_Ux *_Px, _Dx _Dt)
  {
  try {
  _Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
  } catch (...) {
  _Dt(_Px);
  throw;
  }
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
  typedef _Wrap_alloc<_Alloc> _Alref0;
  typename _Alref0::template rebind<_Refd>::other _Alref(_Ax);

  try {
  _Refd *_Pref = _Unfancy(_Alref.allocate(1));
  _Alref.construct(_Pref, _Px, _Dt, _Ax);
  _Resetp0(_Px, _Pref);
  } catch (...) {
  _Dt(_Px);
  throw;
  }
  }

public:
 template<class _Ux>
  void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
  {
  this->_Reset0(_Px, _Rx);
  _Enable_shared(_Px, _Rx);
  }
 };

template<class _Ty1,
 class _Ty2>
 bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (_Left.get() == _Right.get());
 }

template<class _Ty1,
 class _Ty2>
 bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2>
 bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (less<decltype(_Always_false<_Ty1>::value
  ? _Left.get() : _Right.get())>()(
   _Left.get(), _Right.get()));
 }

template<class _Ty1,
 class _Ty2>
 bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty1,
 class _Ty2>
 bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2>
 bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Ty>
 bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
 {
 return (_Left.get() == nullptr_t{});
 }

template<class _Ty>
 bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
 {
 return (nullptr_t{} == _Right.get());
 }

template<class _Ty>
 bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
 {
 return (!(_Left == nullptr_t{}));
 }

template<class _Ty>
 bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(nullptr_t{} == _Right));
 }

template<class _Ty>
 bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
 {
 return (less<_Ty *>()(_Left.get(), nullptr_t{}));
 }

template<class _Ty>
 bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
 {
 return (less<_Ty *>()(nullptr_t{}, _Right.get()));
 }

template<class _Ty>
 bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
 {
 return (!(_Left < nullptr_t{}));
 }

template<class _Ty>
 bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(nullptr_t{} < _Right));
 }

template<class _Ty>
 bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
 {
 return (nullptr_t{} < _Left);
 }

template<class _Ty>
 bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
 {
 return (_Right < nullptr_t{});
 }

template<class _Ty>
 bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
 {
 return (!(nullptr_t{} < _Left));
 }

template<class _Ty>
 bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Right < nullptr_t{}));
 }

template<class _Elem,
 class _Traits,
 class _Ty>
 basic_ostream<_Elem, _Traits>&
 operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px)
 {
 return (_Out << _Px.get());
 }

template<class _Ty>
 void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = static_cast<_Elem1 *>(_Other.get());
 return (shared_ptr<_Ty1>(_Other, _Ptr));
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = const_cast<_Elem1 *>(_Other.get());
 return (shared_ptr<_Ty1>(_Other, _Ptr));
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = dynamic_cast<_Elem1 *>(_Other.get());
 if (_Ptr)
  return (shared_ptr<_Ty1>(_Other, _Ptr));
 else
  return (shared_ptr<_Ty1>());
 }

template<class _Dx,
 class _Ty>
 _Dx *get_deleter(const shared_ptr<_Ty>& _Sx) noexcept
 {
 return ((_Dx *)_Sx._Get_deleter(typeid(_Dx)));
 }


template<class _Ty>
 class _Ref_count_obj
 : public _Ref_count_base
 {
public:
 template<class... _Types>
  _Ref_count_obj(_Types&&... _Args)
  : _Ref_count_base()
  {
  ::new ((void *)&_Storage) _Ty(::std:: forward<_Types>(_Args)...);
  }


 _Ty *_Getptr() const
  {
  return ((_Ty *)&_Storage);
  }

private:
 virtual void _Destroy() noexcept
  {
  _Getptr()->~_Ty();
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 typename aligned_union<1, _Ty>::type _Storage;
 };


template<class _Ty,
 class _Alloc>
 class _Ref_count_obj_alloc
 : public _Ref_count_base
 {
public:
 typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Myt;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;
 typedef typename aligned_union<1, _Ty>::type _Mystoragety;

 template<class... _Types>
  _Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg)
  {
  ::new ((void *)_Getptr()) _Ty(::std:: forward<_Types>(_Args)...);
  }


 _Ty *_Getptr() const
  {
  return ((_Ty *)&_Mypair._Get_second());
  }

private:
 virtual void _Destroy() noexcept
  {
  _Getptr()->~_Ty();
  }

 virtual void _Delete_this() noexcept
  {
  _Myalty _Al = _Mypair._Get_first();
  _Al.destroy(this);
  _Al.deallocate(_Al.address(*this), 1);
  }

 _Compressed_pair<_Myalty, _Mystoragety> _Mypair;
 };


template<class _Ty,
 class... _Types> inline
  shared_ptr<_Ty> make_shared(_Types&&... _Args)
 {
 _Ref_count_obj<_Ty> *_Rx =
  new _Ref_count_obj<_Ty>(::std:: forward<_Types>(_Args)...);

 shared_ptr<_Ty> _Ret;
 _Ret._Resetp0(_Rx->_Getptr(), _Rx);
 return (_Ret);
 }


template<class _Ty,
 class _Alloc,
 class... _Types> inline
 shared_ptr<_Ty> allocate_shared(
  const _Alloc& _Al_arg, _Types&&... _Args)
 {
 typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Refoa;
 typedef _Wrap_alloc<_Alloc> _Alref0;
 typename _Alref0::template rebind<_Refoa>::other _Alref(_Al_arg);

 const auto _Rx = _Alref.allocate(1);

 try {
  _Alref.construct(_Unfancy(_Rx), _Al_arg, ::std:: forward<_Types>(_Args)...);
 } catch (...) {
  _Alref.deallocate(_Rx, 1);
 throw;
 }

 shared_ptr<_Ty> _Ret;
 _Ret._Resetp0(_Rx->_Getptr(), _Unfancy(_Rx));
 return (_Ret);
 }



template<class _Ty>
 class weak_ptr
  : public _Ptr_base<_Ty>
 {
public:
 typedef weak_ptr<_Ty> _Myt;
 typedef _Ptr_base<_Ty> _Mybase;

 constexpr weak_ptr() noexcept
  {
  }

 weak_ptr(const weak_ptr& _Other) noexcept
  {
  this->_Resetw(_Other);
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept
  {
  this->_Resetw(_Other);
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept
  {
  this->_Resetw(_Other.lock());
  }

 weak_ptr(_Myt&& _Other) noexcept
  : _Mybase(::std:: move(_Other))
  {
  }

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept
  {
  this->_Resetw(_Other.lock());
  _Other.reset();
  }

 ~weak_ptr() noexcept
  {
  this->_Decwref();
  }

 weak_ptr& operator=(const weak_ptr& _Right) noexcept
  {
  this->_Resetw(_Right);
  return (*this);
  }

 template<class _Ty2>
  weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept
  {
  this->_Resetw(_Right.lock());
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  weak_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(weak_ptr<_Ty2>&& _Right) noexcept
  {
  weak_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
  {
  this->_Resetw(_Right);
  return (*this);
  }

 void reset() noexcept
  {
  this->_Resetw();
  }

 void swap(weak_ptr& _Other) noexcept
  {
  this->_Swap(_Other);
  }

 bool expired() const noexcept
  {
  return (this->_Expired());
  }

 shared_ptr<_Ty> lock() const noexcept
  {
  return (shared_ptr<_Ty>(_No_bad_weak_ptr{}, *this));
  }
 };

template<class _Ty>
 void swap(weak_ptr<_Ty>& _W1, weak_ptr<_Ty>& _W2) noexcept
 {
 _W1.swap(_W2);
 }


template<class _Ty>
 class enable_shared_from_this
 {
public:
 typedef _Ty _EStype;

 shared_ptr<_Ty> shared_from_this()
  {
  return (shared_ptr<_Ty>(_Wptr));
  }

 shared_ptr<const _Ty> shared_from_this() const
  {
  return (shared_ptr<const _Ty>(_Wptr));
  }

protected:
 constexpr enable_shared_from_this() noexcept
  {
  }

 enable_shared_from_this(const enable_shared_from_this&) noexcept
  {
  }

 enable_shared_from_this&
  operator=(const enable_shared_from_this&) noexcept
  {
  return (*this);
  }

 ~enable_shared_from_this() noexcept
  {
  }

private:
 template<class _Ty1,
  class _Ty2>
  friend void _Do_enable(
   _Ty1 *,
   enable_shared_from_this<_Ty2>*,
   _Ref_count_base *);

 weak_ptr<_Ty> _Wptr;
 };

template<class _Ty1,
 class _Ty2>
 inline void _Do_enable(
  _Ty1 *_Ptr,
  enable_shared_from_this<_Ty2> *_Es,
  _Ref_count_base *_Refptr)
 {
 _Es->_Wptr._Resetw(_Ptr, _Refptr);
 }
}

namespace std {



template<class _Ty>
 struct default_delete
 {
 constexpr default_delete() noexcept = default;

 template<class _Ty2,
  class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
   void>::type>
  default_delete(const default_delete<_Ty2>&) noexcept
  {
  }

 void operator()(_Ty *_Ptr) const noexcept
  {
  static_assert(0 < sizeof (_Ty),
   "can't delete an incomplete type");
  delete _Ptr;
  }
 };

template<class _Ty>
 struct default_delete<_Ty[]>
 {
 constexpr default_delete() noexcept = default;

 template<class _Uty,
  class = typename enable_if<is_convertible<_Uty(*)[], _Ty(*)[]>::value,
   void>::type>
  default_delete(const default_delete<_Uty[]>&) noexcept
  {
  }

 template<class _Uty,
  class = typename enable_if<is_convertible<_Uty(*)[], _Ty(*)[]>::value,
   void>::type>
  void operator()(_Uty *_Ptr) const noexcept
  {
  static_assert(0 < sizeof (_Uty),
   "can't delete an incomplete type");
  delete[] _Ptr;
  }
 };


template<class _Ty,
 class _Dx_noref,
 class = void>
 struct _Get_deleter_pointer_type
 {
 typedef _Ty * type;
 };

template<class _Ty,
 class _Dx_noref>
 struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>>
 {
 typedef typename _Dx_noref::pointer type;
 };


template<class _Ty,
 class _Dx>
 class _Unique_ptr_base
 {
public:
 typedef remove_reference_t<_Dx> _Dx_noref;
 typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

 template<class _Ptr2,
  class _Dx2>
  _Unique_ptr_base(_Ptr2 _Ptr, _Dx2&& _Dt)
  : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx2>(_Dt), _Ptr)
  {
  }

 template<class _Ptr2>
  constexpr _Unique_ptr_base(_Ptr2 _Ptr)
  : _Mypair(_Zero_then_variadic_args_t(), _Ptr)
  {
  }

 _Dx& get_deleter() noexcept
  {
  return (_Mypair._Get_first());
  }

 const _Dx& get_deleter() const noexcept
  {
  return (_Mypair._Get_first());
  }

 pointer& _Myptr() noexcept
  {
  return (_Mypair._Get_second());
  }

 const pointer& _Myptr() const noexcept
  {
  return (_Mypair._Get_second());
  }

 _Compressed_pair<_Dx, pointer> _Mypair;
 };


template<class _Ty,
 class _Dx>
 class unique_ptr
  : public _Unique_ptr_base<_Ty, _Dx>
 {
public:
 typedef unique_ptr<_Ty, _Dx> _Myt;
 typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
 typedef typename _Mybase::pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase::get_deleter;

 constexpr unique_ptr() noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 constexpr unique_ptr(nullptr_t) noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 _Myt& operator=(nullptr_t) noexcept
  {
  reset();
  return (*this);
  }

 explicit unique_ptr(pointer _Ptr) noexcept
  : _Mybase(_Ptr)
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 unique_ptr(pointer _Ptr,
  typename _If<is_reference<_Dx>::value, _Dx,
   const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
  : _Mybase(_Ptr, _Dt)
  {
  }

 unique_ptr(pointer _Ptr,
  typename remove_reference<_Dx>::type&& _Dt) noexcept
  : _Mybase(_Ptr, ::std:: move(_Dt))
  {
  static_assert(!is_reference<_Dx>::value,
   "unique_ptr constructed with reference to rvalue deleter");
  }

 unique_ptr(unique_ptr&& _Right) noexcept
  : _Mybase(_Right.release(),
   ::std:: forward<_Dx>(_Right.get_deleter()))
  {
  }

 template<class _Ty2,
  class _Dx2,
  class = typename enable_if<!is_array<_Ty2>::value
   && is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
    pointer>::value
   && (is_reference<_Dx>::value
    ? is_same<_Dx2, _Dx>::value
    : is_convertible<_Dx2, _Dx>::value),
   void>::type>
  unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
   : _Mybase(_Right.release(),
    ::std:: forward<_Dx2>(_Right.get_deleter()))
  {
  }
# 1785 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
 template<class _Ty2,
  class _Dx2>
  typename enable_if<!is_array<_Ty2>::value
   && is_assignable<_Dx&, _Dx2&&>::value
   && is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
    pointer>::value,
   _Myt&>::type
  operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
  {
  reset(_Right.release());
  this->get_deleter() = ::std:: forward<_Dx2>(_Right.get_deleter());
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  if (this != ::std:: addressof(_Right))
   {
   reset(_Right.release());
   this->get_deleter() = ::std:: forward<_Dx>(_Right.get_deleter());
   }
  return (*this);
  }

 void swap(_Myt& _Right) noexcept
  {
  _Swap_adl(this->_Myptr(), _Right._Myptr());
  _Swap_adl(this->get_deleter(),
   _Right.get_deleter());
  }

 ~unique_ptr() noexcept
  {
  if (get() != pointer())
   this->get_deleter()(get());
  }

 typename add_lvalue_reference<_Ty>::type operator*() const
  {
  return (*get());
  }

 pointer operator->() const noexcept
  {
  return (this->_Myptr());
  }

 pointer get() const noexcept
  {
  return (this->_Myptr());
  }

 explicit operator bool() const noexcept
  {
  return (get() != pointer());
  }

 pointer release() noexcept
  {
  pointer _Ans = get();
  this->_Myptr() = pointer();
  return (_Ans);
  }

 void reset(pointer _Ptr = pointer()) noexcept
  {
  pointer _Old = get();
  this->_Myptr() = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 unique_ptr(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };


template<class _Ty,
 class _Dx>
 class unique_ptr<_Ty[], _Dx>
  : public _Unique_ptr_base<_Ty, _Dx>
 {
public:
 typedef unique_ptr<_Ty[], _Dx> _Myt;
 typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
 typedef typename _Mybase::pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase::get_deleter;

 constexpr unique_ptr() noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 template<class _Uty,
  class _Is_nullptr = is_same<_Uty, nullptr_t>>
  using _Enable_ctor_reset = enable_if_t<
   is_same<_Uty, pointer>::value
   || _Is_nullptr::value
   || (is_same<pointer, element_type *>::value
   && is_pointer<_Uty>::value
   && is_convertible<
    remove_pointer_t<_Uty>(*)[],
    element_type(*)[]
   >::value)>;

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 explicit unique_ptr(_Uty _Ptr) noexcept
  : _Mybase(_Ptr)
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 unique_ptr(_Uty _Ptr,
  typename _If<is_reference<_Dx>::value, _Dx,
   const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
  : _Mybase(_Ptr, _Dt)
  {
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 unique_ptr(_Uty _Ptr,
  typename remove_reference<_Dx>::type&& _Dt) noexcept
  : _Mybase(_Ptr, ::std:: move(_Dt))
  {
  static_assert(!is_reference<_Dx>::value,
   "unique_ptr constructed with reference to rvalue deleter");
  }

 unique_ptr(unique_ptr&& _Right) noexcept
  : _Mybase(_Right.release(),
   ::std:: forward<_Dx>(_Right.get_deleter()))
  {
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  if (this != ::std:: addressof(_Right))
   {
   reset(_Right.release());
   this->get_deleter() = ::std:: move(_Right.get_deleter());
   }
  return (*this);
  }

 template<class _Uty,
  class _Ex,
  bool _More,
  class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
  class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
  using _Enable_conversion = enable_if_t<
   is_array<_Uty>::value
   && is_same<pointer, element_type *>::value
   && is_same<_UP_pointer, _UP_element_type *>::value
   && is_convertible<_UP_element_type(*)[], element_type(*)[]>::value
   && _More>;

 template<class _Uty,
  class _Ex,
  class = _Enable_conversion<_Uty, _Ex,
   is_reference<_Dx>::value
   ? is_same<_Ex, _Dx>::value
   : is_convertible<_Ex, _Dx>::value> >
  unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
   : _Mybase(_Right.release(),
    ::std:: forward<_Ex>(_Right.get_deleter()))
  {
  }

 template<class _Uty,
  class _Ex,
  class = _Enable_conversion<_Uty, _Ex,
   is_assignable<_Dx&, _Ex&&>::value> >
  _Myt& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept
  {
  reset(_Right.release());
  this->get_deleter() = ::std:: forward<_Ex>(_Right.get_deleter());
  return (*this);
  }

 constexpr unique_ptr(nullptr_t) noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 _Myt& operator=(nullptr_t) noexcept
  {
  reset();
  return (*this);
  }

 void reset(nullptr_t = nullptr_t{}) noexcept
  {
  reset(pointer());
  }

 void swap(_Myt& _Right) noexcept
  {
  _Swap_adl(this->_Myptr(), _Right._Myptr());
  _Swap_adl(this->get_deleter(), _Right.get_deleter());
  }

 ~unique_ptr() noexcept
  {
  _Delete();
  }

 _Ty& operator[](size_t _Idx) const
  {
  return (get()[_Idx]);
  }

 pointer get() const noexcept
  {
  return (this->_Myptr());
  }

 explicit operator bool() const noexcept
  {
  return (get() != pointer());
  }

 pointer release() noexcept
  {
  pointer _Ans = get();
  this->_Myptr() = pointer();
  return (_Ans);
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty, false_type> >
 void reset(_Uty _Ptr) noexcept
  {
  pointer _Old = get();
  this->_Myptr() = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 unique_ptr(const _Myt&) = delete;

 _Myt& operator=(const _Myt&) = delete;

private:
 void _Delete()
  {
  if (get() != pointer())
   this->get_deleter()(get());
  }
 };



template<class _Ty,
 class... _Types> inline
 typename enable_if<!is_array<_Ty>::value,
  unique_ptr<_Ty> >::type make_unique(_Types&&... _Args)
 {
 return (unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...)));
 }

template<class _Ty> inline
 typename enable_if<is_array<_Ty>::value && extent<_Ty>::value == 0,
  unique_ptr<_Ty> >::type make_unique(size_t _Size)
 {
 typedef typename remove_extent<_Ty>::type _Elem;
 return (unique_ptr<_Ty>(new _Elem[_Size]()));
 }

template<class _Ty,
 class... _Types>
 typename enable_if<extent<_Ty>::value != 0,
  void>::type make_unique(_Types&&...) = delete;


template<class _Ty,
 class _Dx,
 class = enable_if_t<_Is_swappable<_Dx>::value>>
 void swap(unique_ptr<_Ty, _Dx>& _Left,
  unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (_Left.get() == _Right.get());
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
 typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
 typedef typename common_type<_Ptr1, _Ptr2>::type _Common;
 return (less<_Common>()(_Left.get(), _Right.get()));

 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Dx>
 bool operator==(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t) noexcept
 {
 return (!_Left);
 }

template<class _Ty,
 class _Dx>
 bool operator==(nullptr_t,
  const unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 return (!_Right);
 }

template<class _Ty,
 class _Dx>
 bool operator!=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator!=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator<(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
 return (less<_Ptr>()(_Left.get(), _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator<(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
 return (less<_Ptr>()(_Left, _Right.get()));
 }

template<class _Ty,
 class _Dx>
 bool operator>=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator>=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator>(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Dx>
 bool operator>(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Dx>
 bool operator<=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Dx>
 bool operator<=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (!(_Right < _Left));
 }



enum class pointer_safety {
 relaxed,
 preferred,
 strict
 };

typedef pointer_safety _Pointer_safety;

inline void declare_reachable(void *)
 {
 }

template<class _Ty> inline
 _Ty *undeclare_reachable(_Ty *_Ptr)
 {
 return (_Ptr);
 }

inline void declare_no_pointers(char *, size_t)
 {
 }

inline void undeclare_no_pointers(char *, size_t)
 {
 }

inline _Pointer_safety get_pointer_safety() noexcept
 {
 return (pointer_safety::relaxed);
 }
# 2292 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\memory" 3
template<class _Ty = void>
 struct owner_less;

template<class _Ty>
 struct owner_less<shared_ptr<_Ty> >
 {
 typedef shared_ptr<_Ty> first_argument_type;
 typedef shared_ptr<_Ty> second_argument_type;
 typedef bool result_type;

 bool operator()(const shared_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const shared_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const weak_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };

template<class _Ty>
 struct owner_less<weak_ptr<_Ty> >
 {
 typedef weak_ptr<_Ty> first_argument_type;
 typedef weak_ptr<_Ty> second_argument_type;
 typedef bool result_type;

 bool operator()(const weak_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const weak_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const shared_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };

template<>
 struct owner_less<void>
 {
 typedef int is_transparent;

 template<class _Ty,
  class _Uty>
  bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 template<class _Ty,
  class _Uty>
  bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 template<class _Ty,
  class _Uty>
  bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 template<class _Ty,
  class _Uty>
  bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };


template<class _Ty,
 class _Dx>
 struct hash<unique_ptr<_Ty, _Dx> >
 {
 typedef unique_ptr<_Ty, _Dx> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  typedef typename argument_type::pointer _Ptrtype;
  return (hash<_Ptrtype>()(_Keyval.get()));
  }
 };

template<class _Ty>
 struct hash<shared_ptr<_Ty> >
 {
 typedef shared_ptr<_Ty> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<_Ty *>()(_Keyval.get()));
  }
 };


inline void *align(size_t _Bound, size_t _Size,
 void *& _Ptr, size_t& _Space) noexcept
 {
 size_t _Off = (size_t)((uintptr_t)_Ptr & (_Bound - 1));
 if (0 < _Off)
  _Off = _Bound - _Off;
 if (_Space < _Off || _Space - _Off < _Size)
  return (0);
 else
  {
  _Ptr = (char *)_Ptr + _Off;
  _Space -= _Off;
  return (_Ptr);
  }
 }


extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}


struct _Shared_ptr_spin_lock
 {
 _Shared_ptr_spin_lock()
  {
  _Lock_shared_ptr_spin_lock();
  }

 ~_Shared_ptr_spin_lock() noexcept
  {
  _Unlock_shared_ptr_spin_lock();
  }
 };

template<class _Ty> inline
 bool atomic_is_lock_free(const shared_ptr<_Ty> *)
 {
 return (false);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> *_Ptr,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 shared_ptr<_Ty> _Result = *_Ptr;
 return (_Result);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> *_Ptr)
 {
 return (::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst));
 }

template<class _Ty> inline
 void atomic_store_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr->swap(_Other);
 }

template<class _Ty> inline
 void atomic_store(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
 {
 ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_exchange_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr->swap(_Other);
 return (_Other);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_exchange(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
 {
 return (::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_weak_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
  memory_order, memory_order)
 {
 shared_ptr<_Ty> _Old_exp;
 _Shared_ptr_spin_lock _Lock;
 bool _Success = _Ptr->get() == _Exp->get()
  && !_Ptr->owner_before(*_Exp)
  && !_Exp->owner_before(*_Ptr);
 if (_Success)
  _Ptr->swap(_Value);
 else
  {
  _Exp->swap(_Old_exp);
  *_Exp = *_Ptr;
  }
 return (_Success);
 }

template<class _Ty> inline
 bool atomic_compare_exchange_weak(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
   shared_ptr<_Ty> _Value)
 {
 return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
  memory_order_seq_cst, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_strong_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
  memory_order, memory_order)
 {
 return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
  memory_order_seq_cst, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_strong(
 shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
  shared_ptr<_Ty> _Value)
 {
 return (::std:: atomic_compare_exchange_strong_explicit(_Ptr, _Exp, ::std:: move(_Value),
  memory_order_seq_cst, memory_order_seq_cst));
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 2 3



# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthread" 1 3






# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xtime" 1 3







#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace stdext
 {
 namespace threads
  {
using ::xtime;
using ::xtime_get;
  }
 }

#pragma warning(pop)
#pragma pack(pop)
# 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthread" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthreads.h" 1 3
# 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthreads.h" 3
#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



extern "C" {
enum {
 _Thrd_success,
 _Thrd_nomem,
 _Thrd_timedout,
 _Thrd_busy,
 _Thrd_error
 };


typedef _Thrd_imp_t _Thrd_t;
typedef int (*_Thrd_start_t)(void *);

__declspec(dllimport) int __cdecl _Thrd_create(_Thrd_t *, _Thrd_start_t, void *);

__declspec(dllimport) int __cdecl _Thrd_detach(_Thrd_t);
__declspec(dllimport) void __cdecl _Thrd_exit(int);
__declspec(dllimport) int __cdecl _Thrd_join(_Thrd_t, int *);
__declspec(dllimport) void __cdecl _Thrd_sleep(const xtime*);
__declspec(dllimport) void __cdecl _Thrd_yield(void);
__declspec(dllimport) unsigned int __cdecl _Thrd_hardware_concurrency(void);
__declspec(dllimport) int __cdecl _Thrd_equal(_Thrd_t, _Thrd_t);
__declspec(dllimport) _Thrd_t __cdecl _Thrd_current(void);
__declspec(dllimport) _Thrd_id_t __cdecl _Thrd_id(void);


typedef _Mtx_imp_t _Mtx_t;
enum {
 _Mtx_plain = 0x01,
 _Mtx_try = 0x02,
 _Mtx_timed = 0x04,
 _Mtx_recursive = 0x100
 };

__declspec(dllimport) int __cdecl _Mtx_init(_Mtx_t *, int);
__declspec(dllimport) void __cdecl _Mtx_destroy(_Mtx_t);
__declspec(dllimport) void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
__declspec(dllimport) void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
__declspec(dllimport) int __cdecl _Mtx_current_owns(_Mtx_t);
__declspec(dllimport) int __cdecl _Mtx_lock(_Mtx_t);
__declspec(dllimport) int __cdecl _Mtx_trylock(_Mtx_t);
__declspec(dllimport) int __cdecl _Mtx_timedlock(_Mtx_t, const xtime *);
__declspec(dllimport) int __cdecl _Mtx_unlock(_Mtx_t);

__declspec(dllimport) void *__cdecl _Mtx_getconcrtcs(_Mtx_t);
__declspec(dllimport) void __cdecl _Mtx_clear_owner(_Mtx_t);
__declspec(dllimport) void __cdecl _Mtx_reset_owner(_Mtx_t);



typedef void * _Smtx_t;
void __cdecl _Smtx_lock_exclusive(_Smtx_t *);
void __cdecl _Smtx_lock_shared(_Smtx_t *);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t *);
int __cdecl _Smtx_try_lock_shared(_Smtx_t *);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t *);
void __cdecl _Smtx_unlock_shared(_Smtx_t *);


typedef _Cnd_imp_t _Cnd_t;

__declspec(dllimport) int __cdecl _Cnd_init(_Cnd_t *);
__declspec(dllimport) void __cdecl _Cnd_destroy(_Cnd_t);
__declspec(dllimport) void __cdecl _Cnd_init_in_situ(_Cnd_t);
__declspec(dllimport) void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
__declspec(dllimport) int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t);
__declspec(dllimport) int __cdecl _Cnd_timedwait(_Cnd_t,
 _Mtx_t, const xtime *);
__declspec(dllimport) int __cdecl _Cnd_broadcast(_Cnd_t);
__declspec(dllimport) int __cdecl _Cnd_signal(_Cnd_t);
__declspec(dllimport) void __cdecl _Cnd_register_at_thread_exit(_Cnd_t,
 _Mtx_t, int *);
__declspec(dllimport) void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
__declspec(dllimport) void __cdecl _Cnd_do_broadcast_at_thread_exit(void);


typedef _Tss_imp_t _Tss_t;
typedef void (*_Tss_dtor_t)(void *);
__declspec(dllimport) int __cdecl _Tss_create(_Tss_t *, _Tss_dtor_t);

__declspec(dllimport) int __cdecl _Tss_delete(_Tss_t);
__declspec(dllimport) int __cdecl _Tss_set(_Tss_t, void *);
__declspec(dllimport) void *__cdecl _Tss_get(_Tss_t);
# 110 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthreads.h" 3
__declspec(dllimport) void __cdecl _Thrd_abort(const char *);
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thr/xthread" 2 3





#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
enum {
 _DEVICE_OR_RESOURCE_BUSY,
 _INVALID_ARGUMENT,
 _NO_SUCH_PROCESS,
 _NOT_ENOUGH_MEMORY,
 _OPERATION_NOT_PERMITTED,
 _RESOURCE_DEADLOCK_WOULD_OCCUR,
 _RESOURCE_UNAVAILABLE_TRY_AGAIN
 };

__declspec(dllimport) void __cdecl _Throw_C_error(int _Code);
__declspec(dllimport) void __cdecl _Throw_Cpp_error(int _Code);

inline int _Check_C_return(int _Res)
 {
 if (_Res != _Thrd_success)
  _Throw_C_error(_Res);
 return (_Res);
 }

inline int _Check_C_return(int _Res, int _Other)
 {
 if (_Res != _Thrd_success && _Res != _Other)
  _Throw_C_error(_Res);
 return (_Res);
 }


inline int _Thrd_startX(_Thrd_imp_t *_Thr, _Thrd_callback_t _Fp, void *_Arg)
 {
 int _Res = _Thrd_start(_Thr, _Fp, _Arg);
 return (_Check_C_return(_Res != _Thrd_error ? _Res : _Thrd_nomem));
 }

inline int _Thrd_detachX(_Thrd_t _Thr)
 {
 return (_Check_C_return(_Thrd_detach(_Thr)));
 }

inline int _Thrd_joinX(_Thrd_t _Thr, int *_Res)
 {
 return (_Check_C_return(_Thrd_join(_Thr, _Res)));
 }

inline int _Mtx_initX(_Mtx_t *_Mtx, int _Type)
 {
 return (_Check_C_return(_Mtx_init(_Mtx, _Type)));
 }

inline int _Mtx_lockX(_Mtx_t _Mtx)
 {
 return (_Check_C_return(_Mtx_lock(_Mtx)));
 }

inline int _Mtx_trylockX(_Mtx_t _Mtx)
 {
 return (_Check_C_return(_Mtx_trylock(_Mtx), _Thrd_busy));
 }

inline int _Mtx_timedlockX(_Mtx_t _Mtx, const xtime *_Xt)
 {
 return (_Check_C_return(_Mtx_timedlock(_Mtx, _Xt), _Thrd_timedout));
 }

inline int _Mtx_unlockX(_Mtx_t _Mtx)
 {
 return (_Check_C_return(_Mtx_unlock(_Mtx)));
 }

inline int _Cnd_initX(_Cnd_t *_Cnd)
 {
 return (_Check_C_return(_Cnd_init(_Cnd)));
 }

inline int _Cnd_waitX(_Cnd_t _Cnd, _Mtx_t _Mtx)
 {
 return (_Check_C_return(_Cnd_wait(_Cnd, _Mtx)));
 }

inline int _Cnd_timedwaitX(_Cnd_t _Cnd,
 _Mtx_t _Mtx, const xtime *_Xt)
 {
 return (_Check_C_return(_Cnd_timedwait(_Cnd, _Mtx, _Xt), _Thrd_timedout));
 }

inline int _Cnd_broadcastX(_Cnd_t _Cnd)
 {
 return (_Check_C_return(_Cnd_broadcast(_Cnd)));
 }

inline int _Cnd_signalX(_Cnd_t _Cnd)
 {
 return (_Check_C_return(_Cnd_signal(_Cnd)));
 }

class _Auto_cnd
 {
public:
 _Auto_cnd(_Cnd_t _Cndp)
  : _Active(true), _MyCndp(_Cndp)
  {
  }

 ~_Auto_cnd() noexcept
  {
  if (_Active)
   _Cnd_destroy(_MyCndp);
   }

 void _Release()
  {
  _Active = false;
  }

private:
 bool _Active;
 _Cnd_t _MyCndp;
 };

class _Auto_mtx
 {
public:
 _Auto_mtx(_Mtx_t _Mtxp)
  : _Active(true), _MyMtxp(_Mtxp)
  {
  }

 ~_Auto_mtx() noexcept
  {
  if (_Active)
   _Mtx_destroy(_MyMtxp);
  }

 void _Release()
  {
  _Active = false;
  }

private:
 bool _Active;
 _Mtx_t _MyMtxp;
 };

#pragma warning(push)
#pragma warning(disable: 4265)
class _Pad
 {
public:
 _Pad()
  {
  _Cnd_initX(&_Cond);
  _Auto_cnd _Cnd_cleaner(_Cond);
  _Mtx_initX(&_Mtx, _Mtx_plain);
  _Auto_mtx _Mtx_cleaner(_Mtx);
  _Started = false;
  _Mtx_lockX(_Mtx);
  _Mtx_cleaner._Release();
  _Cnd_cleaner._Release();
  }

 ~_Pad() noexcept
  {
  _Auto_cnd _Cnd_cleaner(_Cond);
  _Auto_mtx _Mtx_cleaner(_Mtx);
  _Mtx_unlockX(_Mtx);
  }

 void _Launch(_Thrd_t *_Thr)
  {
  _Thrd_startX(_Thr, _Call_func, this);
  while (!_Started)
   _Cnd_waitX(_Cond, _Mtx);
  }

 void _Release()
  {
  _Mtx_lockX(_Mtx);
  _Started = true;
  _Cnd_signalX(_Cond);
  _Mtx_unlockX(_Mtx);
  }

 virtual void _Go() = 0;

private:
typedef unsigned int _Call_func_ret;


 static _Call_func_ret __stdcall _Call_func(void *_Data)
  {
  static_cast<_Pad *>(_Data)->_Go();
  return (0);
  }

 _Cnd_t _Cond;
 _Mtx_t _Mtx;
 bool _Started;
 };

template<class _Target>
 class _LaunchPad final
  : public _Pad
 {
public:
 template<class _Other> inline
  _LaunchPad(_Other&& _Tgt)
  : _MyTarget(::std:: forward<_Other>(_Tgt))
  {
  }

 virtual void _Go()
  {
  _Run(this);
  }

private:
 template<size_t... _Idxs>
  static void _Execute(typename _Target::element_type& _Tup,
   index_sequence<_Idxs...>)
  {
  ::std:: invoke(::std:: move(::std:: get<_Idxs>(_Tup))...);
  }

 static void _Run(_LaunchPad *_Ln) noexcept
  {
  _Target _Local(::std:: forward<_Target>(_Ln->_MyTarget));
  _Ln->_Release();
  _Execute(*_Local,
   make_index_sequence<tuple_size<typename _Target::element_type>::value>());
  _Cnd_do_broadcast_at_thread_exit();
  }

 _Target _MyTarget;
 };
#pragma warning(pop)

template<class _Target> inline
 void _Launch(_Thrd_t *_Thr, _Target&& _Tg)
 {
 _LaunchPad<_Target> _Launcher(::std:: forward<_Target>(_Tg));
 _Launcher._Launch(_Thr);
 }
}


#pragma warning(pop)
#pragma pack(pop)
# 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\thread" 2 3



#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {
class thread
 {
public:
 class id;

 typedef void *native_handle_type;

 thread() noexcept
  {
  (_Thr._Hnd = 0, _Thr._Id = 0);
  }


 template<class _Fn,
  class... _Args,
  class = typename enable_if<
   !is_same<typename decay<_Fn>::type, thread>::value>::type>
  explicit thread(_Fn&& _Fx, _Args&&... _Ax)
  {
  _Launch(&_Thr,
   ::std:: make_unique<tuple<decay_t<_Fn>, decay_t<_Args>...> >(
    ::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...));
  }


 ~thread() noexcept
  {
  if (joinable())
   ::std:: terminate();
  }

 thread(thread&& _Other) noexcept
  : _Thr(_Other._Thr)
  {
  (_Other._Thr._Hnd = 0, _Other._Thr._Id = 0);
  }

 thread& operator=(thread&& _Other) noexcept
  {
  return (_Move_thread(_Other));
  }

 thread(const thread&) = delete;
 thread& operator=(const thread&) = delete;

 void swap(thread& _Other) noexcept
  {
  ::std:: swap(_Thr, _Other._Thr);
  }

 bool joinable() const noexcept
  {
  return (!(_Thr._Id == 0));
  }

 void join();

 void detach()
  {
  if (!joinable())
   _Throw_Cpp_error(_INVALID_ARGUMENT);
  _Thrd_detachX(_Thr);
  (_Thr._Hnd = 0, _Thr._Id = 0);
  }

 id get_id() const noexcept;

 static unsigned int hardware_concurrency() noexcept
  {
  return (_Thrd_hardware_concurrency());
  }

 native_handle_type native_handle()
  {
  return (_Thr._Hnd);
  }

private:
 thread& _Move_thread(thread& _Other)
  {
  if (joinable())
   ::std:: terminate();
  _Thr = _Other._Thr;
  (_Other._Thr._Hnd = 0, _Other._Thr._Id = 0);
  return (*this);
  }

 _Thrd_t _Thr;
 };

 namespace this_thread {
thread::id get_id() noexcept;

inline void yield() noexcept
 {
 _Thrd_yield();
 }

inline void sleep_until(const stdext::threads::xtime *_Abs_time)
 {
 _Thrd_sleep(_Abs_time);
 }

template<class _Rep,
 class _Period> inline
 void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
 {
 stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
 this_thread::sleep_until(&_Tgt);
 }

template<class _Clock,
 class _Duration> inline
 void sleep_until(
  const chrono::time_point<_Clock, _Duration>& _Abs_time)
 {
 this_thread::sleep_for(_Abs_time.time_since_epoch() - _Clock::now().time_since_epoch());
 }
 }

class thread::id
 {
public:
 id() noexcept
  : _Id(0)
  {
  }

 template<class _Ch,
  class _Tr>
  basic_ostream<_Ch, _Tr>& _To_text(
   basic_ostream<_Ch, _Tr>& _Str)
  {
  return (_Str << _Id);
  }

private:
 id(_Thrd_id_t _Other_id)
  : _Id(_Other_id)
  {
  }

 size_t _Hash_id() const
  {
  return (hash<_Thrd_id_t>()(_Id));
  }

 _Thrd_id_t _Id;

 friend thread::id thread::get_id() const noexcept;
 friend thread::id this_thread::get_id() noexcept;
 friend bool operator==(thread::id _Left, thread::id _Right) noexcept;
 friend bool operator<(thread::id _Left, thread::id _Right) noexcept;
 friend struct hash<thread::id>;
 };

inline void thread::join()
 {
 if (!joinable())
  _Throw_Cpp_error(_INVALID_ARGUMENT);
 const bool _Is_null = (_Thr._Id == 0);
 if (_Is_null)
  _Throw_Cpp_error(_INVALID_ARGUMENT);
 if (get_id() == ::std:: this_thread::get_id())
  _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
 if (_Thrd_join(_Thr, 0) != _Thrd_success)
  _Throw_Cpp_error(_NO_SUCH_PROCESS);
 (_Thr._Hnd = 0, _Thr._Id = 0);
 }

inline thread::id thread::get_id() const noexcept
 {
 return (_Thr._Id);
 }

inline thread::id this_thread::get_id() noexcept
 {
 return (_Thrd_id());
 }

inline void swap(thread& _Left, thread& _Right) noexcept
 {
 _Left.swap(_Right);
 }

inline bool operator==(thread::id _Left, thread::id _Right) noexcept
 {
 return (_Left._Id == _Right._Id);
 }

inline bool operator!=(thread::id _Left, thread::id _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator<(thread::id _Left, thread::id _Right) noexcept
 {
 return (_Left._Id < _Right._Id);
 }

inline bool operator<=(thread::id _Left, thread::id _Right) noexcept
 {
 return (!(_Right < _Left));
 }

inline bool operator>(thread::id _Left, thread::id _Right) noexcept
 {
 return (_Right < _Left);
 }

inline bool operator>=(thread::id _Left, thread::id _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ch,
 class _Tr>
 basic_ostream<_Ch, _Tr>& operator<<(
  basic_ostream<_Ch, _Tr>& _Str,
  thread::id _Id)
 {
 return (_Id._To_text(_Str));
 }


template<>
 struct hash<thread::id>
 {
 typedef thread::id argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Keyval._Hash_id());
  }
 };
}


#pragma warning(pop)
#pragma pack(pop)
# 10 "./../xrCore/xrCore.h" 2

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\mutex" 1 3
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\mutex" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\system_error" 1 3





# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\cerrno" 1 3
# 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\system_error" 2 3


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 1 3








#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)


namespace std {

class logic_error
 : public exception
 {
public:
 typedef exception _Mybase;

 explicit logic_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit logic_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class domain_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit domain_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit domain_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class invalid_argument
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit invalid_argument(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit invalid_argument(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class length_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit length_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit length_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class out_of_range
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit out_of_range(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit out_of_range(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class runtime_error
 : public exception
 {
public:
 typedef exception _Mybase;

 explicit runtime_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit runtime_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class overflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit overflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit overflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class underflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit underflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit underflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };


class range_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit range_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit range_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
# 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdexcept" 3
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\system_error" 2 3


#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)
# 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\system_error" 3
namespace std {


enum class errc {
 address_family_not_supported = 102,
 address_in_use = 100,
 address_not_available = 101,
 already_connected = 113,
 argument_list_too_long = 7,
 argument_out_of_domain = 33,
 bad_address = 14,
 bad_file_descriptor = 9,
 bad_message = 104,
 broken_pipe = 32,
 connection_aborted = 106,
 connection_already_in_progress = 103,
 connection_refused = 107,
 connection_reset = 108,
 cross_device_link = 18,
 destination_address_required = 109,
 device_or_resource_busy = 16,
 directory_not_empty = 41,
 executable_format_error = 8,
 file_exists = 17,
 file_too_large = 27,
 filename_too_long = 38,
 function_not_supported = 40,
 host_unreachable = 110,
 identifier_removed = 111,
 illegal_byte_sequence = 42,
 inappropriate_io_control_operation = 25,
 interrupted = 4,
 invalid_argument = 22,
 invalid_seek = 29,
 io_error = 5,
 is_a_directory = 21,
 message_size = 115,
 network_down = 116,
 network_reset = 117,
 network_unreachable = 118,
 no_buffer_space = 119,
 no_child_process = 10,
 no_link = 121,
 no_lock_available = 39,
 no_message_available = 120,
 no_message = 122,
 no_protocol_option = 123,
 no_space_on_device = 28,
 no_stream_resources = 124,
 no_such_device_or_address = 6,
 no_such_device = 19,
 no_such_file_or_directory = 2,
 no_such_process = 3,
 not_a_directory = 20,
 not_a_socket = 128,
 not_a_stream = 125,
 not_connected = 126,
 not_enough_memory = 12,
 not_supported = 129,
 operation_canceled = 105,
 operation_in_progress = 112,
 operation_not_permitted = 1,
 operation_not_supported = 130,
 operation_would_block = 140,
 owner_dead = 133,
 permission_denied = 13,
 protocol_error = 134,
 protocol_not_supported = 135,
 read_only_file_system = 30,
 resource_deadlock_would_occur = 36,
 resource_unavailable_try_again = 11,
 result_out_of_range = 34,
 state_not_recoverable = 127,
 stream_timeout = 137,
 text_file_busy = 139,
 timed_out = 138,
 too_many_files_open_in_system = 23,
 too_many_files_open = 24,
 too_many_links = 31,
 too_many_symbolic_link_levels = 114,
 value_too_large = 132,
 wrong_protocol_type = 136
 };

typedef errc _Errc;



enum class io_errc {
 stream = 1
 };

typedef io_errc _Io_errc;


template<class _Enum>
 struct is_error_code_enum
  : public false_type
 {
 };

template<>
 struct is_error_code_enum<_Io_errc>
  : public true_type
 {
 };

template<class _Ty>
 constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;


template<class _Enum>
 struct is_error_condition_enum
  : public false_type
 {
 };

template<>
 struct is_error_condition_enum<_Errc>
  : public true_type
 {
 };

template<class _Ty>
 constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;


class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
 {
public:
                 error_category() noexcept
  {
  _Addr = reinterpret_cast<uintptr_t>(this);
  }

 virtual ~error_category() noexcept
  {
  }

 virtual const char *name() const noexcept = 0;

 virtual string message(int _Errval) const = 0;

 virtual error_condition
  default_error_condition(int _Errval) const noexcept;

 virtual bool equivalent(int _Errval,
  const error_condition& _Cond) const noexcept;

 virtual bool equivalent(const error_code& _Code,
  int _Errval) const noexcept;

 bool operator==(const error_category& _Right) const noexcept
  {
  return (_Addr == _Right._Addr);
  }

 bool operator!=(const error_category& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_category& _Right) const noexcept
  {
  return (_Addr < _Right._Addr);
  }

 error_category(const error_category&) = delete;
 error_category& operator=(const error_category&) = delete;

protected:
 uintptr_t _Addr;

 enum : uintptr_t
  {
  _Future_addr = 1,
  _Generic_addr = 3,
  _Iostream_addr = 5,
  _System_addr = 7
  };
 };


class error_code
 {
public:
 typedef error_code _Myt;

 error_code() noexcept
  : _Myval(0),
   _Mycat(&system_category())
  {
  }

 error_code(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = typename enable_if<is_error_code_enum<_Enum>::value,
   void>::type>
  error_code(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_code(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  typename enable_if<is_error_code_enum<_Enum>::value,
   error_code>::type& operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_code(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &system_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 error_condition default_error_condition() const noexcept;

 string message() const
  {
  return (category().message(value()));
  }

 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


class error_condition
 {
public:
 typedef error_condition _Myt;

 error_condition() noexcept
  : _Myval(0),
   _Mycat(&generic_category())
  {
  }

 error_condition(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = typename enable_if<is_error_condition_enum<_Enum>::value,
   void>::type>
  error_condition(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_condition(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  typename enable_if<is_error_condition_enum<_Enum>::value,
   error_condition>::type& operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_condition(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &generic_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 string message() const
  {
  return (category().message(value()));
  }

 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


inline bool operator==(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }

inline bool operator==(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category().equivalent(_Left.value(), _Right)
  || _Right.category().equivalent(_Left, _Right.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (_Right.category().equivalent(_Right.value(), _Left)
  || _Left.category().equivalent(_Right, _Left.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }


inline bool operator!=(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


inline bool operator<(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }

inline bool operator<(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }


inline error_condition
 error_category::default_error_condition(int _Errval) const noexcept
 {
 return (error_condition(_Errval, *this));
 }

inline bool
 error_category::equivalent(int _Errval,
  const error_condition& _Cond) const noexcept
 {
 return (default_error_condition(_Errval) == _Cond);
 }

inline bool
 error_category::equivalent(const error_code& _Code,
  int _Errval) const noexcept
 {
 return (*this == _Code.category() && _Code.value() == _Errval);
 }


inline error_condition error_code::default_error_condition() const noexcept
 {
 return (category().default_error_condition(value()));
 }


inline error_code make_error_code(_Errc _Errno) noexcept
 {
 return (error_code((int)_Errno, generic_category()));
 }

inline error_code make_error_code(_Io_errc _Errno) noexcept
 {
 return (error_code((int)_Errno, iostream_category()));
 }


inline error_condition make_error_condition(_Errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, generic_category()));
 }

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, iostream_category()));
 }


template<>
 struct hash<error_code>
 {
 typedef error_code argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<int>()(_Keyval.value()));
  }
 };


class _System_error
 : public runtime_error
 {
private:
 static string _Makestr(error_code _Errcode, string _Message)
  {
  if (!_Message.empty())
   _Message.append(": ");
  _Message.append(_Errcode.message());
  return (_Message);
  }

protected:
 _System_error(error_code _Errcode, const string& _Message)
  : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
  {
  }

 error_code _Mycode;
 };

class system_error
 : public _System_error
 {
private:
 typedef _System_error _Mybase;

public:
 system_error(error_code _Errcode)
  : _Mybase(_Errcode, "")
  {
  }

 system_error(error_code _Errcode, const string& _Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(error_code _Errcode, const char *_Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat)
  : _Mybase(error_code(_Errval, _Errcat), "")
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const string& _Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const char *_Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 const error_code& code() const noexcept
  {
  return (_Mycode);
  }
# 579 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\system_error" 3
 };

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) int __cdecl _Winerror_map(int);
__declspec(dllimport) unsigned long __cdecl _Winerror_message(
 unsigned long _Message_id, char *_Narrow, unsigned long _Size);


class _Generic_error_category
 : public error_category
 {
public:
 _Generic_error_category() noexcept
  {
  _Addr = _Generic_addr;
  }

 virtual const char *name() const noexcept
  {
  return ("generic");
  }

 virtual string message(int _Errcode) const
  {
  return (_Syserror_map(_Errcode));
  }
 };


class _Iostream_error_category
 : public _Generic_error_category
 {
public:
 _Iostream_error_category() noexcept
  {
  _Addr = _Iostream_addr;
  }

 virtual const char *name() const noexcept
  {
  return ("iostream");
  }

 virtual string message(int _Errcode) const
  {
  if (_Errcode == (int)io_errc::stream)
   return ("iostream stream error");
  else
   return (_Generic_error_category::message(_Errcode));
  }
 };


class _System_error_category
 : public error_category
 {
public:
 _System_error_category() noexcept
  {
  _Addr = _System_addr;
  }

 virtual const char *name() const noexcept
  {
  return ("system");
  }

 virtual string message(int _Errcode) const
  {
  const unsigned long _Size = 32767;
  string _Narrow(_Size, '\0');

  const unsigned long _Val = _Winerror_message(
   static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

  if (_Val == 0)
   return ("unknown error");

  _Narrow.resize(_Val);
  _Narrow.shrink_to_fit();
  return (_Narrow);
  }

 virtual error_condition
  default_error_condition(int _Errval) const noexcept
  {
  int _Posv = _Winerror_map(_Errval);

  if (_Posv != 0)
   return (error_condition(_Posv, generic_category()));
  else
   return (error_condition(_Errval, system_category()));
  }
 };

template<class _Ty>
 struct _Immortalizer
 {
 _Immortalizer()
  {
  ::new (static_cast<void *>(&_Storage)) _Ty();
  }

 ~_Immortalizer() noexcept
  {
  }

 _Immortalizer(const _Immortalizer&) = delete;
 _Immortalizer& operator=(const _Immortalizer&) = delete;

 typename aligned_union<1, _Ty>::type _Storage;
 };

template<class _Ty> inline
 _Ty& _Immortalize()
 {
             static _Immortalizer<_Ty> _Static;
 return (*reinterpret_cast<_Ty *>(&_Static._Storage));
 }

inline const error_category& generic_category() noexcept
 {
 return (_Immortalize<_Generic_error_category>());
 }

inline const error_category& iostream_category() noexcept
 {
 return (_Immortalize<_Iostream_error_category>());
 }

inline const error_category& system_category() noexcept
 {
 return (_Immortalize<_System_error_category>());
 }
}

#pragma warning(pop)
#pragma pack(pop)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\mutex" 2 3





#pragma pack(push,8)
#pragma warning(push, 3)
#pragma warning(disable: 4702)



namespace std {

class _Mutex_base
 {
public:
 _Mutex_base(int _Flags = 0) noexcept
  {
  _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);
  }

 ~_Mutex_base() noexcept
  {
  _Mtx_destroy_in_situ(_Mymtx());
  }

 _Mutex_base(const _Mutex_base&) = delete;
 _Mutex_base& operator=(const _Mutex_base&) = delete;

 void lock()
  {
  _Mtx_lockX(_Mymtx());
  }

 bool try_lock()
  {
  return (_Mtx_trylockX(_Mymtx()) == _Thrd_success);
  }

 void unlock()
  {
  _Mtx_unlockX(_Mymtx());
  }

 typedef void *native_handle_type;

 native_handle_type native_handle()

  {
  return (_Mtx_getconcrtcs(_Mymtx()));
  }

private:
 friend class condition_variable;
 friend class condition_variable_any;

 aligned_storage<80,
  8>::type _Mtx_storage;

 _Mtx_t _Mymtx() noexcept
  {
  return (reinterpret_cast<_Mtx_t>(&_Mtx_storage));
  }
 };

class mutex
 : public _Mutex_base
 {
public:
                 mutex() noexcept
  : _Mutex_base()
  {
  }

 mutex(const mutex&) = delete;
 mutex& operator=(const mutex&) = delete;
 };

class recursive_mutex
 : public _Mutex_base
 {
public:
 recursive_mutex()
  : _Mutex_base(_Mtx_recursive)
  {
  }

 bool try_lock() noexcept
  {
  return (_Mutex_base::try_lock());
  }

 recursive_mutex(const recursive_mutex&) = delete;
 recursive_mutex& operator=(const recursive_mutex&) = delete;
 };



template<class _Lock0,
 class... _LockN> inline
 int try_lock(_Lock0&, _LockN&...);

template<class _Lock0> inline
 int _Try_lock(_Lock0& _Lk0)
 {
 if (!_Lk0.try_lock())
  return (0);
 else
  return (-1);
 }

template<class _Lock0,
 class _Lock1,
 class... _LockN> inline
 int _Try_lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN)
 {
 int _Res;
 if (!_Lk0.try_lock())
  return (0);
 try {

  if ((_Res = ::std:: try_lock(_Lk1, _LkN...)) != -1)
   {
   _Lk0.unlock();
   ++_Res;
   }
 } catch (...) {

  _Lk0.unlock();
  throw;
 }
 return (_Res);
 }

template<class _Lock0,
 class... _LockN> inline
 int try_lock(_Lock0& _Lk0, _LockN&... _LkN)
 {
 return (_Try_lock(_Lk0, _LkN...));
 }


template<class _Lock0,
 class _Lock1,
 class... _LockN> inline
 void lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN)
 {
 int _Res = 0;
 while (_Res != -1)
  _Res = _Try_lock(_Lk0, _Lk1, _LkN...);
 }



struct adopt_lock_t
 {
 };

struct defer_lock_t
 {
 };

struct try_to_lock_t
 {
 };
constexpr adopt_lock_t adopt_lock{};
constexpr defer_lock_t defer_lock{};
constexpr try_to_lock_t try_to_lock{};

template<class... _Mutexes>
 class lock_guard
 {
public:
 explicit lock_guard(_Mutexes&... _Mtxes)
  : _MyMutexes(_Mtxes...)
  {
  ::std:: lock(_Mtxes...);
  }

 lock_guard(_Mutexes&... _Mtxes, adopt_lock_t)
  : _MyMutexes(_Mtxes...)
  {
  }

 ~lock_guard() noexcept
  {
  _For_each_tuple_element(
   _MyMutexes,
   [](auto& _Mutex) noexcept { _Mutex.unlock(); });
  }

 lock_guard(const lock_guard&) = delete;
 lock_guard& operator=(const lock_guard&) = delete;
private:
 tuple<_Mutexes&...> _MyMutexes;
 };

template<class _Mutex>
 class lock_guard<_Mutex>
 {
public:
 typedef _Mutex mutex_type;

 explicit lock_guard(_Mutex& _Mtx)
  : _MyMutex(_Mtx)
  {
  _MyMutex.lock();
  }

 lock_guard(_Mutex& _Mtx, adopt_lock_t)
  : _MyMutex(_Mtx)
  {
  }

 ~lock_guard() noexcept
  {
  _MyMutex.unlock();
  }

 lock_guard(const lock_guard&) = delete;
 lock_guard& operator=(const lock_guard&) = delete;
private:
 _Mutex& _MyMutex;
 };

template<>
 class lock_guard<>
 {
public:
 explicit lock_guard()
  {
  }

 lock_guard(adopt_lock_t)
  {
  }

 ~lock_guard() noexcept
  {
  }

 lock_guard(const lock_guard&) = delete;
 lock_guard& operator=(const lock_guard&) = delete;
 };

template<class _Mutex>
 class unique_lock
 {
public:
 typedef unique_lock<_Mutex> _Myt;
 typedef _Mutex mutex_type;


 unique_lock() noexcept
  : _Pmtx(0), _Owns(false)
  {
  }

 explicit unique_lock(_Mutex& _Mtx)
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(false)
  {
  _Pmtx->lock();
  _Owns = true;
  }

 unique_lock(_Mutex& _Mtx, adopt_lock_t)
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(true)
  {
  }

 unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(false)
  {
  }

 unique_lock(_Mutex& _Mtx, try_to_lock_t)
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock())
  {
  }

 template<class _Rep,
  class _Period>
  unique_lock(_Mutex& _Mtx,
   const chrono::duration<_Rep, _Period>& _Rel_time)
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_for(_Rel_time))
  {
  }

 template<class _Clock,
  class _Duration>
  unique_lock(_Mutex& _Mtx,
   const chrono::time_point<_Clock, _Duration>& _Abs_time)
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_until(_Abs_time))
  {
  }

 unique_lock(_Mutex& _Mtx, const xtime *_Abs_time)
  : _Pmtx(::std:: addressof(_Mtx)), _Owns(false)
  {
  _Owns = _Pmtx->try_lock_until(_Abs_time);
  }

 unique_lock(unique_lock&& _Other) noexcept
  : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)
  {
  _Other._Pmtx = 0;
  _Other._Owns = false;
  }

 unique_lock& operator=(unique_lock&& _Other)
  {
  if (this != ::std:: addressof(_Other))
   {
   if (_Owns)
    _Pmtx->unlock();
   _Pmtx = _Other._Pmtx;
   _Owns = _Other._Owns;
   _Other._Pmtx = 0;
   _Other._Owns = false;
   }
  return (*this);
  }

 ~unique_lock() noexcept
  {
  if (_Owns)
   _Pmtx->unlock();
  }

 unique_lock(const unique_lock&) = delete;
 unique_lock& operator=(const unique_lock&) = delete;


 void lock()
  {
  _Validate();
  _Pmtx->lock();
  _Owns = true;
  }

 bool try_lock()
  {
  _Validate();
  _Owns = _Pmtx->try_lock();
  return (_Owns);
  }

 template<class _Rep,
  class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  _Validate();
  _Owns = _Pmtx->try_lock_for(_Rel_time);
  return (_Owns);
  }

 template<class _Clock,
  class _Duration>
  bool try_lock_until(
   const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  _Validate();
  _Owns = _Pmtx->try_lock_until(_Abs_time);
  return (_Owns);
  }

 bool try_lock_until(const xtime *_Abs_time)
  {
  _Validate();
  _Owns = _Pmtx->try_lock_until(_Abs_time);
  return (_Owns);
  }

 void unlock()
  {
  if (!_Pmtx || !_Owns)
   throw system_error(::std:: make_error_code(errc::operation_not_permitted));


  _Pmtx->unlock();
  _Owns = false;
  }


 void swap(unique_lock& _Other) noexcept
  {
  ::std:: swap(_Pmtx, _Other._Pmtx);
  ::std:: swap(_Owns, _Other._Owns);
  }

 _Mutex *release() noexcept
  {
  _Mutex *_Res = _Pmtx;
  _Pmtx = 0;
  _Owns = false;
  return (_Res);
  }


 bool owns_lock() const noexcept
  {
  return (_Owns);
  }

 explicit operator bool() const noexcept
  {
  return (_Owns);
  }

 _Mutex *mutex() const noexcept
  {
  return (_Pmtx);
  }

private:
 _Mutex *_Pmtx;
 bool _Owns;

 void _Validate() const
  {
  if (!_Pmtx)
   throw system_error(::std:: make_error_code(errc::operation_not_permitted));


  if (_Owns)
   throw system_error(::std:: make_error_code(errc::resource_deadlock_would_occur));

  }
 };


template<class _Mutex>
 void swap(unique_lock<_Mutex>& _Left,
  unique_lock<_Mutex>& _Right) noexcept
 {
 _Left.swap(_Right);
 }


struct once_flag
 {
 constexpr once_flag() noexcept
  : _Opaque(0)
  {
  }

 once_flag(const once_flag&) = delete;
 once_flag& operator=(const once_flag&) = delete;

 void *_Opaque;
 };


template<class... _Types,
 size_t... _Indices> inline
 auto _Invoke_stored_explicit(tuple<_Types...>&& _Tuple, index_sequence<_Indices...>)
  -> decltype(::std:: invoke(::std:: get<_Indices>(::std:: move(_Tuple))...))
 {
 return (::std:: invoke(::std:: get<_Indices>(::std:: move(_Tuple))...));
 }


template<class... _Types> inline
 auto _Invoke_stored(tuple<_Types...>&& _Tuple)
  -> decltype(_Invoke_stored_explicit(::std:: move(_Tuple), index_sequence_for<_Types...>()))
 {
 return (_Invoke_stored_explicit(::std:: move(_Tuple), index_sequence_for<_Types...>()));
 }


typedef int (__stdcall *_Lambda_fp_t)(void *, void *, void **);
__declspec(dllimport) int __cdecl _Execute_once(
 once_flag& _Flag, _Lambda_fp_t _Lambda_fp, void *_Pv) noexcept;

[[noreturn]] __declspec(dllimport) void __cdecl _XGetLastError();

template<class _Tuple,
 class _Seq,
 size_t _Idx> inline
 int __stdcall _Callback_once(void *, void *_Pv, void **)
 {
 _Tuple *_Ptup = static_cast<_Tuple *>(_Pv);

 try {

  _Invoke_stored_explicit(::std:: move(*_Ptup), _Seq());
 } catch (...) {
  auto& _Ref = ::std:: get<_Idx>(*_Ptup);
  _Ref = ::std:: current_exception();
  return (0);
 }

 return (1);
 }

template<class _Fn,
 class... _Args> inline
 void (call_once)(once_flag& _Flag, _Fn&& _Fx, _Args&&... _Ax)
 {
 typedef tuple<_Fn&&, _Args&&..., exception_ptr&> _Tuple;
 typedef make_index_sequence<1 + sizeof...(_Args)> _Seq;

 exception_ptr _Exc;
 _Tuple _Tup(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)..., _Exc);

 _Lambda_fp_t _Fp = &_Callback_once<_Tuple, _Seq, 1 + sizeof...(_Args)>;

 if (_Execute_once(_Flag, _Fp, ::std:: addressof(_Tup)) != 0)
  return;

 if (_Exc)
  ::std:: rethrow_exception(_Exc);

 _XGetLastError();
 }

enum class cv_status {
 no_timeout,
 timeout
 };

typedef cv_status _Cv_status;

class condition_variable
 {
public:
 typedef _Cnd_t native_handle_type;

 condition_variable()
  {
  _Cnd_init_in_situ(_Mycnd());
  }

 ~condition_variable() noexcept
  {
  _Cnd_destroy_in_situ(_Mycnd());
  }

 condition_variable(const condition_variable&) = delete;
 condition_variable& operator=(const condition_variable&) = delete;

 void notify_one() noexcept
  {
  _Cnd_signalX(_Mycnd());
  }

 void notify_all() noexcept
  {
  _Cnd_broadcastX(_Mycnd());
  }

 void wait(unique_lock<mutex>& _Lck)
  {

  _Cnd_waitX(_Mycnd(), _Lck.mutex()->_Mymtx());
  }

 template<class _Predicate>
  void wait(unique_lock<mutex>& _Lck, _Predicate _Pred)
  {
  while (!_Pred())
   wait(_Lck);
  }

 template<class _Rep,
  class _Period>
  _Cv_status wait_for(
   unique_lock<mutex>& _Lck,
   const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  ::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
  return (wait_until(_Lck, &_Tgt));
  }

 template<class _Rep,
  class _Period,
  class _Predicate>
  bool wait_for(
   unique_lock<mutex>& _Lck,
   const chrono::duration<_Rep, _Period>& _Rel_time,
   _Predicate _Pred)
  {
  ::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
  return (_Wait_until1(_Lck, &_Tgt, _Pred));
  }

 template<class _Clock,
  class _Duration>
  _Cv_status wait_until(
   unique_lock<mutex>& _Lck,
   const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  typename chrono::time_point<_Clock, _Duration>::duration
   _Rel_time = _Abs_time - _Clock::now();
  return (wait_for(_Lck, _Rel_time));
  }

 template<class _Clock,
  class _Duration,
  class _Predicate>
  bool wait_until(
   unique_lock<mutex>& _Lck,
   const chrono::time_point<_Clock, _Duration>& _Abs_time,
   _Predicate _Pred)
  {
  typename chrono::time_point<_Clock, _Duration>::duration
   _Rel_time = _Abs_time - _Clock::now();
  ::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
  return (_Wait_until1(_Lck, &_Tgt, _Pred));
  }

 _Cv_status wait_until(
  unique_lock<mutex>& _Lck,
  const xtime *_Abs_time)
  {
  if (!_Mtx_current_owns(_Lck.mutex()->_Mymtx()))
   _Throw_Cpp_error(_OPERATION_NOT_PERMITTED);


  int _Res = _Cnd_timedwaitX(_Mycnd(),
   _Lck.mutex()->_Mymtx(), _Abs_time);
  return (_Res == _Thrd_timedout
   ? cv_status::timeout : cv_status::no_timeout);
  }

 template<class _Predicate>
  bool wait_until(
   unique_lock<mutex>& _Lck,
   const xtime *_Abs_time,
   _Predicate _Pred)
  {
  return (_Wait_until1(_Lck, _Abs_time, _Pred));
  }

 template<class _Predicate>
  bool _Wait_until1(
   unique_lock<mutex>& _Lck,
   const xtime *_Abs_time,
   _Predicate& _Pred)
  {
  while (!_Pred())
   if (wait_until(_Lck, _Abs_time) == cv_status::timeout)
    return (_Pred());
  return (true);
  }

 native_handle_type native_handle()
  {
  return (_Mycnd());
  }

 void _Register(unique_lock<mutex>& _Lck, int *_Ready)
  {
  _Cnd_register_at_thread_exit(_Mycnd(),
   _Lck.release()->_Mymtx(), _Ready);
  }

 void _Unregister(mutex& _Mtx)
  {
  _Cnd_unregister_at_thread_exit(_Mtx._Mymtx());
  }

private:
 aligned_storage<72,
  8>::type _Cnd_storage;

 _Cnd_t _Mycnd() noexcept
  {
  return (reinterpret_cast<_Cnd_t>(&_Cnd_storage));
  }
 };

class timed_mutex
 {
public:
 timed_mutex() noexcept
  : _My_locked(0)
  {
  }

 timed_mutex(const timed_mutex&) = delete;
 timed_mutex& operator=(const timed_mutex&) = delete;

 void lock()
  {
  unique_lock<mutex> _Lock(_My_mutex);
  while (_My_locked != 0)
   _My_cond.wait(_Lock);
  _My_locked = 0xffffffff;
  }

 bool try_lock() noexcept
  {
  lock_guard<mutex> _Lock(_My_mutex);
  if (_My_locked != 0)
   return (false);
  else
   {
   _My_locked = 0xffffffff;
   return (true);
   }
  }

 void unlock()
  {
   {

   lock_guard<mutex> _Lock(_My_mutex);
   _My_locked = 0;
   }
  _My_cond.notify_one();
  }

 template<class _Rep,
  class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  return (try_lock_until(chrono::steady_clock::now() + _Rel_time));
  }

 template<class _Time>
  bool _Try_lock_until(_Time _Abs_time)
  {
  unique_lock<mutex> _Lock(_My_mutex);
  if (!_My_cond.wait_until(_Lock, _Abs_time,
   [this] { return (_My_locked == 0); }))
    return (false);
  _My_locked = 0xffffffff;
  return (true);
  }

 template<class _Clock,
  class _Duration>
  bool try_lock_until(
  const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

 bool try_lock_until(const xtime *_Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

private:
 mutex _My_mutex;
 condition_variable _My_cond;
 unsigned int _My_locked;
 };

class recursive_timed_mutex
 {
public:
 recursive_timed_mutex() noexcept
  : _My_locked(0)
  {
  }

 recursive_timed_mutex(const recursive_timed_mutex&) = delete;
 recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

 void lock()
  {
  thread::id _Tid = this_thread::get_id();

  unique_lock<mutex> _Lock(_My_mutex);

  if (_Tid == _My_owner)
   {
   if (_My_locked < 0xffffffff)
    ++_My_locked;
   else
    throw system_error(::std:: make_error_code(errc::device_or_resource_busy));

   }
  else
   {
   while (_My_locked != 0)
    _My_cond.wait(_Lock);
   _My_locked = 1;
   _My_owner = _Tid;
   }
  }

 bool try_lock() noexcept
  {
  thread::id _Tid = this_thread::get_id();

  lock_guard<mutex> _Lock(_My_mutex);

  if (_Tid == _My_owner)
   {
   if (_My_locked < 0xffffffff)
    ++_My_locked;
   else
    return (false);
   }
  else
   {
   if (_My_locked != 0)
    return (false);
   else
    {
    _My_locked = 1;
    _My_owner = _Tid;
    }
   }
  return (true);
 }

 void unlock()
  {
  bool _Do_notify = false;

   {
   lock_guard<mutex> _Lock(_My_mutex);
   --_My_locked;
   if (_My_locked == 0)
    {
    _Do_notify = true;
    _My_owner = thread::id();
    }
   }

  if (_Do_notify)
   _My_cond.notify_one();
  }

 template<class _Rep,
  class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
  {
  return (try_lock_until(chrono::steady_clock::now() + _Rel_time));
  }

 template<class _Time>
  bool _Try_lock_until(_Time _Abs_time)
  {
  thread::id _Tid = this_thread::get_id();

  unique_lock<mutex> _Lock(_My_mutex);

  if (_Tid == _My_owner)
   {
   if (_My_locked < 0xffffffff)
    ++_My_locked;
   else
    return (false);
   }
  else
   {
   if (!_My_cond.wait_until(_Lock, _Abs_time,
    [this] { return (_My_locked == 0); }))
     return (false);
   _My_locked = 1;
   _My_owner = _Tid;
   }
  return (true);
  }

 template<class _Clock,
  class _Duration>
  bool try_lock_until(
  const chrono::time_point<_Clock, _Duration>& _Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

 bool try_lock_until(const xtime *_Abs_time)
  {
  return (_Try_lock_until(_Abs_time));
  }

private:
 mutex _My_mutex;
 condition_variable _My_cond;
 unsigned int _My_locked;
 thread::id _My_owner;
 };
}

#pragma warning(pop)
#pragma pack(pop)
# 11 "./../xrCore/xrCore.h" 2
# 37 "./../xrCore/xrCore.h"
#pragma warning(disable: 4996)
# 56 "./../xrCore/xrCore.h"
#pragma warning(disable: 4530)
# 67 "./../xrCore/xrCore.h"
# 1 "./../xrCore/xrCore_platform.h" 1
# 44 "./../xrCore/xrCore_platform.h"
#pragma warning(push)
#pragma warning(disable: 4005)

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 1 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winapifamily.h" 1 3
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winapifamily.h" 3
#pragma warning(push)
#pragma warning(disable: 4001)





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winpackagefamily.h" 1 3
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winpackagefamily.h" 3
#pragma warning(push)
#pragma warning(disable: 4001)
# 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winpackagefamily.h" 3
#pragma warning(pop)
# 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winapifamily.h" 2 3
# 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winapifamily.h" 3
#pragma warning(pop)
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\sdkddkver.h" 1 3
# 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\sdkddkver.h" 3
#pragma warning(push)
#pragma warning(disable: 4668)

#pragma warning(disable: 4001)
# 300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\sdkddkver.h" 3
#pragma warning(pop)
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3
# 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 3
#pragma warning(disable: 4514)

#pragma warning(disable: 4103)


#pragma warning(push)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)


# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 1 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 2 3


#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 3
 extern "C" {




typedef enum _EXCEPTION_DISPOSITION
{
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;
# 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 3
        struct _EXCEPTION_RECORD;
        struct _CONTEXT;
        struct _DISPATCHER_CONTEXT;

        __declspec(dllimport) EXCEPTION_DISPOSITION __C_specific_handler(
                    struct _EXCEPTION_RECORD* ExceptionRecord,
                    void* EstablisherFrame,
                    struct _CONTEXT* ContextRecord,
                    struct _DISPATCHER_CONTEXT* DispatcherContext
            );
# 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 3
unsigned long __cdecl _exception_code(void);
void * __cdecl _exception_info(void);
int __cdecl _abnormal_termination(void);
# 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 3
}
# 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\excpt.h" 3
#pragma pack(pop)
# 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3

# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdarg.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdarg.h" 3
# 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\vcruntime.h" 1 3
# 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdarg.h" 2 3


#pragma pack(push, 8)
# 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdarg.h" 3
 extern "C" {
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdarg.h" 3
}
# 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdarg.h" 3
#pragma pack(pop)
# 168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 1 3
# 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
extern "C" {







# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 1 3
# 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 3
#pragma warning(push)
#pragma warning(disable: 4668)
# 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 3
extern "C" {
# 645 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 3
}
# 674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings_strict.h" 1 3
# 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings_strict.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings_undef.h" 1 3
# 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings_strict.h" 2 3
# 674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 2 3
# 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\driverspecs.h" 1 3
# 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\driverspecs.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/sdv_driverspecs.h" 1 3
# 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\driverspecs.h" 2 3








extern "C" {
# 897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\driverspecs.h" 3
}
# 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 2 3
# 711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\specstrings.h" 3
#pragma warning(pop)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 2 3
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
extern "C" {
# 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
# 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
typedef unsigned long DWORD;
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BOOL *PBOOL;
typedef BOOL *LPBOOL;
typedef BYTE *PBYTE;
typedef BYTE *LPBYTE;
typedef int *PINT;
typedef int *LPINT;
typedef WORD *PWORD;
typedef WORD *LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD;
typedef DWORD *LPDWORD;
typedef void *LPVOID;
typedef const void *LPCVOID;

typedef int INT;
typedef unsigned int UINT;
typedef unsigned int *PUINT;




# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 1 3
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
#pragma warning(push)
#pragma warning(disable: 4668)
#pragma warning(disable: 4820)

#pragma warning(disable: 4200)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)


extern "C" {



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 1 3
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
#pragma pack(push, 8)
# 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
 extern "C" {
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
               __declspec(dllimport) int __cdecl _isctype( int _C, int _Type);
               __declspec(dllimport) int __cdecl _isctype_l( int _C, int _Type, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isalpha( int _C);
               __declspec(dllimport) int __cdecl _isalpha_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isupper( int _C);
               __declspec(dllimport) int __cdecl _isupper_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl islower( int _C);
               __declspec(dllimport) int __cdecl _islower_l( int _C, _locale_t _Locale);


                                  __declspec(dllimport) int __cdecl isdigit( int _C);

               __declspec(dllimport) int __cdecl _isdigit_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isxdigit( int _C);
               __declspec(dllimport) int __cdecl _isxdigit_l( int _C, _locale_t _Locale);


                                  __declspec(dllimport) int __cdecl isspace( int _C);

               __declspec(dllimport) int __cdecl _isspace_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl ispunct( int _C);
               __declspec(dllimport) int __cdecl _ispunct_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isblank( int _C);
               __declspec(dllimport) int __cdecl _isblank_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isalnum( int _C);
               __declspec(dllimport) int __cdecl _isalnum_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isprint( int _C);
               __declspec(dllimport) int __cdecl _isprint_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isgraph( int _C);
               __declspec(dllimport) int __cdecl _isgraph_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iscntrl( int _C);
               __declspec(dllimport) int __cdecl _iscntrl_l( int _C, _locale_t _Locale);


                                  __declspec(dllimport) int __cdecl toupper( int _C);


                                  __declspec(dllimport) int __cdecl tolower( int _C);

                                  __declspec(dllimport) int __cdecl _tolower( int _C);
               __declspec(dllimport) int __cdecl _tolower_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl _toupper( int _C);
               __declspec(dllimport) int __cdecl _toupper_l( int _C, _locale_t _Locale);

               __declspec(dllimport) int __cdecl __isascii( int _C);
               __declspec(dllimport) int __cdecl __toascii( int _C);
               __declspec(dllimport) int __cdecl __iscsymf( int _C);
               __declspec(dllimport) int __cdecl __iscsym( int _C);
# 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }





    __inline int __cdecl _chvalidchk_l(
                 int const _C,
                 int const _Mask,
                 _locale_t const _Locale
        )
    {



        if (_Locale)
        {
            return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
        }

        return (__pctype_func()[(_C)] & (_Mask));

    }




    __inline int __cdecl _ischartype_l(
                 int const _C,
                 int const _Mask,
                 _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }
# 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
}
# 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\ctype.h" 3
#pragma pack(pop)
# 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\kernelspecs.h" 1 3
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\kernelspecs.h" 3
extern "C" {
# 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\kernelspecs.h" 3
}
# 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 1 3
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 3
#pragma warning(push)
#pragma warning(disable: 4668)




 typedef unsigned __int64 POINTER_64_INT;
# 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 3
extern "C" {


typedef signed char INT8, *PINT8;
typedef signed short INT16, *PINT16;
typedef signed int INT32, *PINT32;
typedef signed __int64 INT64, *PINT64;
typedef unsigned char UINT8, *PUINT8;
typedef unsigned short UINT16, *PUINT16;
typedef unsigned int UINT32, *PUINT32;
typedef unsigned __int64 UINT64, *PUINT64;





typedef signed int LONG32, *PLONG32;





typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
# 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 3
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
# 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 3
typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;


__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) (ULONG_PTR) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) (LONG_PTR) h );
}

__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void *p
    )
{
    return((unsigned long) (ULONG_PTR) p );
}

__inline
unsigned int
PtrToUint(
    const void *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}

__inline
unsigned short
PtrToUshort(
    const void *p
    )
{
    return((unsigned short) (unsigned long) (ULONG_PTR) p );
}

__inline
long
PtrToLong(
    const void *p
    )
{
    return((long) (LONG_PTR) p );
}

__inline
int
PtrToInt(
    const void *p
    )
{
    return((int) (INT_PTR) p );
}

__inline
short
PtrToShort(
    const void *p
    )
{
    return((short) (long) (LONG_PTR) p );
}

__inline
void *
IntToPtr(
    const int i
    )

{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )

{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )

{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )

{
    return( (void *)(ULONG_PTR)ul );
}






__inline
void *
Ptr32ToPtr(
    const void * __ptr32 p
    )
{
    return((void *) (ULONG_PTR) (unsigned long) p);
}

__inline
void *
Handle32ToHandle(
    const void * __ptr32 h
    )
{
    return((void *) (LONG_PTR) (long) h);
}

__inline
void * __ptr32
PtrToPtr32(
    const void *p
    )
{
    return((void * __ptr32) (unsigned long) (ULONG_PTR) p);
}
# 420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 3
typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;
# 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\basetsd.h" 3
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;





typedef __int64 LONG64, *PLONG64;






typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;







typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;




}



#pragma warning(pop)
# 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef void *PVOID;
typedef void * __ptr64 PVOID64;
# 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;
# 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef wchar_t WCHAR;





typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;

typedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef PWSTR *PZPWSTR;
typedef const PWSTR *PCZPWSTR;
typedef WCHAR __unaligned *LPUWSTR, *PUWSTR;
typedef const WCHAR *LPCWSTR, *PCWSTR;
typedef PCWSTR *PZPCWSTR;
typedef const PCWSTR *PCZPCWSTR;
typedef const WCHAR __unaligned *LPCUWSTR, *PCUWSTR;

typedef WCHAR *PZZWSTR;
typedef const WCHAR *PCZZWSTR;
typedef WCHAR __unaligned *PUZZWSTR;
typedef const WCHAR __unaligned *PCUZZWSTR;

typedef WCHAR *PNZWCH;
typedef const WCHAR *PCNZWCH;
typedef WCHAR __unaligned *PUNZWCH;
typedef const WCHAR __unaligned *PCUNZWCH;



typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR __unaligned *LPCUWCHAR, *PCUWCHAR;





typedef unsigned long UCSCHAR;
# 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR __unaligned *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR __unaligned *PCUUCSSTR;

typedef UCSCHAR __unaligned *PUUCSCHAR;
typedef const UCSCHAR __unaligned *PCUUCSCHAR;







typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef CHAR *NPSTR, *LPSTR, *PSTR;
typedef PSTR *PZPSTR;
typedef const PSTR *PCZPSTR;
typedef const CHAR *LPCSTR, *PCSTR;
typedef PCSTR *PZPCSTR;
typedef const PCSTR *PCZPCSTR;

typedef CHAR *PZZSTR;
typedef const CHAR *PCZZSTR;

typedef CHAR *PNZCH;
typedef const CHAR *PCNZCH;
# 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;



typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;






typedef SHORT *PSHORT;
typedef LONG *PLONG;
# 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _PROCESSOR_NUMBER {
    WORD Group;
    BYTE Number;
    BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;






typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD Group;
    WORD Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;
# 633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef void *HANDLE;
# 643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef HANDLE *PHANDLE;







typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;
# 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef long HRESULT;
# 731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef char CCHAR;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
# 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID
} COMPARTMENT_ID, *PCOMPARTMENT_ID;
# 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;
# 789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
# 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;



typedef LONGLONG USN;






typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    } ;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
    LONGLONG QuadPart;
} LARGE_INTEGER;


typedef LARGE_INTEGER *PLARGE_INTEGER;






typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } ;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
    ULONGLONG QuadPart;
} ULARGE_INTEGER;


typedef ULARGE_INTEGER *PULARGE_INTEGER;





typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;
typedef LONG RTL_REFERENCE_COUNT32, *PRTL_REFERENCE_COUNT32;
# 873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;


typedef ULONGLONG DWORDLONG;
typedef DWORDLONG *PDWORDLONG;
# 1017 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" {
# 1027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
unsigned char
__cdecl
_rotl8 (
         unsigned char Value,
         unsigned char Shift
    );

unsigned short
__cdecl
_rotl16 (
         unsigned short Value,
         unsigned char Shift
    );

unsigned char
__cdecl
_rotr8 (
         unsigned char Value,
         unsigned char Shift
    );

unsigned short
__cdecl
_rotr16 (
         unsigned short Value,
         unsigned char Shift
    );

#pragma intrinsic(_rotl8)
#pragma intrinsic(_rotl16)
#pragma intrinsic(_rotr8)
#pragma intrinsic(_rotr16)
# 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
unsigned int
__cdecl
_rotl (
         unsigned int Value,
         int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
         unsigned __int64 Value,
         int Shift
    );

unsigned int
__cdecl
_rotr (
         unsigned int Value,
         int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
         unsigned __int64 Value,
         int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)




}






typedef BYTE BOOLEAN;
typedef BOOLEAN *PBOOLEAN;





typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;






typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
# 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\guiddef.h" 1 3
# 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\guiddef.h" 3
typedef struct _GUID {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
} GUID;
# 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\guiddef.h" 3
typedef GUID *LPGUID;




typedef const GUID *LPCGUID;





typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;
# 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\guiddef.h" 3
__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
# 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\guiddef.h" 3
__inline bool operator==(const GUID & guidOne, const GUID & guidOther)
{
    return !!IsEqualGUID(guidOne,guidOther);
}

__inline bool operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
# 1153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3





typedef struct _OBJECTID {
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
# 1250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C++"
template <typename T, size_t N>
char (*RtlpNumberOf( __unaligned T (&)[N] ))[N];
# 1378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef


EXCEPTION_DISPOSITION
__stdcall
EXCEPTION_ROUTINE (
            struct _EXCEPTION_RECORD *ExceptionRecord,
         PVOID EstablisherFrame,
            struct _CONTEXT *ContextRecord,
         PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;
# 2368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C++" {

    template <size_t S>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE;

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
    {
        typedef INT8 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
    {
        typedef INT16 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
    {
        typedef INT32 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<8>
    {
        typedef INT64 type;
    };


    template <class T>
    struct _ENUM_FLAG_SIZED_INTEGER
    {
        typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
    };

}
# 2513 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;







typedef struct __declspec(align(16)) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;





typedef struct __declspec(align(16)) _XSAVE_FORMAT {
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];



    M128A XmmRegisters[16];
    BYTE Reserved4[96];
# 2559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
} XSAVE_FORMAT, *PXSAVE_FORMAT;



typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 CompactionMask;
    DWORD64 Reserved2[6];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct __declspec(align(16)) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
                                   PXSAVE_AREA Area;





    PVOID Buffer;





} XSTATE_CONTEXT, *PXSTATE_CONTEXT;





typedef struct _SCOPE_TABLE_AMD64 {
    DWORD Count;
    struct {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;
# 2618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" {
# 2648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
BOOLEAN
_bittest (
                                   LONG const *Base,
                     LONG Offset
    );

BOOLEAN
_bittestandcomplement (
                                        LONG *Base,
                     LONG Offset
    );

BOOLEAN
_bittestandset (
                                        LONG *Base,
                     LONG Offset
    );

BOOLEAN
_bittestandreset (
                                        LONG *Base,
                     LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
                                                              LONG volatile *Base,
                     LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
                                                              LONG volatile *Base,
                     LONG Offset
    );

BOOLEAN
_bittest64 (
                                   LONG64 const *Base,
                     LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
                                        LONG64 *Base,
                     LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
                                        LONG64 *Base,
                     LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
                                        LONG64 *Base,
                     LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
                                                              LONG64 volatile *Base,
                     LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
                                                              LONG64 volatile *Base,
                     LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)
# 2744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
BOOLEAN
_BitScanForward (
          DWORD *Index,
         DWORD Mask
    );


BOOLEAN
_BitScanReverse (
          DWORD *Index,
         DWORD Mask
    );


BOOLEAN
_BitScanForward64 (
          DWORD *Index,
         DWORD64 Mask
    );


BOOLEAN
_BitScanReverse64 (
          DWORD *Index,
         DWORD64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)
# 2884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
SHORT
_InterlockedIncrement16 (
                                  SHORT volatile *Addend
    );

SHORT
_InterlockedDecrement16 (
                                  SHORT volatile *Addend
    );

SHORT
_InterlockedCompareExchange16 (
                                  SHORT volatile *Destination,
         SHORT ExChange,
         SHORT Comperand
    );

LONG
_InterlockedAnd (
                                  LONG volatile *Destination,
         LONG Value
    );

LONG
_InterlockedOr (
                                  LONG volatile *Destination,
         LONG Value
    );

LONG
_InterlockedXor (
                                  LONG volatile *Destination,
         LONG Value
    );

LONG64
_InterlockedAnd64 (
                                  LONG64 volatile *Destination,
         LONG64 Value
    );

LONG64
_InterlockedOr64 (
                                  LONG64 volatile *Destination,
         LONG64 Value
    );

LONG64
_InterlockedXor64 (
                                  LONG64 volatile *Destination,
         LONG64 Value
    );

LONG
_InterlockedIncrement (
                                  LONG volatile *Addend
    );

LONG
_InterlockedDecrement (
                                  LONG volatile *Addend
    );

LONG
_InterlockedExchange (
                                  LONG volatile *Target,
         LONG Value
    );

LONG
_InterlockedExchangeAdd (
                                  LONG volatile *Addend,
         LONG Value
    );



__forceinline
LONG
_InlineInterlockedAdd (
                                  LONG volatile *Addend,
         LONG Value
    )

{
    return _InterlockedExchangeAdd(Addend, Value) + Value;
}



LONG
_InterlockedCompareExchange (
                                  LONG volatile *Destination,
         LONG ExChange,
         LONG Comperand
    );

LONG64
_InterlockedIncrement64 (
                                  LONG64 volatile *Addend
    );

LONG64
_InterlockedDecrement64 (
                                  LONG64 volatile *Addend
    );

LONG64
_InterlockedExchange64 (
                                  LONG64 volatile *Target,
         LONG64 Value
    );

LONG64
_InterlockedExchangeAdd64 (
                                  LONG64 volatile *Addend,
         LONG64 Value
    );



__forceinline
LONG64
_InlineInterlockedAdd64 (
                                  LONG64 volatile *Addend,
         LONG64 Value
    )

{
    return _InterlockedExchangeAdd64(Addend, Value) + Value;
}



LONG64
_InterlockedCompareExchange64 (
                                  LONG64 volatile *Destination,
         LONG64 ExChange,
         LONG64 Comperand
    );

BOOLEAN
_InterlockedCompareExchange128 (
                                  LONG64 volatile *Destination,
         LONG64 ExchangeHigh,
         LONG64 ExchangeLow,
            LONG64 *ComparandResult
    );

                                       PVOID
_InterlockedCompareExchangePointer (



                          PVOID volatile *Destination,
             PVOID Exchange,
             PVOID Comperand
    );

                                       PVOID
_InterlockedExchangePointer(



                          PVOID volatile *Target,
             PVOID Value
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)



#pragma intrinsic(_InterlockedCompareExchange128)



#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)






CHAR
_InterlockedExchange8 (
                                  CHAR volatile *Target,
         CHAR Value
    );

SHORT
_InterlockedExchange16 (
                                  SHORT volatile *Destination,
         SHORT ExChange
    );

#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)
# 3113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
char
_InterlockedExchangeAdd8 (
                                  char volatile * _Addend,
         char _Value
    );

char
_InterlockedAnd8 (
                                  char volatile *Destination,
         char Value
    );

char
_InterlockedOr8 (
                                  char volatile *Destination,
         char Value
    );

char
_InterlockedXor8 (
                                  char volatile *Destination,
         char Value
    );

SHORT
_InterlockedAnd16(
                                  SHORT volatile *Destination,
         SHORT Value
    );

SHORT
_InterlockedOr16(
                                  SHORT volatile *Destination,
         SHORT Value
    );

SHORT
_InterlockedXor16(
                                  SHORT volatile *Destination,
         SHORT Value
    );

#pragma intrinsic (_InterlockedExchangeAdd8)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)
# 3173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
void
__cpuidex (
    int CPUInfo[4],
    int Function,
    int SubLeaf
    );

#pragma intrinsic(__cpuidex)
# 3190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
void
_mm_clflush (
         void const *Address
    );

#pragma intrinsic(_mm_clflush)




void
_ReadWriteBarrier (
    void
    );

#pragma intrinsic(_ReadWriteBarrier)
# 3223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
void
__faststorefence (
    void
    );




void
_mm_lfence (
    void
    );

void
_mm_mfence (
    void
    );

void
_mm_sfence (
    void
    );

void
_mm_pause (
    void
    );

void
_mm_prefetch (
         CHAR const *a,
         int sel
    );

void
_m_prefetchw (
         volatile const void *Source
    );
# 3274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
#pragma intrinsic(__faststorefence)




#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)
# 3308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
unsigned int
_mm_getcsr (
    void
    );

void
_mm_setcsr (
         unsigned int MxCsr
    );

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)







unsigned __int32
__getcallerseflags (
    void
    );

#pragma intrinsic(__getcallerseflags)







DWORD
__segmentlimit (
         DWORD Selector
    );

#pragma intrinsic(__segmentlimit)







DWORD64
__readpmc (
         DWORD Counter
    );

#pragma intrinsic(__readpmc)







DWORD64
__rdtsc (
    void
    );

#pragma intrinsic(__rdtsc)





void
__movsb (
                            PBYTE Destination,
                      BYTE const *Source,
         SIZE_T Count
    );

void
__movsw (
                            PWORD Destination,
                      WORD const *Source,
         SIZE_T Count
    );

void
__movsd (
                            PDWORD Destination,
                      DWORD const *Source,
         SIZE_T Count
    );

void
__movsq (
                            PDWORD64 Destination,
                      DWORD64 const *Source,
         SIZE_T Count
    );

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)





void
__stosb (
                            PBYTE Destination,
         BYTE Value,
         SIZE_T Count
    );

void
__stosw (
                            PWORD Destination,
         WORD Value,
         SIZE_T Count
    );

void
__stosd (
                            PDWORD Destination,
         DWORD Value,
         SIZE_T Count
    );

void
__stosq (
                            PDWORD64 Destination,
         DWORD64 Value,
         SIZE_T Count
    );

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)








LONGLONG
__mulh (
         LONG64 Multiplier,
         LONG64 Multiplicand
    );

ULONGLONG
__umulh (
         DWORD64 Multiplier,
         DWORD64 Multiplicand
    );

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)







DWORD64
__popcnt64 (
         DWORD64 operand
    );



#pragma intrinsic(__popcnt64)
# 3493 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
DWORD64
__shiftleft128 (
         DWORD64 LowPart,
         DWORD64 HighPart,
         BYTE Shift
    );

DWORD64
__shiftright128 (
         DWORD64 LowPart,
         DWORD64 HighPart,
         BYTE Shift
    );

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)







LONG64
_mul128 (
         LONG64 Multiplier,
         LONG64 Multiplicand,
          LONG64 *HighProduct
    );

#pragma intrinsic(_mul128)





DWORD64
_umul128 (
         DWORD64 Multiplier,
         DWORD64 Multiplicand,
          DWORD64 *HighProduct
    );

#pragma intrinsic(_umul128)



__forceinline
LONG64
MultiplyExtract128 (
         LONG64 Multiplier,
         LONG64 Multiplicand,
         BYTE Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    DWORD64 uhighProduct;
    DWORD64 ulowProduct;

    lowProduct = _mul128(Multiplier, Multiplicand, &highProduct);
    negate = 0;
    uhighProduct = (DWORD64)highProduct;
    ulowProduct = (DWORD64)lowProduct;
    if (highProduct < 0) {
        negate = 1;
        uhighProduct = (DWORD64)(-highProduct);
        ulowProduct = (DWORD64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64)__shiftright128(ulowProduct, uhighProduct, Shift);
    if (negate != 0) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}

__forceinline
DWORD64
UnsignedMultiplyExtract128 (
         DWORD64 Multiplier,
         DWORD64 Multiplicand,
         BYTE Shift
    )

{

    DWORD64 extractedProduct;
    DWORD64 highProduct;
    DWORD64 lowProduct;

    lowProduct = _umul128(Multiplier, Multiplicand, &highProduct);
    extractedProduct = __shiftright128(lowProduct, highProduct, Shift);
    return extractedProduct;
}





BYTE
__readgsbyte (
         DWORD Offset
    );

WORD
__readgsword (
         DWORD Offset
    );

DWORD
__readgsdword (
         DWORD Offset
    );

DWORD64
__readgsqword (
         DWORD Offset
    );

void
__writegsbyte (
         DWORD Offset,
         BYTE Data
    );

void
__writegsword (
         DWORD Offset,
         WORD Data
    );

void
__writegsdword (
         DWORD Offset,
         DWORD Data
    );

void
__writegsqword (
         DWORD Offset,
         DWORD64 Data
    );

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)



void
__incgsbyte (
         DWORD Offset
    );

void
__addgsbyte (
         DWORD Offset,
         BYTE Value
    );

void
__incgsword (
         DWORD Offset
    );

void
__addgsword (
         DWORD Offset,
         WORD Value
    );

void
__incgsdword (
         DWORD Offset
    );

void
__addgsdword (
         DWORD Offset,
         DWORD Value
    );

void
__incgsqword (
         DWORD Offset
    );

void
__addgsqword (
         DWORD Offset,
         DWORD64 Value
    );
# 3715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
}
# 3783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;
# 3820 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct __declspec(align(16)) _CONTEXT {
# 3829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;





    DWORD ContextFlags;
    DWORD MxCsr;





    WORD SegCs;
    WORD SegDs;
    WORD SegEs;
    WORD SegFs;
    WORD SegGs;
    WORD SegSs;
    DWORD EFlags;





    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;





    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;





    DWORD64 Rip;





    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        } ;
    } ;





    M128A VectorRegister[26];
    DWORD64 VectorControl;





    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
} CONTEXT, *PCONTEXT;






typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
typedef SCOPE_TABLE_AMD64 SCOPE_TABLE, *PSCOPE_TABLE;
# 3966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE {
    DWORD Count;
    BYTE LocalHint;
    BYTE GlobalHint;
    BYTE Search;
    BYTE Once;
    DWORD64 LowAddress;
    DWORD64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[12];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;





typedef

PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK (
         DWORD64 ControlPc,
             PVOID Context
    );
typedef GET_RUNTIME_FUNCTION_CALLBACK *PGET_RUNTIME_FUNCTION_CALLBACK;

typedef

DWORD
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
         HANDLE Process,
         PVOID TableAddress,
          PDWORD Entries,
          PRUNTIME_FUNCTION* Functions
    );
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK *POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;
# 4013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _DISPATCHER_CONTEXT {
    DWORD64 ControlPc;
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    DWORD64 EstablisherFrame;
    DWORD64 TargetIp;
    PCONTEXT ContextRecord;
    PEXCEPTION_ROUTINE LanguageHandler;
    PVOID HandlerData;
    PUNWIND_HISTORY_TABLE HistoryTable;
    DWORD ScopeIndex;
    DWORD Fill0;
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;





struct _EXCEPTION_POINTERS;
typedef
LONG
(*PEXCEPTION_FILTER) (
    struct _EXCEPTION_POINTERS *ExceptionPointers,
    PVOID EstablisherFrame
    );

typedef
void
(*PTERMINATION_HANDLER) (
    BOOLEAN _abnormal_termination,
    PVOID EstablisherFrame
    );






typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    union {
        PM128A FloatingContext[16];
        struct {
            PM128A Xmm0;
            PM128A Xmm1;
            PM128A Xmm2;
            PM128A Xmm3;
            PM128A Xmm4;
            PM128A Xmm5;
            PM128A Xmm6;
            PM128A Xmm7;
            PM128A Xmm8;
            PM128A Xmm9;
            PM128A Xmm10;
            PM128A Xmm11;
            PM128A Xmm12;
            PM128A Xmm13;
            PM128A Xmm14;
            PM128A Xmm15;
        } ;
    } ;

    union {
        PDWORD64 IntegerContext[16];
        struct {
            PDWORD64 Rax;
            PDWORD64 Rcx;
            PDWORD64 Rdx;
            PDWORD64 Rbx;
            PDWORD64 Rsp;
            PDWORD64 Rbp;
            PDWORD64 Rsi;
            PDWORD64 Rdi;
            PDWORD64 R8;
            PDWORD64 R9;
            PDWORD64 R10;
            PDWORD64 R11;
            PDWORD64 R12;
            PDWORD64 R13;
            PDWORD64 R14;
            PDWORD64 R15;
        } ;
    } ;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;







typedef struct _SCOPE_TABLE_ARM {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;
# 5076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _SCOPE_TABLE_ARM64 {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM64, *PSCOPE_TABLE_ARM64;
# 6251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {

    PDWORD64 X19;
    PDWORD64 X20;
    PDWORD64 X21;
    PDWORD64 X22;
    PDWORD64 X23;
    PDWORD64 X24;
    PDWORD64 X25;
    PDWORD64 X26;
    PDWORD64 X27;
    PDWORD64 X28;
    PDWORD64 Fp;
    PDWORD64 Lr;

    PDWORD64 D8;
    PDWORD64 D9;
    PDWORD64 D10;
    PDWORD64 D11;
    PDWORD64 D12;
    PDWORD64 D13;
    PDWORD64 D14;
    PDWORD64 D15;

} KNONVOLATILE_CONTEXT_POINTERS_ARM64, *PKNONVOLATILE_CONTEXT_POINTERS_ARM64;
# 6299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" {
# 6325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
void
__int2c (
    void
    );

#pragma intrinsic(__int2c)
# 6449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
}
# 7617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1;
            BYTE Flags2;
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;
# 7651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" {


__forceinline
CHAR
ReadAcquire8 (
                               CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
CHAR
ReadNoFence8 (
                               CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease8 (
                                CHAR volatile *Destination,
         CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence8 (
                                CHAR volatile *Destination,
         CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
SHORT
ReadAcquire16 (
                               SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
SHORT
ReadNoFence16 (
                               SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease16 (
                                SHORT volatile *Destination,
         SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence16 (
                                SHORT volatile *Destination,
         SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG
ReadAcquire (
                               LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG
ReadNoFence (
                               LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease (
                                LONG volatile *Destination,
         LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence (
                                LONG volatile *Destination,
         LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG64
ReadAcquire64 (
                               LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG64
ReadNoFence64 (
                               LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease64 (
                                LONG64 volatile *Destination,
         LONG64 Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence64 (
                                LONG64 volatile *Destination,
         LONG64 Value
    )

{

    *Destination = Value;
    return;
}


}
# 7880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__forceinline
CHAR
ReadRaw8 (
                               CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *(CHAR *)Source;
    return Value;
}

__forceinline
void
WriteRaw8 (
                                CHAR volatile *Destination,
         CHAR Value
    )

{

    *(CHAR *)Destination = Value;
    return;
}

__forceinline
SHORT
ReadRaw16 (
                               SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *(SHORT *)Source;
    return Value;
}

__forceinline
void
WriteRaw16 (
                                SHORT volatile *Destination,
         SHORT Value
    )

{

    *(SHORT *)Destination = Value;
    return;
}

__forceinline
LONG
ReadRaw (
                               LONG const volatile *Source
    )

{

    LONG Value;

    Value = *(LONG *)Source;
    return Value;
}

__forceinline
void
WriteRaw (
                                LONG volatile *Destination,
         LONG Value
    )

{

    *(LONG *)Destination = Value;
    return;
}

__forceinline
LONG64
ReadRaw64 (
                               LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *(LONG64 *)Source;
    return Value;
}

__forceinline
void
WriteRaw64 (
                                LONG64 volatile *Destination,
         LONG64 Value
    )

{

    *(LONG64 *)Destination = Value;
    return;
}





__forceinline
BYTE
ReadUCharAcquire (
                               BYTE const volatile *Source
    )

{

    return (BYTE )ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE
ReadUCharNoFence (
                               BYTE const volatile *Source
    )

{

    return (BYTE )ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE
ReadBooleanAcquire (
                               BOOLEAN const volatile *Source
    )

{

    return (BOOLEAN)ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE
ReadBooleanNoFence (
                               BOOLEAN const volatile *Source
    )

{

    return (BOOLEAN)ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE
ReadUCharRaw (
                               BYTE const volatile *Source
    )

{

    return (BYTE )ReadRaw8((PCHAR)Source);
}

__forceinline
void
WriteUCharRelease (
                                BYTE volatile *Destination,
         BYTE Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharNoFence (
                                BYTE volatile *Destination,
         BYTE Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteBooleanRelease (
                                BOOLEAN volatile *Destination,
         BOOLEAN Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteBooleanNoFence (
                                BOOLEAN volatile *Destination,
         BOOLEAN Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharRaw (
                                BYTE volatile *Destination,
         BYTE Value
    )

{

    WriteRaw8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
WORD
ReadUShortAcquire (
                               WORD const volatile *Source
    )

{

    return (WORD )ReadAcquire16((PSHORT)Source);
}

__forceinline
WORD
ReadUShortNoFence (
                               WORD const volatile *Source
    )

{

    return (WORD )ReadNoFence16((PSHORT)Source);
}

__forceinline
WORD
ReadUShortRaw (
                               WORD const volatile *Source
    )

{

    return (WORD )ReadRaw16((PSHORT)Source);
}

__forceinline
void
WriteUShortRelease (
                                WORD volatile *Destination,
         WORD Value
    )

{

    WriteRelease16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortNoFence (
                                WORD volatile *Destination,
         WORD Value
    )

{

    WriteNoFence16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortRaw (
                                WORD volatile *Destination,
         WORD Value
    )

{

    WriteRaw16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
DWORD
ReadULongAcquire (
                               DWORD const volatile *Source
    )

{

    return (DWORD)ReadAcquire((PLONG)Source);
}

__forceinline
DWORD
ReadULongNoFence (
                               DWORD const volatile *Source
    )

{

    return (DWORD)ReadNoFence((PLONG)Source);
}

__forceinline
DWORD
ReadULongRaw (
                               DWORD const volatile *Source
    )

{

    return (DWORD)ReadRaw((PLONG)Source);
}

__forceinline
void
WriteULongRelease (
                                DWORD volatile *Destination,
         DWORD Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongNoFence (
                                DWORD volatile *Destination,
         DWORD Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongRaw (
                                DWORD volatile *Destination,
         DWORD Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
DWORD64
ReadULong64Acquire (
                               DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadAcquire64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64NoFence (
                               DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadNoFence64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64Raw (
                               DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WriteULong64Release (
                                DWORD64 volatile *Destination,
         DWORD64 Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64NoFence (
                                DWORD64 volatile *Destination,
         DWORD64 Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64Raw (
                                DWORD64 volatile *Destination,
         DWORD64 Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}
# 8440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__forceinline
PVOID
ReadPointerAcquire (
                               PVOID const volatile *Source
    )

{

    return (PVOID)ReadAcquire64((PLONG64)Source);
}

__forceinline
PVOID
ReadPointerNoFence (
                               PVOID const volatile *Source
    )

{

    return (PVOID)ReadNoFence64((PLONG64)Source);
}

__forceinline
PVOID
ReadPointerRaw (
                               PVOID const volatile *Source
    )

{

    return (PVOID)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WritePointerRelease (
                                PVOID volatile *Destination,
         PVOID Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WritePointerNoFence (
                                PVOID volatile *Destination,
         PVOID Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WritePointerRaw (
                                PVOID volatile *Destination,
         PVOID Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}
# 8578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack4.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack4.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,4)
# 8592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 8604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _WOW64_CONTEXT {
# 8624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
    DWORD ContextFlags;







    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;






    WOW64_FLOATING_SAVE_AREA FloatSave;






    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;






    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;






    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;







    BYTE ExtendedRegisters[512];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 8692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3



typedef struct _WOW64_LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1;
            BYTE Flags2;
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;
# 8746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;





typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
# 8804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef PVOID PSID;
typedef PVOID PCLAIMS_BLOB;
# 8848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;
# 8907 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;
# 8926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,4)
# 8926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3


typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 8935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 8970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;





typedef struct _SID {
   BYTE Revision;
   BYTE SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1];

} SID, *PISID;
# 9018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef union _SE_SID {
    SID Sid;
    BYTE Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
} SE_SID, *PSE_SID;




typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    SidTypeLogonSession
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {



    PSID Sid;

    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;


typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;
# 9458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum {

    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
} WELL_KNOWN_SID_TYPE;
# 9676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ACL {
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
} ACL;
typedef ACL *PACL;
# 9706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ACE_HEADER {
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;
# 9835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;

typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;

typedef struct _SYSTEM_ACCESS_FILTER_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_ACCESS_FILTER_ACE, *PSYSTEM_ACCESS_FILTER_ACE;
# 9912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;






typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;
# 10035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;






typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;





typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;
# 10086 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;
# 10176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE Revision;
   BYTE Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;


typedef struct _SECURITY_OBJECT_AI_PARAMS {
    DWORD Size;
    DWORD ConstraintMask;
} SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;
# 10253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _OBJECT_TYPE_LIST {
    WORD Level;
    WORD Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;
# 10273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;
# 10327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;
# 10348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone = 0x00000000,






    AccessReasonAllowedAce = 0x00010000,
    AccessReasonDeniedAce = 0x00020000,

    AccessReasonAllowedParentAce = 0x00030000,
    AccessReasonDeniedParentAce = 0x00040000,

    AccessReasonNotGrantedByCape = 0x00050000,
    AccessReasonNotGrantedByParentCape = 0x00060000,

    AccessReasonNotGrantedToAppContainer = 0x00070000,

    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,


    AccessReasonIntegrityLevel = 0x00300000,

    AccessReasonOwnership = 0x00400000,

    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,

    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000,

    AccessReasonTrustLabel = 0x00900000,

    AccessReasonFilterAce = 0x00a00000
}
ACCESS_REASON_TYPE;
# 10401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;
# 10432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount;
    PACCESS_MASK GrantedAccess;
    PDWORD AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;
# 10537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;
# 10619 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;







typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;






typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    TokenPrivateNameSpace,
    TokenSingletonAttributes,
    TokenBnoIsolation,
    TokenChildProcessFlags,
    MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;





typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;



typedef struct _SE_TOKEN_USER {
    union {
        TOKEN_USER TokenUser;
        SID_AND_ATTRIBUTES User;
    } ;

    union {
        SID Sid;
        BYTE Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
    } ;

} SE_TOKEN_USER , PSE_TOKEN_USER;






typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;



    SID_AND_ATTRIBUTES Groups[1];

} TOKEN_GROUPS, *PTOKEN_GROUPS;

typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;





typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_USER_CLAIMS {
    PCLAIMS_BLOB UserClaims;
} TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;

typedef struct _TOKEN_DEVICE_CLAIMS {
    PCLAIMS_BLOB DeviceClaims;
} TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;
# 10795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef PVOID PSECURITY_ATTRIBUTES_OPAQUE;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
    DWORD AppContainerNumber;
    PSID PackageSid;
    PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    PSID TrustLevelSid;
    PSECURITY_ATTRIBUTES_OPAQUE SecurityAttributes;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;







typedef struct _TOKEN_AUDIT_POLICY {
    BYTE PerUserPolicy[(((59)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;



typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

typedef struct _TOKEN_APPCONTAINER_INFORMATION {
    PSID TokenAppContainer;
} TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;





typedef struct _TOKEN_SID_INFORMATION {
    PSID Sid;
} TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;

typedef struct _TOKEN_BNO_ISOLATION_INFORMATION {
    PWSTR IsolationPrefix;
    BOOLEAN IsolationEnabled;
} TOKEN_BNO_ISOLATION_INFORMATION, *PTOKEN_BNO_ISOLATION_INFORMATION;
# 10918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    DWORD64 Version;
    PWSTR Name;
} CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
# 10930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    PVOID pValue;
    DWORD ValueLength;
} CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
# 11002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {






    PWSTR Name;





    WORD ValueType;






    WORD Reserved;





    DWORD Flags;





    DWORD ValueCount;





    union {
        PLONG64 pInt64;
        PDWORD64 pUint64;
        PWSTR *ppString;
        PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;






typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {






    DWORD Name;





    WORD ValueType;






    WORD Reserved;





    DWORD Flags;





    DWORD ValueCount;





    union {
        DWORD pInt64[1];
        DWORD pUint64[1];
        DWORD ppString[1];
        DWORD pFqbn[1];
        DWORD pOctetString[1];
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
# 11121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {





    WORD Version;





    WORD Reserved;

    DWORD AttributeCount;
    union {
        PCLAIM_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;
# 11148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;







typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;






typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;






typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
# 11204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef BYTE SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;
# 11228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _SE_IMAGE_SIGNATURE_TYPE
{
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded,
    SeImageSignatureCache,
    SeImageSignatureCatalogCached,
    SeImageSignatureCatalogNotCached,
    SeImageSignatureCatalogHint,
    SeImageSignaturePackageCatalog,
} SE_IMAGE_SIGNATURE_TYPE, *PSE_IMAGE_SIGNATURE_TYPE;






typedef enum _SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
} SE_LEARNING_MODE_DATA_TYPE;



typedef struct _SECURITY_CAPABILITIES {




    PSID AppContainerSid;
    PSID_AND_ATTRIBUTES Capabilities;

    DWORD CapabilityCount;
    DWORD Reserved;
} SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;
# 11318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;
    DWORD MemberLevel;
    DWORD Flags;
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;




typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;

    union {
        PVOID FiberData;
        DWORD Version;
    };



    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;




typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;


    union {
        DWORD FiberData;
        DWORD Version;
    };




    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;


    union {
        DWORD64 FiberData;
        DWORD Version;
    };





    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
# 11403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {
    DWORD UmsVersion;
        PVOID UmsContext;
        PVOID UmsCompletionList;
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES;

typedef struct _WOW64_ARCHITECTURE_INFORMATION {
    DWORD Machine : 16;
    DWORD KernelMode : 1;
    DWORD UserMode : 1;
    DWORD Native : 1;
    DWORD Process : 1;
    DWORD ReservedZero0 : 12;
} WOW64_ARCHITECTURE_INFORMATION;
# 11431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;







typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0 : 25;
    } ;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;




typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;






typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        } ;
    } ;
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;

typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;

typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD RaiseExceptionOnInvalidHandleReference : 1;
            DWORD HandleExceptionsPermanentlyEnabled : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableExtensionPoints : 1;
            DWORD ReservedFlags : 31;
        } ;
    } ;
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } ;
    } ;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;

typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD ReservedFlags : 29;
        } ;
    } ;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;

typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } ;
    } ;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;

typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        } ;
    } ;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } ;
    } ;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD FilterId: 4;
            DWORD ReservedFlags : 28;
        } ;
    } ;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;

typedef struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableExportAddressFilter : 1;
            DWORD AuditExportAddressFilter : 1;

            DWORD EnableExportAddressFilterPlus : 1;
            DWORD AuditExportAddressFilterPlus : 1;

            DWORD EnableImportAddressFilter : 1;
            DWORD AuditImportAddressFilter : 1;

            DWORD EnableRopStackPivot : 1;
            DWORD AuditRopStackPivot : 1;

            DWORD EnableRopCallerCheck : 1;
            DWORD AuditRopCallerCheck : 1;

            DWORD EnableRopSimExec : 1;
            DWORD AuditRopSimExec : 1;

            DWORD ReservedFlags : 20;
        } ;
    } ;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;

typedef struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoChildProcessCreation : 1;
            DWORD AuditNoChildProcessCreation : 1;
            DWORD AllowSecureProcessCreation : 1;
            DWORD ReservedFlags : 29;
        } ;
    } ;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY;


typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;


typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;





typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
} JOBOBJECT_RATE_CONTROL_TOLERANCE, *PJOBOBJECT_RATE_CONTROL_TOLERANCE;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
} JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;

typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    DWORD LimitFlags;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;

typedef struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
            CpuRateControlToleranceInterval;
    } ;

    DWORD LimitFlags;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL IoRateControlToleranceInterval;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL NetRateControlToleranceInterval;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2;


typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;

typedef struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    } ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlToleranceLimit;
    } ;

    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlToleranceLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2;


typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    DWORD ControlFlags;
    union {
        DWORD CpuRate;
        DWORD Weight;
        struct {
            WORD MinRate;
            WORD MaxRate;
        } ;
    } ;
} JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;





typedef enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
} JOB_OBJECT_NET_RATE_CONTROL_FLAGS;



extern "C++" { inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator | (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator |= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator & (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator &= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator ~ (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator ^ (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator ^= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } }
typedef char __C_ASSERT__[(JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS == (JOB_OBJECT_NET_RATE_CONTROL_ENABLE + JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH + JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG))?1:-1];
# 11888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    DWORD64 MaxBandwidth;
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    BYTE DscpTag;
} JOBOBJECT_NET_RATE_CONTROL_INFORMATION;
# 11901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE |
                                             JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME
} JOB_OBJECT_IO_RATE_CONTROL_FLAGS;



extern "C++" { inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator | (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator |= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator & (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator &= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator ~ (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator ^ (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator ^= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } }



typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD VolumeNameLength;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;

typedef JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1;

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
    LONG64 SoftMaxIops;
    LONG64 SoftMaxBandwidth;
    LONG64 SoftMaxTimePercent;
    LONG64 LimitExcessNotifyIops;
    LONG64 LimitExcessNotifyBandwidth;
    LONG64 LimitExcessNotifyTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;



typedef enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
} JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS;

typedef struct _JOBOBJECT_IO_ATTRIBUTION_STATS {

    ULONG_PTR IoCount;
    ULONGLONG TotalNonOverlappedQueueTime;
    ULONGLONG TotalNonOverlappedServiceTime;
    ULONGLONG TotalSize;

} JOBOBJECT_IO_ATTRIBUTION_STATS, *PJOBOBJECT_IO_ATTRIBUTION_STATS;

typedef struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    DWORD ControlFlags;

    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;

} JOBOBJECT_IO_ATTRIBUTION_INFORMATION, *PJOBOBJECT_IO_ATTRIBUTION_INFORMATION;
# 12117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    JobObjectReserved10Information,
    JobObjectReserved11Information,
    JobObjectReserved12Information,
    JobObjectReserved13Information,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation,
    JobObjectNotificationLimitInformation2,
    JobObjectLimitViolationInformation2,
    JobObjectCreateSilo,
    JobObjectSiloBasicInformation,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;



typedef struct _SILOOBJECT_BASIC_INFORMATION {
    DWORD SiloId;
    DWORD SiloParentId;
    DWORD NumberOfProcesses;
    BOOLEAN IsInServerSilo;
    BYTE Reserved[3];
} SILOOBJECT_BASIC_INFORMATION, *PSILOOBJECT_BASIC_INFORMATION;

typedef enum _SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED,
    SERVERSILO_SHUTTING_DOWN,
    SERVERSILO_TERMINATING,
    SERVERSILO_TERMINATED,
} SERVERSILO_STATE, *PSERVERSILO_STATE;

typedef struct _SERVERSILO_BASIC_INFORMATION {
    DWORD ServiceSessionId;
    SERVERSILO_STATE State;
    DWORD ExitStatus;
} SERVERSILO_BASIC_INFORMATION, *PSERVERSILO_BASIC_INFORMATION;


typedef enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
} FIRMWARE_TYPE, *PFIRMWARE_TYPE;
# 12232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;



typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;



typedef struct _CACHE_DESCRIPTOR {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG Reserved[2];
    } ;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE Flags;
    BYTE EfficiencyClass;
    BYTE Reserved[20];
    WORD GroupCount;
                             GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

                          struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } ;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

typedef enum _CPU_SET_INFORMATION_TYPE {
    CpuSetInformation
} CPU_SET_INFORMATION_TYPE, *PCPU_SET_INFORMATION_TYPE;

                          struct _SYSTEM_CPU_SET_INFORMATION {
    DWORD Size;
    CPU_SET_INFORMATION_TYPE Type;
    union {
        struct {
            DWORD Id;
            WORD Group;
            BYTE LogicalProcessorIndex;
            BYTE CoreIndex;
            BYTE LastLevelCacheIndex;
            BYTE NumaNodeIndex;
            BYTE EfficiencyClass;
            union {






                BYTE AllFlags;
                struct {
                    BYTE Parked : 1;
                    BYTE Allocated : 1;
                    BYTE AllocatedToTargetProcess : 1;
                    BYTE RealTime : 1;
                    BYTE ReservedFlags : 4;
                } ;
            } ;
            DWORD Reserved;
            DWORD64 AllocationTag;
        } CpuSet;
    } ;
};

typedef struct _SYSTEM_CPU_SET_INFORMATION SYSTEM_CPU_SET_INFORMATION, *PSYSTEM_CPU_SET_INFORMATION;



typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
# 12529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {

    DWORD64 EnabledFeatures;


    DWORD64 EnabledVolatileFeatures;


    DWORD Size;


    union {
        DWORD ControlFlags;
        struct
        {
            DWORD OptimizedSave : 1;
            DWORD CompactionEnabled : 1;
        };
    };


    XSTATE_FEATURE Features[(64)];


    DWORD64 EnabledSupervisorFeatures;


    DWORD64 AlignedFeatures;


    DWORD AllFeatureSize;


    DWORD AllFeatures[(64)];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;



typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;



typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD AllocationProtect;
    DWORD __alignment1;
    ULONGLONG RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
    DWORD __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
# 12635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _CFG_CALL_TARGET_INFO {
    ULONG_PTR Offset;
    ULONG_PTR Flags;
} CFG_CALL_TARGET_INFO, *PCFG_CALL_TARGET_INFO;
# 12714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ENCLAVE_CREATE_INFO_SGX {
    BYTE Secs[4096];
} ENCLAVE_CREATE_INFO_SGX, *PENCLAVE_CREATE_INFO_SGX;

typedef struct _ENCLAVE_INIT_INFO_SGX {
    BYTE SigStruct[1808];
    BYTE Reserved1[240];
    BYTE EInitToken[304];
    BYTE Reserved2[1744];
} ENCLAVE_INIT_INFO_SGX, *PENCLAVE_INIT_INFO_SGX;



typedef struct _ENCLAVE_CREATE_INFO_VBS {
    DWORD Flags;
    BYTE OwnerID[32];
} ENCLAVE_CREATE_INFO_VBS, *PENCLAVE_CREATE_INFO_VBS;




typedef struct _ENCLAVE_INIT_INFO_VBS {
    DWORD Length;
    DWORD ThreadCount;
} ENCLAVE_INIT_INFO_VBS, *PENCLAVE_INIT_INFO_VBS;



typedef PVOID (ENCLAVE_TARGET_FUNCTION)(PVOID);
typedef ENCLAVE_TARGET_FUNCTION (*PENCLAVE_TARGET_FUNCTION);
typedef PENCLAVE_TARGET_FUNCTION LPENCLAVE_TARGET_FUNCTION;
# 12886 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _FILE_ID_128 {
    BYTE Identifier[16];
} FILE_ID_128, *PFILE_ID_128;





typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;


typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastModificationTime;
    LARGE_INTEGER LastChangeTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER AllocatedLength;
    LARGE_INTEGER FileSize;
    DWORD FileAttributes;
    DWORD ReparsePointTag;
    LARGE_INTEGER FileId;
    LARGE_INTEGER ParentFileId;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;







typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
# 12999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD ReparseTag;
    WORD ReparseDataLength;
    WORD Reserved;
    GUID ReparseGuid;
    struct {
        BYTE DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;
# 13515 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_MAX_POWER_SAVINGS;






extern "C" const GUID GUID_MIN_POWER_SAVINGS;






extern "C" const GUID GUID_TYPICAL_POWER_SAVINGS;







extern "C" const GUID NO_SUBGROUP_GUID;







extern "C" const GUID ALL_POWERSCHEMES_GUID;
# 13582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_POWERSCHEME_PERSONALITY;
# 13591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_ACTIVE_POWERSCHEME;
# 13606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_IDLE_RESILIENCY_SUBGROUP;







extern "C" const GUID GUID_IDLE_RESILIENCY_PERIOD;





extern "C" const GUID GUID_DEEP_SLEEP_ENABLED;
# 13629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_DEEP_SLEEP_PLATFORM_STATE;






extern "C" const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT;
# 13649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT;
# 13660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_VIDEO_SUBGROUP;







extern "C" const GUID GUID_VIDEO_POWERDOWN_TIMEOUT;
# 13677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT;
# 13686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;







extern "C" const GUID GUID_VIDEO_DIM_TIMEOUT;







extern "C" const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN;






extern "C" const GUID GUID_MONITOR_POWER_ON;






extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;






extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;






extern "C" const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;







extern "C" const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;






extern "C" const GUID GUID_CONSOLE_DISPLAY_STATE;







extern "C" const GUID GUID_ALLOW_DISPLAY_REQUIRED;
# 13762 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT;






extern "C" const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP;






extern "C" const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT;






extern "C" const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE;







extern "C" const GUID GUID_DISK_SUBGROUP;




extern "C" const GUID GUID_DISK_MAX_POWER;





extern "C" const GUID GUID_DISK_POWERDOWN_TIMEOUT;






extern "C" const GUID GUID_DISK_IDLE_TIMEOUT;
# 13818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_DISK_BURST_IGNORE_THRESHOLD;





extern "C" const GUID GUID_DISK_ADAPTIVE_POWERDOWN;
# 13833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_SLEEP_SUBGROUP;







extern "C" const GUID GUID_SLEEP_IDLE_THRESHOLD;





extern "C" const GUID GUID_STANDBY_TIMEOUT;
# 13856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_UNATTEND_SLEEP_TIMEOUT;





extern "C" const GUID GUID_HIBERNATE_TIMEOUT;





extern "C" const GUID GUID_HIBERNATE_FASTS4_POLICY;
# 13877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_CRITICAL_POWER_TRANSITION;





extern "C" const GUID GUID_SYSTEM_AWAYMODE;






extern "C" const GUID GUID_ALLOW_AWAYMODE;






extern "C" const GUID GUID_USER_PRESENCE_PREDICTION;






extern "C" const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD;






extern "C" const GUID GUID_STANDBY_BUDGET_PERCENT;






extern "C" const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD;






extern "C" const GUID GUID_STANDBY_RESERVE_TIME;






extern "C" const GUID GUID_STANDBY_RESET_PERCENT;







extern "C" const GUID GUID_ALLOW_STANDBY_STATES;






extern "C" const GUID GUID_ALLOW_RTC_WAKE;






extern "C" const GUID GUID_LEGACY_RTC_MITIGATION;







extern "C" const GUID GUID_ALLOW_SYSTEM_REQUIRED;
# 13971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_POWER_SAVING_STATUS;







extern "C" const GUID GUID_ENERGY_SAVER_SUBGROUP;






extern "C" const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD;






extern "C" const GUID GUID_ENERGY_SAVER_BRIGHTNESS;






extern "C" const GUID GUID_ENERGY_SAVER_POLICY;
# 14009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_SYSTEM_BUTTON_SUBGROUP;
# 14030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_POWERBUTTON_ACTION;





extern "C" const GUID GUID_SLEEPBUTTON_ACTION;






extern "C" const GUID GUID_USERINTERFACEBUTTON_ACTION;





extern "C" const GUID GUID_LIDCLOSE_ACTION;
extern "C" const GUID GUID_LIDOPEN_POWERSTATE;
# 14059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_BATTERY_SUBGROUP;
# 14071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_0;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_1;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_2;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_3;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_3;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_3;
# 14096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP;





extern "C" const GUID GUID_PROCESSOR_THROTTLE_POLICY;
# 14120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM;
# 14130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1;
# 14140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM;
# 14150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM_1;






extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT;



extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT_1;
# 14170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_ALLOW_THROTTLING;
# 14180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_IDLESTATE_POLICY;





extern "C" const GUID GUID_PROCESSOR_PERFSTATE_POLICY;







extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;
# 14203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1;







extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;
# 14220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1;







extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY;
# 14237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY_1;







extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY;
# 14254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY_1;
# 14263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME;
# 14272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME_1;
# 14281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME;
# 14290 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME_1;







extern "C" const GUID GUID_PROCESSOR_PERF_TIME_CHECK;







extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_POLICY;
# 14318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_MODE;
# 14336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_MODE;
# 14347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE;
# 14358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW;
# 14368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_DUTY_CYCLING;
# 14380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING;






extern "C" const GUID GUID_PROCESSOR_IDLE_DISABLE;
# 14396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_IDLE_STATE_MAXIMUM;
# 14405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_IDLE_TIME_CHECK;
# 14414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;
# 14431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;
# 14440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;
# 14460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES;







extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES;







extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE;







extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE;







extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE_1;







extern "C" const GUID GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY;







extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY_1;
# 14626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_HISTORY;
# 14636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_HISTORY;
# 14646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY;
# 14656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT;






extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF;







extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1;







extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK;







extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1;







extern "C" const GUID GUID_PROCESSOR_DISTRIBUTE_UTILITY;
# 14706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_HETEROGENEOUS_POLICY;







extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_TIME;







extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_TIME;
# 14731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD;
# 14740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD;
# 14749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_CLASS0_FLOOR_PERF;
# 14758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_CLASS1_INITIAL_PERF;






extern "C" const GUID GUID_PROCESSOR_THREAD_SCHEDULING_POLICY;
# 14774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY;
# 14783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_SYSTEM_COOLING_POLICY;
# 14793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_LOCK_CONSOLE_ON_WAKE;
# 14803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_DEVICE_IDLE_POLICY;
# 14812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_CONNECTIVITY_IN_STANDBY;
# 14822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_DISCONNECTED_STANDBY_MODE;
# 14843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_ACDC_POWER_SOURCE;
# 14859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_LIDSWITCH_STATE_CHANGE;
# 14876 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_BATTERY_PERCENTAGE_REMAINING;
# 14889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_BATTERY_COUNT;






extern "C" const GUID GUID_GLOBAL_USER_PRESENCE;
# 14907 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_SESSION_DISPLAY_STATUS;
# 14917 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_SESSION_USER_PRESENCE;






extern "C" const GUID GUID_IDLE_BACKGROUND_TASK;






extern "C" const GUID GUID_BACKGROUND_TASK_NOTIFICATION;







extern "C" const GUID GUID_APPLAUNCH_BUTTON;
# 14950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP;





extern "C" const GUID GUID_PCIEXPRESS_ASPM_POLICY;
# 14968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;






extern "C" const GUID GUID_INTSTEER_SUBGROUP;



extern "C" const GUID GUID_INTSTEER_MODE;



extern "C" const GUID GUID_INTSTEER_LOAD_PER_PROC_TRIGGER;



extern "C" const GUID GUID_INTSTEER_TIME_UNPARK_TRIGGER;
# 14999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID GUID_MIXED_REALITY_MODE;



typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;



typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
    PowerActionDisplayOff
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;

typedef enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
} USER_ACTIVITY_PRESENCE, *PUSER_ACTIVITY_PRESENCE;
# 15059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;
# 15083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;
# 15109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct CM_Power_Data_s {
    DWORD PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    DWORD PD_Capabilities;
    DWORD PD_D1Latency;
    DWORD PD_D2Latency;
    DWORD PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;





typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,
    LastSleepTime,
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    SystemMonitorHiberBootPowerOff,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    ProcessorIdleStatesHv,
    ProcessorPerfStatesHv,
    ProcessorPerfCapHv,
    ProcessorSetIdle,
    LogicalProcessorIdling,
    UserPresence,
    PowerSettingNotificationName,
    GetPowerSettingValue,
    IdleResiliency,
    SessionRITState,
    SessionConnectNotification,
    SessionPowerCleanup,
    SessionLockState,
    SystemHiberbootState,
    PlatformInformation,
    PdcInvocation,
    MonitorInvocation,
    FirmwareTableInformationRegistered,
    SetShutdownSelectedTime,
    SuspendResumeInvocation,
    PlmPowerRequestCreate,
    ScreenOff,
    CsDeviceNotification,
    PlatformRole,
    LastResumePerformance,
    DisplayBurst,
    ExitLatencySamplingPercentage,
    RegisterSpmPowerSettings,
    PlatformIdleStates,
    ProcessorIdleVeto,
    PlatformIdleVeto,
    SystemBatteryStatePrecise,
    ThermalEvent,
    PowerRequestActionInternal,
    BatteryDeviceState,
    PowerInformationInternal,
    ThermalStandby,
    SystemHiberFileType,
    PhysicalPowerButtonPress,
    QueryPotentialDripsConstraint,
    EnergyTrackerCreate,
    EnergyTrackerQuery,
    UpdateBlackBoxRecorder,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;





typedef enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
} POWER_USER_PRESENCE_TYPE, *PPOWER_USER_PRESENCE_TYPE;

typedef struct _POWER_USER_PRESENCE {
    POWER_USER_PRESENCE_TYPE UserPresence;
} POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;




typedef struct _POWER_SESSION_CONNECT {
    BOOLEAN Connected;
    BOOLEAN Console;
} POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;

typedef struct _POWER_SESSION_TIMEOUTS {
    DWORD InputTimeout;
    DWORD DisplayTimeout;
} POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;




typedef struct _POWER_SESSION_RIT_STATE {
    BOOLEAN Active;
    DWORD LastInputTime;
} POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;




typedef struct _POWER_SESSION_WINLOGON {
    DWORD SessionId;
    BOOLEAN Console;
    BOOLEAN Locked;
} POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;




typedef struct _POWER_IDLE_RESILIENCY {
    DWORD CoalescingTimeout;
    DWORD IdleResiliencyPeriod;
} POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;




typedef enum {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonGracePeriod,
    MonitorRequestReasonPnP,
    MonitorRequestReasonDP,
    MonitorRequestReasonSxTransition,
    MonitorRequestReasonSystemIdle,
    MonitorRequestReasonNearProximity,
    MonitorRequestReasonThermalStandby,
    MonitorRequestReasonResumePdc,
    MonitorRequestReasonResumeS4,
    MonitorRequestReasonTerminal,
    MonitorRequestReasonPdcSignal,
    MonitorRequestReasonAcDcDisplayBurstSuppressed,
    MonitorRequestReasonSystemStateEntered,


    MonitorRequestReasonWinrt,
    MonitorRequestReasonUserInputKeyboard,
    MonitorRequestReasonUserInputMouse,
    MonitorRequestReasonUserInputTouch,
    MonitorRequestReasonUserInputPen,
    MonitorRequestReasonUserInputAccelerometer,
    MonitorRequestReasonUserInputHid,
    MonitorRequestReasonUserInputPoUserPresent,
    MonitorRequestReasonUserInputSessionSwitch,
    MonitorRequestReasonUserInputInitialization,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,
    MonitorRequestReasonPdcSignalWindowsMobileShell,
    MonitorRequestReasonPdcSignalHeyCortana,
    MonitorRequestReasonPdcSignalHolographicShell,
    MonitorRequestReasonMax
} POWER_MONITOR_REQUEST_REASON;

typedef enum _POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn
} POWER_MONITOR_REQUEST_TYPE;




typedef struct _POWER_MONITOR_INVOCATION {
    BOOLEAN Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;





typedef struct _RESUME_PERFORMANCE {
    DWORD PostTimeMs;
    ULONGLONG TotalResumeTimeMs;
    ULONGLONG ResumeCompleteTimestamp;
} RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;





typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {





    DWORD Version;





    GUID Guid;






    SYSTEM_POWER_CONDITION PowerCondition;




    DWORD DataLength;




    BYTE Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;



typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;






typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {





    LARGE_INTEGER ActivationTime;




    DWORD Flags;




    DWORD ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;





typedef enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleSlate,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE, *PPOWER_PLATFORM_ROLE;
# 15462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _POWER_PLATFORM_INFORMATION {
    BOOLEAN AoAc;
} POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;






typedef struct {
    DWORD Granularity;
    DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;




typedef struct {
    DWORD Frequency;
    DWORD Flags;
    DWORD PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE PromotePercent;
    BYTE DemotePercent;
    BYTE StateType;
    BYTE Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;
    DWORD OldState;
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;
    DWORD OldState;
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency;
    DWORD Power;
    BYTE PercentFrequency;
    BYTE IncreaseLevel;
    BYTE DecreaseLevel;
    BYTE Type;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD64 Control;
    DWORD64 Status;
    DWORD HitCount;
    DWORD Reserved1;
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;
    DWORD MaxPerfState;
    DWORD MinPerfState;
    DWORD LowestPerfState;
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType;
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;
    DWORD MaxPerfState;
    DWORD MinPerfState;
    DWORD LowestPerfState;
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType;
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;







typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;







typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD AbortCount;
    DWORD64 StartTime;
                             PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;
# 15698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
extern "C" const GUID PPM_PERFSTATE_CHANGE_GUID;



extern "C" const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID;



extern "C" const GUID PPM_IDLESTATE_CHANGE_GUID;



extern "C" const GUID PPM_PERFSTATES_DATA_GUID;



extern "C" const GUID PPM_IDLESTATES_DATA_GUID;



extern "C" const GUID PPM_IDLE_ACCOUNTING_GUID;



extern "C" const GUID PPM_IDLE_ACCOUNTING_EX_GUID;



extern "C" const GUID PPM_THERMALCONSTRAINT_GUID;



extern "C" const GUID PPM_PERFMON_PERFSTATE_GUID;



extern "C" const GUID PPM_THERMAL_POLICY_CHANGE_GUID;



typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable: 4121)

typedef struct {
    BYTE Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)




typedef struct {
    POWER_ACTION Action;
    DWORD Flags;
    DWORD EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
# 15816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct {
    BOOLEAN Enable;
    BYTE Spare[3];
    DWORD BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;
# 15831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _SYSTEM_POWER_POLICY {
    DWORD Revision;


    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    DWORD Reserved;


    POWER_ACTION_POLICY Idle;
    DWORD IdleTimeout;
    BYTE IdleSensitivity;

    BYTE DynamicThrottle;
    BYTE Spare2[2];


    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    DWORD WinLogonFlags;

    DWORD Spare3;



    DWORD DozeS4Timeout;


    DWORD BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy[4];


    DWORD VideoTimeout;
    BOOLEAN VideoDimDisplay;
    DWORD VideoReserved[3];


    DWORD SpindownTimeout;


    BOOLEAN OptimizeForPower;
    BYTE FanThrottleTolerance;
    BYTE ForcedThrottle;
    BYTE MinThrottle;
    POWER_ACTION_POLICY OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;
# 15891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct {
    DWORD TimeCheck;
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD Revision;
    union {
        WORD AsWORD ;
        struct {
            WORD AllowScaling : 1;
            WORD Disabled : 1;
            WORD Reserved : 14;
        } ;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;
# 15926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _PROCESSOR_POWER_POLICY_INFO {


    DWORD TimeCheck;
    DWORD DemoteLimit;
    DWORD PromoteLimit;


    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];


    DWORD AllowDemotion:1;
    DWORD AllowPromotion:1;
    DWORD Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;


typedef struct _PROCESSOR_POWER_POLICY {
    DWORD Revision;


    BYTE DynamicThrottle;
    BYTE Spare[3];


    DWORD DisableCStates:1;
    DWORD Reserved:31;




    DWORD PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;





typedef struct {
    DWORD Revision;
    BYTE MaxThrottle;
    BYTE MinThrottle;
    BYTE BusyAdjThreshold;
    union {
        BYTE Spare;
        union {
            BYTE AsBYTE ;
            struct {
                BYTE NoDomainAccounting : 1;
                BYTE IncreasePolicy: 2;
                BYTE DecreasePolicy: 2;
                BYTE Reserved : 3;
            } ;
        } Flags;
    } ;

    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;


typedef struct _ADMINISTRATOR_POWER_POLICY {


    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;


    DWORD MinVideoTimeout;
    DWORD MaxVideoTimeout;


    DWORD MinSpindownTimeout;
    DWORD MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef enum _HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB,
    HiberFileBucket4GB,
    HiberFileBucket8GB,
    HiberFileBucket16GB,
    HiberFileBucket32GB,
    HiberFileBucketUnlimited,
    HiberFileBucketMax
} HIBERFILE_BUCKET_SIZE, *PHIBERFILE_BUCKET_SIZE;






typedef struct _HIBERFILE_BUCKET {
    DWORD64 MaxPhysicalMemory;
    DWORD PhysicalMemoryPercent[0x03];
} HIBERFILE_BUCKET, *PHIBERFILE_BUCKET;

typedef struct {

    BOOLEAN PowerButtonPresent;
    BOOLEAN SleepButtonPresent;
    BOOLEAN LidPresent;
    BOOLEAN SystemS1;
    BOOLEAN SystemS2;
    BOOLEAN SystemS3;
    BOOLEAN SystemS4;
    BOOLEAN SystemS5;
    BOOLEAN HiberFilePresent;
    BOOLEAN FullWake;
    BOOLEAN VideoDimPresent;
    BOOLEAN ApmPresent;
    BOOLEAN UpsPresent;


    BOOLEAN ThermalControl;
    BOOLEAN ProcessorThrottle;
    BYTE ProcessorMinThrottle;





    BYTE ProcessorMaxThrottle;
    BOOLEAN FastSystemS4;
    BOOLEAN Hiberboot;
    BOOLEAN WakeAlarmPresent;
    BOOLEAN AoAc;



    BOOLEAN DiskSpinDown;


    BYTE spare3[8];
# 16077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
    BOOLEAN SystemBatteriesPresent;
    BOOLEAN BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];


    SYSTEM_POWER_STATE AcOnLineWake;
    SYSTEM_POWER_STATE SoftLidWake;
    SYSTEM_POWER_STATE RtcWake;
    SYSTEM_POWER_STATE MinDeviceWakeState;
    SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN AcOnLine;
    BOOLEAN BatteryPresent;
    BOOLEAN Charging;
    BOOLEAN Discharging;
    BOOLEAN Spare1[3];

    BYTE Tag;

    DWORD MaxCapacity;
    DWORD RemainingCapacity;
    DWORD Rate;
    DWORD EstimatedTime;

    DWORD DefaultAlert1;
    DWORD DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;
# 16116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,4)
# 16116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3








# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack2.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack2.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,2)
# 16124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 16136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {
    WORD ne_magic;
    CHAR ne_ver;
    CHAR ne_rev;
    WORD ne_enttab;
    WORD ne_cbenttab;
    LONG ne_crc;
    WORD ne_flags;
    WORD ne_autodata;
    WORD ne_heap;
    WORD ne_stack;
    LONG ne_csip;
    LONG ne_sssp;
    WORD ne_cseg;
    WORD ne_cmod;
    WORD ne_cbnrestab;
    WORD ne_segtab;
    WORD ne_rsrctab;
    WORD ne_restab;
    WORD ne_modtab;
    WORD ne_imptab;
    LONG ne_nrestab;
    WORD ne_cmovent;
    WORD ne_align;
    WORD ne_cres;
    BYTE ne_exetyp;
    BYTE ne_flagsothers;
    WORD ne_pretthunks;
    WORD ne_psegrefbytes;
    WORD ne_swaparea;
    WORD ne_expver;
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {
    WORD e32_magic;
    BYTE e32_border;
    BYTE e32_worder;
    DWORD e32_level;
    WORD e32_cpu;
    WORD e32_os;
    DWORD e32_ver;
    DWORD e32_mflags;
    DWORD e32_mpages;
    DWORD e32_startobj;
    DWORD e32_eip;
    DWORD e32_stackobj;
    DWORD e32_esp;
    DWORD e32_pagesize;
    DWORD e32_lastpagesize;
    DWORD e32_fixupsize;
    DWORD e32_fixupsum;
    DWORD e32_ldrsize;
    DWORD e32_ldrsum;
    DWORD e32_objtab;
    DWORD e32_objcnt;
    DWORD e32_objmap;
    DWORD e32_itermap;
    DWORD e32_rsrctab;
    DWORD e32_rsrccnt;
    DWORD e32_restab;
    DWORD e32_enttab;
    DWORD e32_dirtab;
    DWORD e32_dircnt;
    DWORD e32_fpagetab;
    DWORD e32_frectab;
    DWORD e32_impmod;
    DWORD e32_impmodcnt;
    DWORD e32_impproc;
    DWORD e32_pagesum;
    DWORD e32_datapage;
    DWORD e32_preload;
    DWORD e32_nrestab;
    DWORD e32_cbnrestab;
    DWORD e32_nressum;
    DWORD e32_autodata;
    DWORD e32_debuginfo;
    DWORD e32_debuglen;
    DWORD e32_instpreload;
    DWORD e32_instdemand;
    DWORD e32_heapsize;
    BYTE e32_res3[12];
    DWORD e32_winresoff;
    DWORD e32_winreslen;
    WORD e32_devid;
    WORD e32_ddkver;
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 16246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3







typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
# 16319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;







typedef struct _IMAGE_OPTIONAL_HEADER {




    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;





    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD BaseOfBss;
    DWORD GprMask;
    DWORD CprMask[4];
    DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;






typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;







typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;


typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
# 16528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct ANON_OBJECT_HEADER {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
    DWORD Flags;
    DWORD MetaDataSize;
    DWORD MetaDataOffset;
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {

    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
    DWORD Flags;
    DWORD MetaDataSize;
    DWORD MetaDataOffset;


    DWORD NumberOfSections;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;







typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union {
            DWORD PhysicalAddress;
            DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
# 16656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack2.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack2.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,2)
# 16656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3







typedef struct _IMAGE_SYMBOL {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short;
            DWORD Long;
        } Name;
        DWORD LongName[2];
    } N;
    DWORD Value;
    SHORT SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL __unaligned *PIMAGE_SYMBOL;



typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short;
            DWORD Long;
        } Name;
        DWORD LongName[2];
    } N;
    DWORD Value;
    LONG SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX __unaligned *PIMAGE_SYMBOL_EX;
# 16819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack2.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack2.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,2)
# 16819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3


typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE bAuxType;
    BYTE bReserved;
    DWORD SymbolTableIndex;
    BYTE rgbReserved[12];
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF __unaligned *PIMAGE_AUX_SYMBOL_TOKEN_DEF;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 16830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3






typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD TagIndex;
        union {
            struct {
                WORD Linenumber;
                WORD Size;
            } LnSz;
           DWORD TotalSize;
        } Misc;
        union {
            struct {
                DWORD PointerToLinenumber;
                DWORD PointerToNextFunction;
            } Function;
            struct {
                WORD Dimension[4];
            } Array;
        } FcnAry;
        WORD TvIndex;
    } Sym;
    struct {
        BYTE Name[18];
    } File;
    struct {
        DWORD Length;
        WORD NumberOfRelocations;
        WORD NumberOfLinenumbers;
        DWORD CheckSum;
        SHORT Number;
        BYTE Selection;
 BYTE bReserved;
 SHORT HighNumber;
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL __unaligned *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD WeakDefaultSymIndex;
        DWORD WeakSearchType;
        BYTE rgbReserved[12];
    } Sym;
    struct {
        BYTE Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD Length;
        WORD NumberOfRelocations;
        WORD NumberOfLinenumbers;
        DWORD CheckSum;
        SHORT Number;
        BYTE Selection;
        BYTE bReserved;
        SHORT HighNumber;
        BYTE rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE rgbReserved[2];
    } ;
    struct {
        DWORD crc;
        BYTE rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX __unaligned *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;
# 16935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_RELOCATION {
    union {
        DWORD VirtualAddress;
        DWORD RelocCount;
    } ;
    DWORD SymbolTableIndex;
    WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION __unaligned *PIMAGE_RELOCATION;
# 17337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD SymbolTableIndex;
        DWORD VirtualAddress;
    } Type;
    WORD Linenumber;
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER __unaligned *PIMAGE_LINENUMBER;



# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 17347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3







typedef struct _IMAGE_BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;

} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION __unaligned * PIMAGE_BASE_RELOCATION;
# 17403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE Name[16];
    BYTE Date[12];
    BYTE UserID[6];
    BYTE GroupID[6];
    BYTE Mode[8];
    BYTE Size[10];
    BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
# 17423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;





typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    CHAR Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack8.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack8.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,8)
# 17446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3


typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 17458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3


typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
# 17481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;
    ULONGLONG AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD StartAddressOfRawData;
    DWORD EndAddressOfRawData;
    DWORD AddressOfIndex;
    DWORD AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;




typedef IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64 PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;
# 17543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    } ;
    DWORD TimeDateStamp;




    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR __unaligned *PIMAGE_IMPORT_DESCRIPTOR;





typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD NumberOfModuleForwarderRefs;

} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;
            DWORD ReservedAttributes : 31;
        } ;
    } Attributes;

    DWORD DllNameRVA;
    DWORD ModuleHandleRVA;
    DWORD ImportAddressTableRVA;
    DWORD ImportNameTableRVA;
    DWORD BoundImportAddressTableRVA;
    DWORD UnloadInformationTableRVA;
    DWORD TimeDateStamp;


} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR;
# 17616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    WORD NumberOfNamedEntries;
    WORD NumberOfIdEntries;

} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
# 17643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } ;
        DWORD Name;
        WORD Id;
    } ;
    union {
        DWORD OffsetToData;
        struct {
            DWORD OffsetToDirectory:31;
            DWORD DataIsDirectory:1;
        } ;
    } ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;
# 17670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD Length;
    CHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD Length;
    WCHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;
# 17691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;







typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    WORD Flags;
    WORD Catalog;
    DWORD CatalogOffset;
    DWORD Reserved;
} IMAGE_LOAD_CONFIG_CODE_INTEGRITY, *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY;





typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
    DWORD Version;
    DWORD Size;

} IMAGE_DYNAMIC_RELOCATION_TABLE, *PIMAGE_DYNAMIC_RELOCATION_TABLE;






# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack1.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack1.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,1)
# 17725 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3


typedef struct _IMAGE_DYNAMIC_RELOCATION32 {
    DWORD Symbol;
    DWORD BaseRelocSize;

} IMAGE_DYNAMIC_RELOCATION32, *PIMAGE_DYNAMIC_RELOCATION32;

typedef struct _IMAGE_DYNAMIC_RELOCATION64 {
    ULONGLONG Symbol;
    DWORD BaseRelocSize;

} IMAGE_DYNAMIC_RELOCATION64, *PIMAGE_DYNAMIC_RELOCATION64;

typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
    DWORD HeaderSize;
    DWORD FixupInfoSize;
    DWORD Symbol;
    DWORD SymbolGroup;
    DWORD Flags;


} IMAGE_DYNAMIC_RELOCATION32_V2, *PIMAGE_DYNAMIC_RELOCATION32_V2;

typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
    DWORD HeaderSize;
    DWORD FixupInfoSize;
    ULONGLONG Symbol;
    DWORD SymbolGroup;
    DWORD Flags;


} IMAGE_DYNAMIC_RELOCATION64_V2, *PIMAGE_DYNAMIC_RELOCATION64_V2;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 17759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3



typedef IMAGE_DYNAMIC_RELOCATION64 IMAGE_DYNAMIC_RELOCATION;
typedef PIMAGE_DYNAMIC_RELOCATION64 PIMAGE_DYNAMIC_RELOCATION;
typedef IMAGE_DYNAMIC_RELOCATION64_V2 IMAGE_DYNAMIC_RELOCATION_V2;
typedef PIMAGE_DYNAMIC_RELOCATION64_V2 PIMAGE_DYNAMIC_RELOCATION_V2;
# 17780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack1.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared/pshpack1.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,1)
# 17780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3


typedef struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    BYTE PrologueByteCount;

} IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER __unaligned * PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;

typedef struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    DWORD EpilogueCount;
    BYTE EpilogueByteCount;
    BYTE BranchDescriptorElementSize;
    WORD BranchDescriptorCount;


} IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER __unaligned * PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 17798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3






typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    DWORD DeCommitFreeBlockThreshold;
    DWORD DeCommitTotalFreeThreshold;
    DWORD LockPrefixTable;
    DWORD MaximumAllocationSize;
    DWORD VirtualMemoryThreshold;
    DWORD ProcessHeapFlags;
    DWORD ProcessAffinityMask;
    WORD CSDVersion;
    WORD DependentLoadFlags;
    DWORD EditList;
    DWORD SecurityCookie;
    DWORD SEHandlerTable;
    DWORD SEHandlerCount;
    DWORD GuardCFCheckFunctionPointer;
    DWORD GuardCFDispatchFunctionPointer;
    DWORD GuardCFFunctionTable;
    DWORD GuardCFFunctionCount;
    DWORD GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    DWORD GuardAddressTakenIatEntryTable;
    DWORD GuardAddressTakenIatEntryCount;
    DWORD GuardLongJumpTargetTable;
    DWORD GuardLongJumpTargetCount;
    DWORD DynamicValueRelocTable;
    DWORD CHPEMetadataPointer;
    DWORD GuardRFFailureRoutine;
    DWORD GuardRFFailureRoutineFunctionPointer;
    DWORD DynamicValueRelocTableOffset;
    WORD DynamicValueRelocTableSection;
    WORD Reserved2;
    DWORD GuardRFVerifyStackPointerFunctionPointer;
    DWORD HotPatchTableOffset;
    DWORD Reserved3;
    DWORD EnclaveConfigurationPointer;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    ULONGLONG DeCommitFreeBlockThreshold;
    ULONGLONG DeCommitTotalFreeThreshold;
    ULONGLONG LockPrefixTable;
    ULONGLONG MaximumAllocationSize;
    ULONGLONG VirtualMemoryThreshold;
    ULONGLONG ProcessAffinityMask;
    DWORD ProcessHeapFlags;
    WORD CSDVersion;
    WORD DependentLoadFlags;
    ULONGLONG EditList;
    ULONGLONG SecurityCookie;
    ULONGLONG SEHandlerTable;
    ULONGLONG SEHandlerCount;
    ULONGLONG GuardCFCheckFunctionPointer;
    ULONGLONG GuardCFDispatchFunctionPointer;
    ULONGLONG GuardCFFunctionTable;
    ULONGLONG GuardCFFunctionCount;
    DWORD GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    ULONGLONG GuardAddressTakenIatEntryTable;
    ULONGLONG GuardAddressTakenIatEntryCount;
    ULONGLONG GuardLongJumpTargetTable;
    ULONGLONG GuardLongJumpTargetCount;
    ULONGLONG DynamicValueRelocTable;
    ULONGLONG CHPEMetadataPointer;
    ULONGLONG GuardRFFailureRoutine;
    ULONGLONG GuardRFFailureRoutineFunctionPointer;
    DWORD DynamicValueRelocTableOffset;
    WORD DynamicValueRelocTableSection;
    WORD Reserved2;
    ULONGLONG GuardRFVerifyStackPointerFunctionPointer;
    DWORD HotPatchTableOffset;
    DWORD Reserved3;
    ULONGLONG EnclaveConfigurationPointer;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;





typedef IMAGE_LOAD_CONFIG_DIRECTORY64 IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64 PIMAGE_LOAD_CONFIG_DIRECTORY;







typedef struct _IMAGE_HOT_PATCH_INFO {
    DWORD Version;
    DWORD Size;
    DWORD SequenceNumber;
    DWORD BaseImageList;
    DWORD BaseImageCount;
    DWORD BufferOffset;
} IMAGE_HOT_PATCH_INFO, *PIMAGE_HOT_PATCH_INFO;

typedef struct _IMAGE_HOT_PATCH_BASE {
    DWORD SequenceNumber;
    DWORD Flags;
    DWORD OriginalTimeDateStamp;
    DWORD OriginalCheckSum;
    DWORD CodeIntegrityInfo;
    DWORD CodeIntegritySize;
    DWORD PatchTable;
    DWORD BufferOffset;
} IMAGE_HOT_PATCH_BASE, *PIMAGE_HOT_PATCH_BASE;

typedef struct _IMAGE_HOT_PATCH_HASHES {
    BYTE SHA256[32];
    BYTE SHA1[20];
} IMAGE_HOT_PATCH_HASHES, *PIMAGE_HOT_PATCH_HASHES;
# 17981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD Ret : 2;
            DWORD H : 1;
            DWORD Reg : 3;
            DWORD R : 1;
            DWORD L : 1;
            DWORD C : 1;
            DWORD StackAdjust : 10;
        } ;
    } ;
} IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD RegF : 3;
            DWORD RegI : 4;
            DWORD H : 1;
            DWORD CR : 2;
            DWORD FrameSize : 9;
        } ;
    } ;
} IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    } ;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
# 18075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;
# 18087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_ENCLAVE_CONFIG32 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE FamilyID[16];
    BYTE ImageID[16];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    DWORD EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG32, *PIMAGE_ENCLAVE_CONFIG32;

typedef struct _IMAGE_ENCLAVE_CONFIG64 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE FamilyID[16];
    BYTE ImageID[16];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    ULONGLONG EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG64, *PIMAGE_ENCLAVE_CONFIG64;


typedef IMAGE_ENCLAVE_CONFIG64 IMAGE_ENCLAVE_CONFIG;
typedef PIMAGE_ENCLAVE_CONFIG64 PIMAGE_ENCLAVE_CONFIG;
# 18133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_ENCLAVE_IMPORT {
    DWORD MatchType;
    DWORD MinimumSecurityVersion;
    BYTE UniqueOrAuthorID[32];
    BYTE FamilyID[16];
    BYTE ImageID[16];
    DWORD ImportName;
    DWORD Reserved;
} IMAGE_ENCLAVE_IMPORT, *PIMAGE_ENCLAVE_IMPORT;
# 18153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Type;
    DWORD SizeOfData;
    DWORD AddressOfRawData;
    DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
# 18183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD NumberOfSymbols;
    DWORD LvaToFirstSymbol;
    DWORD NumberOfLinenumbers;
    DWORD LvaToFirstLinenumber;
    DWORD RvaToFirstByteOfCode;
    DWORD RvaToLastByteOfCode;
    DWORD RvaToFirstByteOfData;
    DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD ulOffStart;
    DWORD cbProcSize;
    DWORD cdwLocals;
    WORD cdwParams;
    WORD cbProlog : 8;
    WORD cbRegs : 3;
    WORD fHasSEH : 1;
    WORD fUseBP : 1;
    WORD reserved : 1;
    WORD cbFrame : 2;
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD DataType;
    DWORD Length;

    BOOLEAN Unicode;
    BYTE Reserved[ 3 ];
    BYTE Data[ 1 ];
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;
# 18232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG StartingAddress;
    ULONGLONG EndingAddress;
    union {
        ULONGLONG EndOfPrologue;
        ULONGLONG UnwindInfoAddress;
    } ;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;
# 18267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD Signature;
    WORD Flags;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;
    DWORD NumberOfSections;
    DWORD ExportedNamesSize;
    DWORD DebugDirectorySize;
    DWORD SectionAlignment;
    DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;



typedef struct _NON_PAGED_DEBUG_INFO {
    WORD Signature;
    WORD Flags;
    DWORD Size;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD SizeOfImage;
    ULONGLONG ImageBase;


} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;
# 18321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;

    int :7;
    unsigned int AmaskShift: 8;
    int :16;
    DWORD FirstEntryRVA;
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;
    DWORD NewInst;
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;


# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 18335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 18344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct IMPORT_OBJECT_HEADER {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    DWORD SizeOfData;

    union {
        WORD Ordinal;
        WORD Hint;
    } ;

    WORD Type : 2;
    WORD NameType : 3;
    WORD Reserved : 11;
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,

    IMPORT_OBJECT_NAME_EXPORTAS = 4,
} IMPORT_OBJECT_NAME_TYPE;





typedef enum ReplacesCorHdrNumericDefines
{

    COMIMAGE_FLAGS_ILONLY =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA =0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED =0x00020000,


    COR_VERSION_MAJOR_V2 =2,
    COR_VERSION_MAJOR =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR =5,
    COR_DELETED_NAME_LENGTH =8,
    COR_VTABLEGAP_NAME_LENGTH =8,


    NATIVE_TYPE_MAX_CB =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,


    IMAGE_COR_MIH_METHODRVA =0x01,
    IMAGE_COR_MIH_EHRVA =0x02,
    IMAGE_COR_MIH_BASICBLOCK =0x08,


    COR_VTABLE_32BIT =0x01,
    COR_VTABLE_64BIT =0x02,
    COR_VTABLE_FROM_UNMANAGED =0x04,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN =0x08,
    COR_VTABLE_CALL_MOST_DERIVED =0x10,


    IMAGE_COR_EATJ_THUNK_SIZE =32,



    MAX_CLASS_NAME =1024,
    MAX_PACKAGE_NAME =1024,
} ReplacesCorHdrNumericDefines;


typedef struct IMAGE_COR20_HEADER
{

    DWORD cb;
    WORD MajorRuntimeVersion;
    WORD MinorRuntimeVersion;


    IMAGE_DATA_DIRECTORY MetaData;
    DWORD Flags;



    union {
        DWORD EntryPointToken;
        DWORD EntryPointRVA;
    } ;


    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;


    IMAGE_DATA_DIRECTORY CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;


    IMAGE_DATA_DIRECTORY ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;








# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\apiset.h" 1 3
# 18465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3
# 18480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)

WORD
__stdcall
RtlCaptureStackBackTrace(
         DWORD FramesToSkip,
         DWORD FramesToCapture,
                                             PVOID * BackTrace,
              PDWORD BackTraceHash
    );
# 18504 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
void
__stdcall
RtlCaptureContext(
          PCONTEXT ContextRecord
    );
# 18523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
void
__stdcall
RtlUnwind(
             PVOID TargetFrame,
             PVOID TargetIp,
             PEXCEPTION_RECORD ExceptionRecord,
         PVOID ReturnValue
    );
# 18544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
BOOLEAN
__cdecl
RtlAddFunctionTable(
                           PRUNTIME_FUNCTION FunctionTable,
         DWORD EntryCount,
         DWORD64 BaseAddress
    );


__declspec(dllimport)
BOOLEAN
__cdecl
RtlDeleteFunctionTable(
         PRUNTIME_FUNCTION FunctionTable
    );


__declspec(dllimport)
BOOLEAN
__cdecl
RtlInstallFunctionTableCallback(
         DWORD64 TableIdentifier,
         DWORD64 BaseAddress,
         DWORD Length,
         PGET_RUNTIME_FUNCTION_CALLBACK Callback,
             PVOID Context,
             PCWSTR OutOfProcessCallbackDll
    );
# 18621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
PRUNTIME_FUNCTION
__stdcall
RtlLookupFunctionEntry(
         DWORD64 ControlPc,
          PDWORD64 ImageBase,
                PUNWIND_HISTORY_TABLE HistoryTable
    );
# 18638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
void
__cdecl
RtlRestoreContext(
         PCONTEXT ContextRecord,
             struct _EXCEPTION_RECORD * ExceptionRecord
    );
# 18654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
void
__stdcall
RtlUnwindEx(
             PVOID TargetFrame,
             PVOID TargetIp,
             PEXCEPTION_RECORD ExceptionRecord,
         PVOID ReturnValue,
         PCONTEXT ContextRecord,
             PUNWIND_HISTORY_TABLE HistoryTable
    );
# 18674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
PEXCEPTION_ROUTINE
__stdcall
RtlVirtualUnwind(
         DWORD HandlerType,
         DWORD64 ImageBase,
         DWORD64 ControlPc,
         PRUNTIME_FUNCTION FunctionEntry,
            PCONTEXT ContextRecord,
          PVOID * HandlerData,
          PDWORD64 EstablisherFrame,
                PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
    );
# 19060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
PVOID
__stdcall
RtlPcToFileHeader(
         PVOID PcValue,
          PVOID * BaseOfImage
    );
# 19086 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
SIZE_T
__stdcall
RtlCompareMemory(
         const void * Source1,
         const void * Source2,
         SIZE_T Length
    );
# 19129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
#pragma warning(push)
#pragma warning(disable: 4324)

typedef struct __declspec(align(16)) _SLIST_ENTRY {
    struct _SLIST_ENTRY *Next;
} SLIST_ENTRY, *PSLIST_ENTRY;

#pragma warning(pop)
# 19146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef union __declspec(align(16)) _SLIST_HEADER {
    struct {
        ULONGLONG Alignment;
        ULONGLONG Region;
    } ;
    struct {
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG Reserved:4;
        ULONGLONG NextEntry:60;
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;
# 19205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
void
__stdcall
RtlInitializeSListHead (
          PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlFirstEntrySList (
         const SLIST_HEADER *ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPopEntrySList (
            PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushEntrySList (
            PSLIST_HEADER ListHead,
                             PSLIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushListSListEx (
            PSLIST_HEADER ListHead,
                             PSLIST_ENTRY List,
            PSLIST_ENTRY ListEnd,
         DWORD Count
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedFlushSList (
            PSLIST_HEADER ListHead
    );

__declspec(dllimport)
WORD
__stdcall
RtlQueryDepthSList (
         PSLIST_HEADER ListHead
    );
# 19287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef union _RTL_RUN_ONCE {
    PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;



typedef struct _RTL_BARRIER {
            DWORD Reserved1;
            DWORD Reserved2;
            ULONG_PTR Reserved3[2];
            DWORD Reserved4;
            DWORD Reserved5;
} RTL_BARRIER, *PRTL_BARRIER;
# 19368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(noreturn)
void
__fastfail(
         unsigned int Code
    );

#pragma intrinsic(__fastfail)
# 19397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__forceinline
DWORD
HEAP_MAKE_TAG_FLAGS (
         DWORD TagBase,
         DWORD Tag
    )

{
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}
# 19476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__forceinline
PVOID
RtlSecureZeroMemory(
                                PVOID ptr,
         SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;



    __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
# 19509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
    return ptr;
}
# 19535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD Length;
    WORD Flags;
    BYTE Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ];
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;





typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;


typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ];
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ];
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;





typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
# 19682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
         ULONGLONG ConditionMask,
         DWORD TypeMask,
         BYTE Condition
    );
# 19707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__declspec(dllimport)
BOOLEAN
__stdcall
RtlGetProductInfo(
          DWORD OSMajorVersion,
          DWORD OSMinorVersion,
          DWORD SpMajorVersion,
          DWORD SpMinorVersion,
          PDWORD ReturnedProductType
    );
# 19727 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef

void
__stdcall
RTL_UMS_SCHEDULER_ENTRY_POINT(
         RTL_UMS_SCHEDULER_REASON Reason,
         ULONG_PTR ActivationPayload,
         PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
# 20026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool,
    ImagePolicyEntryTypeInt8,
    ImagePolicyEntryTypeUInt8,
    ImagePolicyEntryTypeInt16,
    ImagePolicyEntryTypeUInt16,
    ImagePolicyEntryTypeInt32,
    ImagePolicyEntryTypeUInt32,
    ImagePolicyEntryTypeInt64,
    ImagePolicyEntryTypeUInt64,
    ImagePolicyEntryTypeAnsiString,
    ImagePolicyEntryTypeUnicodeString,
    ImagePolicyEntryTypeMaximum
} IMAGE_POLICY_ENTRY_TYPE;

typedef enum _IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw,
    ImagePolicyIdDebug,
    ImagePolicyIdCrashDump,
    ImagePolicyIdCrashDumpKey,
    ImagePolicyIdCrashDumpKeyGuid,
    ImagePolicyIdParentSd,
    ImagePolicyIdParentSdRev,
    ImagePolicyIdSvn,
    ImagePolicyIdDeviceId,
    ImagePolicyIdCapability,
    ImagePolicyIdScenarioId,
    ImagePolicyIdMaximum
} IMAGE_POLICY_ID;

typedef struct _IMAGE_POLICY_ENTRY {
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
    union {
        const void* None;
        BOOLEAN BoolValue;
        INT8 Int8Value;
        UINT8 UInt8Value;
        INT16 Int16Value;
        UINT16 UInt16Value;
        INT32 Int32Value;
        UINT32 UInt32Value;
        INT64 Int64Value;
        UINT64 UInt64Value;
        PCSTR AnsiStringValue;
        PCWSTR UnicodeStringValue;
    } u;
} IMAGE_POLICY_ENTRY;
typedef const IMAGE_POLICY_ENTRY* PCIMAGE_POLICY_ENTRY;

#pragma warning(push)
#pragma warning(disable: 4200)
typedef struct _IMAGE_POLICY_METADATA {
    BYTE Version;
    BYTE Reserved0[7];
    ULONGLONG ApplicationId;
    IMAGE_POLICY_ENTRY Policies[];
} IMAGE_POLICY_METADATA;
typedef const IMAGE_POLICY_METADATA* PCIMAGE_POLICY_METADATA;
#pragma warning(pop)
# 20138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;
# 20166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;






    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {
        PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;

typedef struct _RTL_CONDITION_VARIABLE {
        PVOID Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;


typedef
void
(__stdcall *PAPCFUNC)(
         ULONG_PTR Parameter
    );
typedef LONG (__stdcall *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1
# 20218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
} HEAP_INFORMATION_CLASS;
# 20244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef void (__stdcall * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef void (__stdcall * WORKERCALLBACKFUNC) (PVOID );
typedef void (__stdcall * APC_CALLBACK_FUNCTION) (DWORD , PVOID, PVOID);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;
typedef
void
(__stdcall *PFLS_CALLBACK_FUNCTION) (
       PVOID lpFlsData
    );

typedef
BOOLEAN
(__stdcall *PSECURE_MEMORY_CACHE_CALLBACK) (
                            PVOID Addr,
         SIZE_T Range
    );




typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,




    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
} ACTIVATION_CONTEXT_INFO_CLASS;




typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;







typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;
# 20316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;
    DWORD ulManifestPathType;
    DWORD ulManifestPathLength;
    LARGE_INTEGER liManifestLastWriteTime;
    DWORD ulPolicyPathType;
    DWORD ulPolicyPathLength;
    LARGE_INTEGER liPolicyLastWriteTime;
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor;
    DWORD ulManifestVersionMinor;
    DWORD ulPolicyVersionMajor;
    DWORD ulPolicyVersionMinor;
    DWORD ulAssemblyDirectoryNameLength;

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;




#pragma warning(push)
#pragma warning(disable: 4200)


typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;


#pragma warning(pop)


typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;



typedef struct _SUPPORTED_OS_INFO {
    WORD MajorVersion;
    WORD MinorVersion;
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;




typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;



typedef struct _PERFORMANCE_DATA {
    WORD Size;
    BYTE Version;
    BYTE HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;
# 20584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _EVENTLOGRECORD {
    DWORD Length;
    DWORD Reserved;
    DWORD RecordNumber;
    DWORD TimeGenerated;
    DWORD TimeWritten;
    DWORD EventID;
    WORD EventType;
    WORD NumStrings;
    WORD EventCategory;
    WORD ReservedFlags;
    DWORD ClosingRecordNumber;
    DWORD StringOffset;
    DWORD UserSidLength;
    DWORD UserSidOffset;
    DWORD DataLength;
    DWORD DataOffset;
# 20612 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
} EVENTLOGRECORD, *PEVENTLOGRECORD;






#pragma warning(push)

#pragma warning(disable: 4200)

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;



struct _EVENTSFORLOGFILE
{
    DWORD ulSize;
    WCHAR szLogicalLogFile[256];
    DWORD ulNumRecords;
    EVENTLOGRECORD pEventLogRecords[];
};

struct _PACKEDEVENTINFO
{
    DWORD ulSize;
    DWORD ulNumEventsForLogFile;
    DWORD ulOffsets[];
};




#pragma warning(pop)
# 20888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;
# 20976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;
# 20992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;
# 21006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;
# 21020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
# 21041 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;
# 21134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;





typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;





typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;





typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;
# 21188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;
# 21204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;




typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;







extern "C" {




# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\ktmtypes.h" 1 3
# 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\ktmtypes.h" 3
extern "C" {



#pragma warning(push)
#pragma warning(disable: 4820)


typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;
# 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\ktmtypes.h" 3
typedef ULONG NOTIFICATION_MASK;
# 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\ktmtypes.h" 3
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID TransactionKey;
    ULONG TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID EnlistmentId;
    UOW UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;



typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID UOW;
    GUID TmIdentity;
    ULONG BufferLength;

} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;







typedef struct _KCRM_MARSHAL_HEADER {
    ULONG VersionMajor;
    ULONG VersionMinor;
    ULONG NumProtocols;
    ULONG Unused;
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW UOW;
    GUID TmIdentity;
    ULONG IsolationLevel;
    ULONG IsolationFlags;
    ULONG Timeout;
    WCHAR Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID ProtocolId;
                                  ULONG StaticInfoLength;
    ULONG TransactionIdInfoLength;
    ULONG Unused1;
    ULONG Unused2;
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;


#pragma warning(pop)



}
# 21233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 2 3



#pragma warning(push)
#pragma warning(disable: 4820)
# 21410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID TransactionId;
    DWORD State;
    DWORD Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
                                WCHAR LogPath[1];

} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;



typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;



typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD IsolationLevel;
    DWORD IsolationFlags;
    LARGE_INTEGER Timeout;
    DWORD Outcome;
    DWORD DescriptionLength;
    WCHAR Description[1];

} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;



typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID EnlistmentId;
    GUID ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID ResourceManagerId;
    DWORD DescriptionLength;
    WCHAR Description[1];
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;




typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation

    ,


    TransactionBindInformation,
    TransactionDTCPrivateInformation
    ,

} TRANSACTION_INFORMATION_CLASS;


typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4

    ,



    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5



} TRANSACTIONMANAGER_INFORMATION_CLASS;



typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;



typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1];
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;






typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;
# 21595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _KTMOBJECT_CURSOR {





    GUID LastQuery;





    DWORD ObjectIdCount;





    GUID ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;




#pragma warning(pop)



}



typedef DWORD TP_VERSION, *PTP_VERSION;

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef void (__stdcall *PTP_SIMPLE_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL;

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;

typedef void (__stdcall *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
                PVOID ObjectContext,
                PVOID CleanupContext
    );
# 21690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
typedef struct _TP_CALLBACK_ENVIRON_V1 {
    TP_VERSION Version;
    PTP_POOL Pool;
    PTP_CLEANUP_GROUP CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    PVOID RaceDll;
    struct _ACTIVATION_CONTEXT *ActivationContext;
    PTP_SIMPLE_CALLBACK FinalizationCallback;
    union {
        DWORD Flags;
        struct {
            DWORD LongFunction : 1;
            DWORD Persistent : 1;
            DWORD Private : 30;
        } s;
    } u;
} TP_CALLBACK_ENVIRON_V1;

typedef TP_CALLBACK_ENVIRON_V1 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;





__forceinline
void
TpInitializeCallbackEnviron(
          PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{







    CallbackEnviron->Version = 1;



    CallbackEnviron->Pool = 0;
    CallbackEnviron->CleanupGroup = 0;
    CallbackEnviron->CleanupGroupCancelCallback = 0;
    CallbackEnviron->RaceDll = 0;
    CallbackEnviron->ActivationContext = 0;
    CallbackEnviron->FinalizationCallback = 0;
    CallbackEnviron->u.Flags = 0;
# 21746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
}

__forceinline
void
TpSetCallbackThreadpool(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            PTP_POOL Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

__forceinline
void
TpSetCallbackCleanupGroup(
             PTP_CALLBACK_ENVIRON CallbackEnviron,
             PTP_CLEANUP_GROUP CleanupGroup,
             PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

__forceinline
void
TpSetCallbackActivationContext(
             PTP_CALLBACK_ENVIRON CallbackEnviron,
             struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

__forceinline
void
TpSetCallbackNoActivationContext(
            PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1;
}

__forceinline
void
TpSetCallbackLongFunction(
            PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

__forceinline
void
TpSetCallbackRaceWithDll(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            PVOID DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

__forceinline
void
TpSetCallbackFinalizationCallback(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            PTP_SIMPLE_CALLBACK FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}
# 21832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
__forceinline
void
TpSetCallbackPersistent(
            PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


__forceinline
void
TpDestroyCallbackEnviron(
         PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{






    (CallbackEnviron);
}




typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef void (__stdcall *PTP_WORK_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PTP_WORK Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef void (__stdcall *PTP_TIMER_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PTP_TIMER Timer
    );

typedef DWORD TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef void (__stdcall *PTP_WAIT_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PTP_WAIT Wait,
                TP_WAIT_RESULT WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;



__forceinline
struct _TEB *
NtCurrentTeb (
    void
    )

{
    return (struct _TEB *)__readgsqword(((LONG)(LONG_PTR)&(((NT_TIB *)0)->Self)));
}

__forceinline
PVOID
GetCurrentFiber (
    void
    )

{

    return (PVOID)__readgsqword(((LONG)(LONG_PTR)&(((NT_TIB *)0)->FiberData)));
}

__forceinline
PVOID
GetFiberData (
    void
    )

{

    return *(PVOID *)GetCurrentFiber();
}
# 22019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winnt.h" 3
}



#pragma warning(pop)
# 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 2 3




typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;
# 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
typedef HANDLE *SPHANDLE;
typedef HANDLE *LPHANDLE;
typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;



#pragma warning(push)
#pragma warning(disable: 4255)



typedef INT_PTR ( __stdcall *FARPROC)();
typedef INT_PTR ( __stdcall *NEARPROC)();
typedef INT_PTR (__stdcall *PROC)();
# 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
#pragma warning(pop)







typedef WORD ATOM;

struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;
struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE;
struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA;
struct HKL__{int unused;}; typedef struct HKL__ *HKL;


typedef int HFILE;
# 271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\minwindef.h" 3
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;



}
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 2 3
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
struct HWND__{int unused;}; typedef struct HWND__ *HWND;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK;
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
typedef void * HGDIOBJ;






struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL;


struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH;


struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE;


struct HDC__{int unused;}; typedef struct HDC__ *HDC;

struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC;
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE;

struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT;

struct HICON__{int unused;}; typedef struct HICON__ *HICON;

struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU;


struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN;



struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;
# 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR;
# 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD;
# 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
typedef HICON HCURSOR;




typedef DWORD COLORREF;







typedef DWORD *LPCOLORREF;
# 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
typedef struct tagRECT
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT, *PRECT, *NPRECT, *LPRECT;

typedef const RECT * LPCRECT;

typedef struct _RECTL
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL * LPCRECTL;

typedef struct tagPOINT
{
    LONG x;
    LONG y;
} POINT, *PPOINT, *NPPOINT, *LPPOINT;

typedef struct _POINTL
{
    LONG x;
    LONG y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG cx;
    LONG cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE SIZEL;
typedef SIZE *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT x;
    SHORT y;




} POINTS, *PPOINTS, *LPPOINTS;
# 241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
}
# 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\windef.h" 3
struct DPI_AWARENESS_CONTEXT__{int unused;}; typedef struct DPI_AWARENESS_CONTEXT__ *DPI_AWARENESS_CONTEXT;

typedef enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
} DPI_AWARENESS;
# 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 1 3
# 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
#pragma warning(push)
#pragma warning(disable: 4820)
#pragma warning(disable: 4668)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)







# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\apisetcconv.h" 1 3
# 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 1 3
# 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
#pragma warning(disable: 4514)

#pragma warning(disable: 4103)


#pragma warning(push)
#pragma warning(disable: 4820)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)






extern "C" {
# 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } ;
        PVOID Pointer;
    } ;

    HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
# 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
              CHAR cFileName[ 260 ];
              CHAR cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
              WCHAR cFileName[ 260 ];
              WCHAR cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;





typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;




typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;




typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
# 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;


typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,
# 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
    FileDispositionInfoEx,
    FileRenameInfoEx,

    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;


typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

typedef
void
(__stdcall *LPOVERLAPPED_COMPLETION_ROUTINE)(
            DWORD dwErrorCode,
            DWORD dwNumberOfBytesTransfered,
            LPOVERLAPPED lpOverlapped
    );




typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } ;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;
# 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;
# 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
typedef DWORD (__stdcall *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef LPVOID (__stdcall *PENCLAVE_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;







typedef PCONTEXT LPCONTEXT;
# 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\minwinbase.h" 3
}






#pragma warning(pop)
# 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3






# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 1 3
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
extern "C" {
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsW(
                                     LPWCH NewEnvironment
    );
# 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)
HANDLE
__stdcall
GetStdHandle(
         DWORD nStdHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetStdHandle(
         DWORD nStdHandle,
         HANDLE hHandle
    );





__declspec(dllimport)
BOOL
__stdcall
SetStdHandleEx(
         DWORD nStdHandle,
         HANDLE hHandle,
              PHANDLE phPrevValue
    );
# 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)
LPSTR
__stdcall
GetCommandLineA(
    void
    );

__declspec(dllimport)
LPWSTR
__stdcall
GetCommandLineW(
    void
    );







__declspec(dllimport)

LPCH
__stdcall
GetEnvironmentStrings(
    void
    );


__declspec(dllimport)

LPWCH
__stdcall
GetEnvironmentStringsW(
    void
    );
# 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsA(
                                     LPCH penv
    );

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsW(
                                     LPWCH penv
    );







__declspec(dllimport)

DWORD
__stdcall
GetEnvironmentVariableA(
             LPCSTR lpName,
                                           LPSTR lpBuffer,
         DWORD nSize
    );

__declspec(dllimport)

DWORD
__stdcall
GetEnvironmentVariableW(
             LPCWSTR lpName,
                                           LPWSTR lpBuffer,
         DWORD nSize
    );







__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableA(
         LPCSTR lpName,
             LPCSTR lpValue
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableW(
         LPCWSTR lpName,
             LPCWSTR lpValue
    );







__declspec(dllimport)

DWORD
__stdcall
ExpandEnvironmentStringsA(
         LPCSTR lpSrc,
                                       LPSTR lpDst,
         DWORD nSize
    );

__declspec(dllimport)

DWORD
__stdcall
ExpandEnvironmentStringsW(
         LPCWSTR lpSrc,
                                       LPWSTR lpDst,
         DWORD nSize
    );







__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryA(
         LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryW(
         LPCWSTR lpPathName
    );
# 280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)

DWORD
__stdcall
GetCurrentDirectoryA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );

__declspec(dllimport)

DWORD
__stdcall
GetCurrentDirectoryW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );
# 315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)
DWORD
__stdcall
SearchPathW(
             LPCWSTR lpPath,
         LPCWSTR lpFileName,
             LPCWSTR lpExtension,
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer,
              LPWSTR * lpFilePart
    );
# 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
__declspec(dllimport)
DWORD
__stdcall
SearchPathA(
             LPCSTR lpPath,
         LPCSTR lpFileName,
             LPCSTR lpExtension,
         DWORD nBufferLength,
                                                   LPSTR lpBuffer,
              LPSTR * lpFilePart
    );





__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathA(
         LPCSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathW(
         LPCWSTR ExeName
    );
# 390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processenv.h" 3
}
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 1 3
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
extern "C" {
# 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
LONG
__stdcall
CompareFileTime(
         const FILETIME * lpFileTime1,
         const FILETIME * lpFileTime2
    );


__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryA(
         LPCSTR lpPathName,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryW(
         LPCWSTR lpPathName,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
# 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
CreateFileA(
         LPCSTR lpFileName,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD dwCreationDisposition,
         DWORD dwFlagsAndAttributes,
             HANDLE hTemplateFile
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateFileW(
         LPCWSTR lpFileName,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD dwCreationDisposition,
         DWORD dwFlagsAndAttributes,
             HANDLE hTemplateFile
    );







__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceW(
         DWORD dwFlags,
         LPCWSTR lpDeviceName,
             LPCWSTR lpTargetPath
    );
# 173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
DeleteFileA(
         LPCSTR lpFileName
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteFileW(
         LPCWSTR lpFileName
    );







__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint
    );






__declspec(dllimport)
BOOL
__stdcall
FileTimeToLocalFileTime(
         const FILETIME * lpFileTime,
          LPFILETIME lpLocalFileTime
    );





__declspec(dllimport)
BOOL
__stdcall
FindClose(
            HANDLE hFindFile
    );
# 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FindCloseChangeNotification(
         HANDLE hChangeHandle
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationA(
         LPCSTR lpPathName,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationW(
         LPCWSTR lpPathName,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter
    );
# 271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileA(
         LPCSTR lpFileName,
          LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileW(
         LPCWSTR lpFileName,
          LPWIN32_FIND_DATAW lpFindFileData
    );
# 296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExA(
         LPCSTR lpFileName,
         FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
         FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
         DWORD dwAdditionalFlags
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExW(
         LPCWSTR lpFileName,
         FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
         FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
         DWORD dwAdditionalFlags
    );
# 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeW(
                                  LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindNextChangeNotification(
         HANDLE hChangeHandle
    );
# 363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FindNextFileA(
         HANDLE hFindFile,
          LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileW(
         HANDLE hFindFile,
          LPWIN32_FIND_DATAW lpFindFileData
    );
# 392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeW(
            HANDLE hFindVolume,
                                  LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindVolumeClose(
         HANDLE hFindVolume
    );
# 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FlushFileBuffers(
         HANDLE hFile
    );
# 436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceA(
             LPCSTR lpRootPathName,
              LPDWORD lpSectorsPerCluster,
              LPDWORD lpBytesPerSector,
              LPDWORD lpNumberOfFreeClusters,
              LPDWORD lpTotalNumberOfClusters
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceW(
             LPCWSTR lpRootPathName,
              LPDWORD lpSectorsPerCluster,
              LPDWORD lpBytesPerSector,
              LPDWORD lpNumberOfFreeClusters,
              LPDWORD lpTotalNumberOfClusters
    );







__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExA(
             LPCSTR lpDirectoryName,
              PULARGE_INTEGER lpFreeBytesAvailableToCaller,
              PULARGE_INTEGER lpTotalNumberOfBytes,
              PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExW(
             LPCWSTR lpDirectoryName,
              PULARGE_INTEGER lpFreeBytesAvailableToCaller,
              PULARGE_INTEGER lpTotalNumberOfBytes,
              PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );







__declspec(dllimport)
UINT
__stdcall
GetDriveTypeA(
             LPCSTR lpRootPathName
    );

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeW(
             LPCWSTR lpRootPathName
    );
# 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesA(
         LPCSTR lpFileName
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesW(
         LPCWSTR lpFileName
    );







__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExA(
         LPCSTR lpFileName,
         GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExW(
         LPCWSTR lpFileName,
         GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation
    );
# 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandle(
         HANDLE hFile,
          LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileSize(
         HANDLE hFile,
              LPDWORD lpFileSizeHigh
    );
# 615 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetFileSizeEx(
         HANDLE hFile,
          PLARGE_INTEGER lpFileSize
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileType(
         HANDLE hFile
    );





__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleA(
         HANDLE hFile,
                              LPSTR lpszFilePath,
         DWORD cchFilePath,
         DWORD dwFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleW(
         HANDLE hFile,
                              LPWSTR lpszFilePath,
         DWORD cchFilePath,
         DWORD dwFlags
    );
# 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetFileTime(
         HANDLE hFile,
              LPFILETIME lpCreationTime,
              LPFILETIME lpLastAccessTime,
              LPFILETIME lpLastWriteTime
    );


__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameW(
         LPCWSTR lpFileName,
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer,
                 LPWSTR * lpFilePart
    );






__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameA(
         LPCSTR lpFileName,
         DWORD nBufferLength,
                                                   LPSTR lpBuffer,
                 LPSTR * lpFilePart
    );






__declspec(dllimport)
DWORD
__stdcall
GetLogicalDrives(
    void
    );
# 721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );






__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameA(
         LPCSTR lpszShortPath,
                                               LPSTR lpszLongPath,
         DWORD cchBuffer
    );
# 756 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameW(
         LPCWSTR lpszShortPath,
                                               LPWSTR lpszLongPath,
         DWORD cchBuffer
    );
# 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)

DWORD
__stdcall
GetShortPathNameW(
         LPCWSTR lpszLongPath,
                                               LPWSTR lpszShortPath,
         DWORD cchBuffer
    );
# 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
UINT
__stdcall
GetTempFileNameW(
         LPCWSTR lpPathName,
         LPCWSTR lpPrefixString,
         UINT uUnique,
                           LPWSTR lpTempFileName
    );
# 825 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationByHandleW(
         HANDLE hFile,
                                      LPWSTR lpVolumeNameBuffer,
         DWORD nVolumeNameSize,
              LPDWORD lpVolumeSerialNumber,
              LPDWORD lpMaximumComponentLength,
              LPDWORD lpFileSystemFlags,
                                          LPWSTR lpFileSystemNameBuffer,
         DWORD nFileSystemNameSize
    );
# 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationW(
             LPCWSTR lpRootPathName,
                                      LPWSTR lpVolumeNameBuffer,
         DWORD nVolumeNameSize,
              LPDWORD lpVolumeSerialNumber,
              LPDWORD lpMaximumComponentLength,
              LPDWORD lpFileSystemFlags,
                                          LPWSTR lpFileSystemNameBuffer,
         DWORD nFileSystemNameSize
    );
# 874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameW(
         LPCWSTR lpszFileName,
                                  LPWSTR lpszVolumePathName,
         DWORD cchBufferLength
    );
# 895 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
LocalFileTimeToFileTime(
         const FILETIME * lpLocalFileTime,
          LPFILETIME lpFileTime
    );


__declspec(dllimport)
BOOL
__stdcall
LockFile(
         HANDLE hFile,
         DWORD dwFileOffsetLow,
         DWORD dwFileOffsetHigh,
         DWORD nNumberOfBytesToLockLow,
         DWORD nNumberOfBytesToLockHigh
    );


__declspec(dllimport)
BOOL
__stdcall
LockFileEx(
         HANDLE hFile,
         DWORD dwFlags,
               DWORD dwReserved,
         DWORD nNumberOfBytesToLockLow,
         DWORD nNumberOfBytesToLockHigh,
            LPOVERLAPPED lpOverlapped
    );
# 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceW(
             LPCWSTR lpDeviceName,
                                         LPWSTR lpTargetPath,
         DWORD ucchMax
    );
# 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
ReadFile(
         HANDLE hFile,
                                                                                                  LPVOID lpBuffer,
         DWORD nNumberOfBytesToRead,
              LPDWORD lpNumberOfBytesRead,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)

BOOL
__stdcall
ReadFileEx(
         HANDLE hFile,
                                                                         LPVOID lpBuffer,
         DWORD nNumberOfBytesToRead,
            LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 990 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
ReadFileScatter(
         HANDLE hFile,
         FILE_SEGMENT_ELEMENT aSegmentArray[],
         DWORD nNumberOfBytesToRead,
               LPDWORD lpReserved,
            LPOVERLAPPED lpOverlapped
    );
# 1010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryA(
         LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryW(
         LPCWSTR lpPathName
    );







__declspec(dllimport)
BOOL
__stdcall
SetEndOfFile(
         HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesA(
         LPCSTR lpFileName,
         DWORD dwFileAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesW(
         LPCWSTR lpFileName,
         DWORD dwFileAttributes
    );
# 1063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileInformationByHandle(
         HANDLE hFile,
         FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
                                   LPVOID lpFileInformation,
         DWORD dwBufferSize
    );




__declspec(dllimport)
DWORD
__stdcall
SetFilePointer(
         HANDLE hFile,
         LONG lDistanceToMove,
                PLONG lpDistanceToMoveHigh,
         DWORD dwMoveMethod
    );


__declspec(dllimport)
BOOL
__stdcall
SetFilePointerEx(
         HANDLE hFile,
         LARGE_INTEGER liDistanceToMove,
              PLARGE_INTEGER lpNewFilePointer,
         DWORD dwMoveMethod
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileTime(
         HANDLE hFile,
             const FILETIME * lpCreationTime,
             const FILETIME * lpLastAccessTime,
             const FILETIME * lpLastWriteTime
    );
# 1119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileValidData(
         HANDLE hFile,
         LONGLONG ValidDataLength
    );
# 1137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
UnlockFile(
         HANDLE hFile,
         DWORD dwFileOffsetLow,
         DWORD dwFileOffsetHigh,
         DWORD nNumberOfBytesToUnlockLow,
         DWORD nNumberOfBytesToUnlockHigh
    );



__declspec(dllimport)
BOOL
__stdcall
UnlockFileEx(
         HANDLE hFile,
               DWORD dwReserved,
         DWORD nNumberOfBytesToUnlockLow,
         DWORD nNumberOfBytesToUnlockHigh,
            LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFile(
         HANDLE hFile,
                                                LPCVOID lpBuffer,
         DWORD nNumberOfBytesToWrite,
              LPDWORD lpNumberOfBytesWritten,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFileEx(
         HANDLE hFile,
                                                LPCVOID lpBuffer,
         DWORD nNumberOfBytesToWrite,
            LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 1193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
WriteFileGather(
         HANDLE hFile,
         FILE_SEGMENT_ELEMENT aSegmentArray[],
         DWORD nNumberOfBytesToWrite,
               LPDWORD lpReserved,
            LPOVERLAPPED lpOverlapped
    );
# 1219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetTempPathW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );
# 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint,
                                  LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );
# 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameW(
         LPCWSTR lpszVolumeName,
                                                                                          LPWCH lpszVolumePathNames,
         DWORD cchBufferLength,
          PDWORD lpcchReturnLength
    );
# 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileIoOverlappedRange(
         HANDLE FileHandle,
         PUCHAR OverlappedRangeStart,
         ULONG Length
    );
# 1346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeA(
         LPCSTR lpFileName,
              LPDWORD lpFileSizeHigh
    );

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeW(
         LPCWSTR lpFileName,
              LPDWORD lpFileSizeHigh
    );
# 1384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;




__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamW(
         LPCWSTR lpFileName,
         STREAM_INFO_LEVELS InfoLevel,
                                                       LPVOID lpFindStreamData,
               DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextStreamW(
         HANDLE hFindStream,
                                                       LPVOID lpFindStreamData
    );
# 1428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AreFileApisANSI(
    void
    );
# 1448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetTempPathA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );
# 1476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameW(
         LPCWSTR lpFileName,
         DWORD dwFlags,
            LPDWORD StringLength,
                                PWSTR LinkName
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextFileNameW(
         HANDLE hFindStream,
            LPDWORD StringLength,
                                PWSTR LinkName
    );
# 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationA(
             LPCSTR lpRootPathName,
                                      LPSTR lpVolumeNameBuffer,
         DWORD nVolumeNameSize,
              LPDWORD lpVolumeSerialNumber,
              LPDWORD lpMaximumComponentLength,
              LPDWORD lpFileSystemFlags,
                                          LPSTR lpFileSystemNameBuffer,
         DWORD nFileSystemNameSize
    );






__declspec(dllimport)
UINT
__stdcall
GetTempFileNameA(
         LPCSTR lpPathName,
         LPCSTR lpPrefixString,
         UINT uUnique,
                           LPSTR lpTempFileName
    );
# 1556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
__declspec(dllimport)
void
__stdcall
SetFileApisToOEM(
    void
    );


__declspec(dllimport)
void
__stdcall
SetFileApisToANSI(
    void
    );
# 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fileapi.h" 3
}
# 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 1 3
# 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
extern "C" {
# 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsDebuggerPresent(
    void
    );
# 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
__declspec(dllimport)
void
__stdcall
DebugBreak(
    void
    );
# 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
__declspec(dllimport)
void
__stdcall
OutputDebugStringA(
             LPCSTR lpOutputString
    );

__declspec(dllimport)
void
__stdcall
OutputDebugStringW(
             LPCWSTR lpOutputString
    );
# 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
ContinueDebugEvent(
         DWORD dwProcessId,
         DWORD dwThreadId,
         DWORD dwContinueStatus
    );


__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEvent(
          LPDEBUG_EVENT lpDebugEvent,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcess(
         DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcessStop(
         DWORD dwProcessId
    );





__declspec(dllimport)
BOOL
__stdcall
CheckRemoteDebuggerPresent(
         HANDLE hProcess,
          PBOOL pbDebuggerPresent
    );
# 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEventEx(
          LPDEBUG_EVENT lpDebugEvent,
         DWORD dwMilliseconds
    );
# 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\debugapi.h" 3
}
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\utilapiset.h" 1 3
# 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\utilapiset.h" 3
extern "C" {






__declspec(dllimport)

PVOID
__stdcall
EncodePointer(
             PVOID Ptr
    );


__declspec(dllimport)

PVOID
__stdcall
DecodePointer(
             PVOID Ptr
    );
# 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\utilapiset.h" 3
__declspec(dllimport)

PVOID
__stdcall
EncodeSystemPointer(
             PVOID Ptr
    );


__declspec(dllimport)

PVOID
__stdcall
DecodeSystemPointer(
             PVOID Ptr
    );





__declspec(dllimport)
HRESULT
__stdcall
EncodeRemotePointer(
         HANDLE ProcessHandle,
             PVOID Ptr,
          PVOID * EncodedPtr
    );


__declspec(dllimport)
HRESULT
__stdcall
DecodeRemotePointer(
         HANDLE ProcessHandle,
             PVOID Ptr,
          PVOID * DecodedPtr
    );
# 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\utilapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
Beep(
         DWORD dwFreq,
         DWORD dwDuration
    );






}
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\handleapi.h" 1 3
# 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\handleapi.h" 3
extern "C" {
# 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\handleapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CloseHandle(
                            HANDLE hObject
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateHandle(
         HANDLE hSourceProcessHandle,
         HANDLE hSourceHandle,
         HANDLE hTargetProcessHandle,
             LPHANDLE lpTargetHandle,
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwOptions
    );


__declspec(dllimport)
BOOL
__stdcall
CompareObjectHandles(
         HANDLE hFirstObjectHandle,
         HANDLE hSecondObjectHandle
    );
# 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\handleapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetHandleInformation(
         HANDLE hObject,
          LPDWORD lpdwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetHandleInformation(
         HANDLE hObject,
         DWORD dwMask,
         DWORD dwFlags
    );






}
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 1 3
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
extern "C" {
# 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
typedef LONG (__stdcall *PTOP_LEVEL_EXCEPTION_FILTER)(
         struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;





__declspec(dllimport)

void
__stdcall
RaiseException(
         DWORD dwExceptionCode,
         DWORD dwExceptionFlags,
         DWORD nNumberOfArguments,
                                       const ULONG_PTR * lpArguments
    );
# 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
LONG
__stdcall
UnhandledExceptionFilter(
         struct _EXCEPTION_POINTERS * ExceptionInfo
    );
# 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
LPTOP_LEVEL_EXCEPTION_FILTER
__stdcall
SetUnhandledExceptionFilter(
             LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );




__declspec(dllimport)

DWORD
__stdcall
GetLastError(
    void
    );




__declspec(dllimport)
void
__stdcall
SetLastError(
         DWORD dwErrCode
    );
# 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
UINT
__stdcall
GetErrorMode(
    void
    );
# 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
UINT
__stdcall
SetErrorMode(
         UINT uMode
    );
# 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)

PVOID
__stdcall
AddVectoredExceptionHandler(
         ULONG First,
         PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredExceptionHandler(
         PVOID Handle
    );


__declspec(dllimport)

PVOID
__stdcall
AddVectoredContinueHandler(
         ULONG First,
         PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredContinueHandler(
         PVOID Handle
    );
# 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
void
__stdcall
RaiseFailFastException(
             PEXCEPTION_RECORD pExceptionRecord,
             PCONTEXT pContextRecord,
         DWORD dwFlags
    );
# 294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
void
__stdcall
FatalAppExitA(
         UINT uAction,
         LPCSTR lpMessageText
    );

__declspec(dllimport)
void
__stdcall
FatalAppExitW(
         UINT uAction,
         LPCWSTR lpMessageText
    );
# 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetThreadErrorMode(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadErrorMode(
         DWORD dwNewMode,
             LPDWORD lpOldMode
    );
# 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
__declspec(dllimport)
void
__stdcall
TerminateProcessOnMemoryExhaustion(
         SIZE_T FailedAllocationSize
    );
# 378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\errhandlingapi.h" 3
}
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fibersapi.h" 1 3
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fibersapi.h" 3
extern "C" {
# 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fibersapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
FlsAlloc(
             PFLS_CALLBACK_FUNCTION lpCallback
    );


__declspec(dllimport)
PVOID
__stdcall
FlsGetValue(
         DWORD dwFlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
FlsSetValue(
         DWORD dwFlsIndex,
             PVOID lpFlsData
    );


__declspec(dllimport)
BOOL
__stdcall
FlsFree(
         DWORD dwFlsIndex
    );
# 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fibersapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsThreadAFiber(
    void
    );
# 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\fibersapi.h" 3
}
# 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 1 3
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
extern "C" {
# 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreatePipe(
          PHANDLE hReadPipe,
          PHANDLE hWritePipe,
             LPSECURITY_ATTRIBUTES lpPipeAttributes,
         DWORD nSize
    );


__declspec(dllimport)
BOOL
__stdcall
ConnectNamedPipe(
         HANDLE hNamedPipe,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DisconnectNamedPipe(
         HANDLE hNamedPipe
    );


__declspec(dllimport)
BOOL
__stdcall
SetNamedPipeHandleState(
         HANDLE hNamedPipe,
             LPDWORD lpMode,
             LPDWORD lpMaxCollectionCount,
             LPDWORD lpCollectDataTimeout
    );


__declspec(dllimport)
BOOL
__stdcall
PeekNamedPipe(
         HANDLE hNamedPipe,
                                                         LPVOID lpBuffer,
         DWORD nBufferSize,
              LPDWORD lpBytesRead,
              LPDWORD lpTotalBytesAvail,
              LPDWORD lpBytesLeftThisMessage
    );


__declspec(dllimport)
BOOL
__stdcall
TransactNamedPipe(
         HANDLE hNamedPipe,
                                        LPVOID lpInBuffer,
         DWORD nInBufferSize,
                                                            LPVOID lpOutBuffer,
         DWORD nOutBufferSize,
          LPDWORD lpBytesRead,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeW(
         LPCWSTR lpName,
         DWORD dwOpenMode,
         DWORD dwPipeMode,
         DWORD nMaxInstances,
         DWORD nOutBufferSize,
         DWORD nInBufferSize,
         DWORD nDefaultTimeOut,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeW(
         LPCWSTR lpNamedPipeName,
         DWORD nTimeOut
    );
# 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameW(
         HANDLE Pipe,
                                                 LPWSTR ClientComputerName,
         ULONG ClientComputerNameLength
    );
# 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
ImpersonateNamedPipeClient(
         HANDLE hNamedPipe
    );
# 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeInfo(
         HANDLE hNamedPipe,
              LPDWORD lpFlags,
              LPDWORD lpOutBufferSize,
              LPDWORD lpInBufferSize,
              LPDWORD lpMaxInstances
    );


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateW(
         HANDLE hNamedPipe,
              LPDWORD lpState,
              LPDWORD lpCurInstances,
              LPDWORD lpMaxCollectionCount,
              LPDWORD lpCollectDataTimeout,
                                       LPWSTR lpUserName,
         DWORD nMaxUserNameSize
    );
# 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeW(
         LPCWSTR lpNamedPipeName,
                                        LPVOID lpInBuffer,
         DWORD nInBufferSize,
                                                            LPVOID lpOutBuffer,
         DWORD nOutBufferSize,
          LPDWORD lpBytesRead,
         DWORD nTimeOut
    );
# 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namedpipeapi.h" 3
}
# 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\profileapi.h" 1 3
# 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\profileapi.h" 3
extern "C" {
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\profileapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceCounter(
          LARGE_INTEGER * lpPerformanceCount
    );


__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceFrequency(
          LARGE_INTEGER * lpFrequency
    );






}
# 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 1 3
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
extern "C" {




#pragma warning(push)
#pragma warning(disable: 4820)
# 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;
# 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
__declspec(dllimport)

HANDLE
__stdcall
HeapCreate(
         DWORD flOptions,
         SIZE_T dwInitialSize,
         SIZE_T dwMaximumSize
    );


__declspec(dllimport)
BOOL
__stdcall
HeapDestroy(
         HANDLE hHeap
    );


__declspec(dllimport)


__declspec(allocator)
LPVOID
__stdcall
HeapAlloc(
         HANDLE hHeap,
         DWORD dwFlags,
         SIZE_T dwBytes
    );


__declspec(dllimport)



__declspec(allocator)
LPVOID
__stdcall
HeapReAlloc(
            HANDLE hHeap,
         DWORD dwFlags,
                    LPVOID lpMem,
         SIZE_T dwBytes
    );


__declspec(dllimport)

BOOL
__stdcall
HeapFree(
            HANDLE hHeap,
         DWORD dwFlags,
                                        LPVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapSize(
         HANDLE hHeap,
         DWORD dwFlags,
         LPCVOID lpMem
    );


__declspec(dllimport)
HANDLE
__stdcall
GetProcessHeap(
    void
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapCompact(
         HANDLE hHeap,
         DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
HeapSetInformation(
             HANDLE HeapHandle,
         HEAP_INFORMATION_CLASS HeapInformationClass,
                                                PVOID HeapInformation,
         SIZE_T HeapInformationLength
    );
# 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
HeapValidate(
         HANDLE hHeap,
         DWORD dwFlags,
             LPCVOID lpMem
    );
# 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
BOOL
__stdcall
HeapSummary(
         HANDLE hHeap,
         DWORD dwFlags,
          LPHEAP_SUMMARY lpSummary
    );
# 227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetProcessHeaps(
         DWORD NumberOfHeaps,
                                           PHANDLE ProcessHeaps
    );


__declspec(dllimport)
BOOL
__stdcall
HeapLock(
         HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapUnlock(
         HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapWalk(
         HANDLE hHeap,
            LPPROCESS_HEAP_ENTRY lpEntry
    );


__declspec(dllimport)
BOOL
__stdcall
HeapQueryInformation(
             HANDLE HeapHandle,
         HEAP_INFORMATION_CLASS HeapInformationClass,
                                                                    PVOID HeapInformation,
         SIZE_T HeapInformationLength,
              PSIZE_T ReturnLength
    );
# 282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\heapapi.h" 3
#pragma warning(pop)



}
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 1 3
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
extern "C" {
# 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateIoCompletionPort(
         HANDLE FileHandle,
             HANDLE ExistingCompletionPort,
         ULONG_PTR CompletionKey,
         DWORD NumberOfConcurrentThreads
    );


__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatus(
         HANDLE CompletionPort,
          LPDWORD lpNumberOfBytesTransferred,
          PULONG_PTR lpCompletionKey,
          LPOVERLAPPED * lpOverlapped,
         DWORD dwMilliseconds
    );





__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatusEx(
         HANDLE CompletionPort,
                                                   LPOVERLAPPED_ENTRY lpCompletionPortEntries,
         ULONG ulCount,
          PULONG ulNumEntriesRemoved,
         DWORD dwMilliseconds,
         BOOL fAlertable
    );




__declspec(dllimport)
BOOL
__stdcall
PostQueuedCompletionStatus(
         HANDLE CompletionPort,
         DWORD dwNumberOfBytesTransferred,
         ULONG_PTR dwCompletionKey,
             LPOVERLAPPED lpOverlapped
    );
# 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
DeviceIoControl(
         HANDLE hDevice,
         DWORD dwIoControlCode,
                                        LPVOID lpInBuffer,
         DWORD nInBufferSize,
                                                                LPVOID lpOutBuffer,
         DWORD nOutBufferSize,
              LPDWORD lpBytesReturned,
                LPOVERLAPPED lpOverlapped
    );
# 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResult(
         HANDLE hFile,
         LPOVERLAPPED lpOverlapped,
          LPDWORD lpNumberOfBytesTransferred,
         BOOL bWait
    );





__declspec(dllimport)
BOOL
__stdcall
CancelIoEx(
         HANDLE hFile,
             LPOVERLAPPED lpOverlapped
    );
# 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
CancelIo(
         HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResultEx(
         HANDLE hFile,
         LPOVERLAPPED lpOverlapped,
          LPDWORD lpNumberOfBytesTransferred,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
# 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
CancelSynchronousIo(
         HANDLE hThread
    );
# 227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\ioapiset.h" 3
}
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 1 3
# 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
extern "C" {
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
# 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
void
__stdcall
InitializeSRWLock(
          PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockExclusive(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockShared(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockExclusive(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockShared(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockExclusive(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockShared(
            PSRWLOCK SRWLock
    );
# 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
void
__stdcall
InitializeCriticalSection(
          LPCRITICAL_SECTION lpCriticalSection
    );




__declspec(dllimport)
void
__stdcall
EnterCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeCriticalSectionAndSpinCount(
          LPCRITICAL_SECTION lpCriticalSection,
         DWORD dwSpinCount
    );





__declspec(dllimport)
BOOL
__stdcall
InitializeCriticalSectionEx(
          LPCRITICAL_SECTION lpCriticalSection,
         DWORD dwSpinCount,
         DWORD Flags
    );




__declspec(dllimport)
DWORD
__stdcall
SetCriticalSectionSpinCount(
            LPCRITICAL_SECTION lpCriticalSection,
         DWORD dwSpinCount
    );





__declspec(dllimport)
BOOL
__stdcall
TryEnterCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );




__declspec(dllimport)
void
__stdcall
DeleteCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );
# 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;
# 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
typedef
BOOL
(__stdcall *PINIT_ONCE_FN) (
            PINIT_ONCE InitOnce,
                PVOID Parameter,
                                  PVOID *Context
    );







__declspec(dllimport)
void
__stdcall
InitOnceInitialize(
          PINIT_ONCE InitOnce
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceExecuteOnce(
            PINIT_ONCE InitOnce,
                    PINIT_ONCE_FN InitFn,
                PVOID Parameter,
                                  LPVOID * Context
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceBeginInitialize(
            LPINIT_ONCE lpInitOnce,
         DWORD dwFlags,
          PBOOL fPending,
                                  LPVOID * lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceComplete(
            LPINIT_ONCE lpInitOnce,
         DWORD dwFlags,
             LPVOID lpContext
    );
# 330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;
# 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
void
__stdcall
InitializeConditionVariable(
          PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeConditionVariable(
            PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeAllConditionVariable(
            PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableCS(
            PCONDITION_VARIABLE ConditionVariable,
            PCRITICAL_SECTION CriticalSection,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableSRW(
            PCONDITION_VARIABLE ConditionVariable,
            PSRWLOCK SRWLock,
         DWORD dwMilliseconds,
         ULONG Flags
    );
# 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetEvent(
         HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ResetEvent(
         HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseSemaphore(
         HANDLE hSemaphore,
         LONG lReleaseCount,
              LPLONG lpPreviousCount
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseMutex(
         HANDLE hMutex
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObject(
         HANDLE hHandle,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
DWORD
__stdcall
SleepEx(
         DWORD dwMilliseconds,
         BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObjectEx(
         HANDLE hHandle,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjectsEx(
         DWORD nCount,
                       const HANDLE * lpHandles,
         BOOL bWaitAll,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
# 484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateMutexA(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
         BOOL bInitialOwner,
             LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateMutexW(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
         BOOL bInitialOwner,
             LPCWSTR lpName
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenMutexW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateEventA(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
         BOOL bManualReset,
         BOOL bInitialState,
             LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateEventW(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
         BOOL bManualReset,
         BOOL bInitialState,
             LPCWSTR lpName
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenEventA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
OpenEventW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenSemaphoreW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );
# 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
typedef
void
(__stdcall *PTIMERAPCROUTINE)(
             LPVOID lpArgToCompletionRoutine,
             DWORD dwTimerLowValue,
             DWORD dwTimerHighValue
    );

__declspec(dllimport)

HANDLE
__stdcall
OpenWaitableTimerW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpTimerName
    );
# 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetWaitableTimer(
         HANDLE hTimer,
         const LARGE_INTEGER * lpDueTime,
         LONG lPeriod,
             PTIMERAPCROUTINE pfnCompletionRoutine,
             LPVOID lpArgToCompletionRoutine,
         BOOL fResume
    );


__declspec(dllimport)
BOOL
__stdcall
CancelWaitableTimer(
         HANDLE hTimer
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateMutexExA(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
             LPCSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateMutexExW(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
             LPCWSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );
# 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateEventExA(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
             LPCSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateEventExW(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
             LPCWSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreExW(
             LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
         LONG lInitialCount,
         LONG lMaximumCount,
             LPCWSTR lpName,
               DWORD dwFlags,
         DWORD dwDesiredAccess
    );
# 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerExW(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             LPCWSTR lpTimerName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );
# 777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;





BOOL
__stdcall
EnterSynchronizationBarrier(
            LPSYNCHRONIZATION_BARRIER lpBarrier,
         DWORD dwFlags
    );


BOOL
__stdcall
InitializeSynchronizationBarrier(
          LPSYNCHRONIZATION_BARRIER lpBarrier,
         LONG lTotalThreads,
         LONG lSpinCount
    );


BOOL
__stdcall
DeleteSynchronizationBarrier(
            LPSYNCHRONIZATION_BARRIER lpBarrier
    );
# 816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
void
__stdcall
Sleep(
         DWORD dwMilliseconds
    );


BOOL
__stdcall
WaitOnAddress(
                                  volatile void * Address,
                                  PVOID CompareAddress,
         SIZE_T AddressSize,
             DWORD dwMilliseconds
    );


void
__stdcall
WakeByAddressSingle(
         PVOID Address
    );


void
__stdcall
WakeByAddressAll(
         PVOID Address
    );
# 857 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
         HANDLE hObjectToSignal,
         HANDLE hObjectToWaitOn,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
# 884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjects(
         DWORD nCount,
                       const HANDLE * lpHandles,
         BOOL bWaitAll,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateSemaphoreW(
             LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
         LONG lInitialCount,
         LONG lMaximumCount,
             LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerW(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
         BOOL bManualReset,
             LPCWSTR lpTimerName
    );
# 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\synchapi.h" 3
}
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\interlockedapi.h" 1 3
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\interlockedapi.h" 3
extern "C" {
# 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\interlockedapi.h" 3
__declspec(dllimport)
void
__stdcall
InitializeSListHead(
          PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPopEntrySList(
            PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushEntrySList(
            PSLIST_HEADER ListHead,
                             PSLIST_ENTRY ListEntry
    );
# 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\interlockedapi.h" 3
__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedFlushSList(
            PSLIST_HEADER ListHead
    );


__declspec(dllimport)
USHORT
__stdcall
QueryDepthSList(
         PSLIST_HEADER ListHead
    );
# 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\interlockedapi.h" 3
}
# 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 1 3
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
extern "C" {
# 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;




typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
# 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
QueueUserAPC(
         PAPCFUNC pfnAPC,
         HANDLE hThread,
         ULONG_PTR dwData
    );




__declspec(dllimport)
BOOL
__stdcall
GetProcessTimes(
         HANDLE hProcess,
          LPFILETIME lpCreationTime,
          LPFILETIME lpExitTime,
          LPFILETIME lpKernelTime,
          LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
GetCurrentProcess(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessId(
    void
    );
# 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitProcess(
         UINT uExitCode
    );
# 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
TerminateProcess(
         HANDLE hProcess,
         UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
GetExitCodeProcess(
         HANDLE hProcess,
          LPDWORD lpExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
SwitchToThread(
    void
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateThread(
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         SIZE_T dwStackSize,
         LPTHREAD_START_ROUTINE lpStartAddress,
                              LPVOID lpParameter,
         DWORD dwCreationFlags,
              LPDWORD lpThreadId
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateRemoteThread(
         HANDLE hProcess,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         SIZE_T dwStackSize,
         LPTHREAD_START_ROUTINE lpStartAddress,
             LPVOID lpParameter,
         DWORD dwCreationFlags,
              LPDWORD lpThreadId
    );
# 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
GetCurrentThread(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentThreadId(
    void
    );


__declspec(dllimport)

HANDLE
__stdcall
OpenThread(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwThreadId
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriority(
         HANDLE hThread,
         int nPriority
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriorityBoost(
         HANDLE hThread,
         BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadPriorityBoost(
         HANDLE hThread,
          PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
int
__stdcall
GetThreadPriority(
         HANDLE hThread
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitThread(
         DWORD dwExitCode
    );







__declspec(dllimport)
BOOL
__stdcall
TerminateThread(
         HANDLE hThread,
         DWORD dwExitCode
    );
# 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
GetExitCodeThread(
         HANDLE hThread,
          LPDWORD lpExitCode
    );


__declspec(dllimport)
DWORD
__stdcall
SuspendThread(
         HANDLE hThread
    );


__declspec(dllimport)
DWORD
__stdcall
ResumeThread(
         HANDLE hThread
    );







__declspec(dllimport)
DWORD
__stdcall
TlsAlloc(
    void
    );


__declspec(dllimport)
LPVOID
__stdcall
TlsGetValue(
         DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
TlsSetValue(
         DWORD dwTlsIndex,
             LPVOID lpTlsValue
    );


__declspec(dllimport)
BOOL
__stdcall
TlsFree(
         DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
CreateProcessA(
             LPCSTR lpApplicationName,
                LPSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCSTR lpCurrentDirectory,
         LPSTARTUPINFOA lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessW(
             LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCWSTR lpCurrentDirectory,
         LPSTARTUPINFOW lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );
# 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetProcessShutdownParameters(
         DWORD dwLevel,
         DWORD dwFlags
    );


__declspec(dllimport)
DWORD
__stdcall
GetProcessVersion(
         DWORD ProcessId
    );


__declspec(dllimport)
void
__stdcall
GetStartupInfoW(
          LPSTARTUPINFOW lpStartupInfo
    );





__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserW(
             HANDLE hToken,
             LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCWSTR lpCurrentDirectory,
         LPSTARTUPINFOW lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );
# 566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
SetThreadToken(
             PHANDLE Thread,
             HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
OpenProcessToken(
         HANDLE ProcessHandle,
         DWORD DesiredAccess,
             PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
OpenThreadToken(
         HANDLE ThreadHandle,
         DWORD DesiredAccess,
         BOOL OpenAsSelf,
             PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetPriorityClass(
         HANDLE hProcess,
         DWORD dwPriorityClass
    );


__declspec(dllimport)
DWORD
__stdcall
GetPriorityClass(
         HANDLE hProcess
    );
# 621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetThreadStackGuarantee(
            PULONG StackSizeInBytes
    );


__declspec(dllimport)
BOOL
__stdcall
ProcessIdToSessionId(
         DWORD dwProcessId,
          DWORD * pSessionId
    );


typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;
# 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetProcessId(
         HANDLE Process
    );







__declspec(dllimport)
DWORD
__stdcall
GetThreadId(
         HANDLE Thread
    );







__declspec(dllimport)
void
__stdcall
FlushProcessWriteBuffers(
    void
    );
# 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetProcessIdOfThread(
         HANDLE Thread
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeProcThreadAttributeList(
                                                LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
         DWORD dwAttributeCount,
               DWORD dwFlags,
                                                                                          PSIZE_T lpSize
    );


__declspec(dllimport)
void
__stdcall
DeleteProcThreadAttributeList(
            LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );




__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityUpdateMode(
         HANDLE hProcess,
         DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessAffinityUpdateMode(
         HANDLE hProcess,
              LPDWORD lpdwFlags
    );




__declspec(dllimport)
BOOL
__stdcall
UpdateProcThreadAttribute(
            LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
         DWORD dwFlags,
         DWORD_PTR Attribute,
                                 PVOID lpValue,
         SIZE_T cbSize,
                                   PVOID lpPreviousValue,
             PSIZE_T lpReturnSize
    );
# 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateRemoteThreadEx(
         HANDLE hProcess,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         SIZE_T dwStackSize,
         LPTHREAD_START_ROUTINE lpStartAddress,
             LPVOID lpParameter,
         DWORD dwCreationFlags,
             LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
              LPDWORD lpThreadId
    );
# 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetThreadContext(
         HANDLE hThread,
            LPCONTEXT lpContext
    );
# 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetThreadContext(
         HANDLE hThread,
         const CONTEXT * lpContext
    );
# 883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FlushInstructionCache(
         HANDLE hProcess,
                                 LPCVOID lpBaseAddress,
         SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadTimes(
         HANDLE hThread,
          LPFILETIME lpCreationTime,
          LPFILETIME lpExitTime,
          LPFILETIME lpKernelTime,
          LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenProcess(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
IsProcessorFeaturePresent(
         DWORD ProcessorFeature
    );
# 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetProcessHandleCount(
         HANDLE hProcess,
          PDWORD pdwHandleCount
    );
# 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessorNumber(
    void
    );
# 1021 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetProcessPriorityBoost(
         HANDLE hProcess,
          PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessPriorityBoost(
         HANDLE hProcess,
         BOOL bDisablePriorityBoost
    );
# 1051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetThreadIOPendingFlag(
         HANDLE hThread,
          PBOOL lpIOIsPending
    );


__declspec(dllimport)
BOOL
__stdcall
GetSystemTimes(
              PFILETIME lpIdleTime,
              PFILETIME lpKernelTime,
              PFILETIME lpUserTime
    );
# 1076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
typedef enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax
} THREAD_INFORMATION_CLASS;
# 1124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
typedef struct _THREAD_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} THREAD_POWER_THROTTLING_STATE;
# 1185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
SetThreadIdealProcessor(
         HANDLE hThread,
         DWORD dwIdealProcessor
    );
# 1201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessInformationClassMax
} PROCESS_INFORMATION_CLASS;

typedef struct _APP_MEMORY_INFORMATION {
    ULONG64 AvailableCommit;
    ULONG64 PrivateCommitUsage;
    ULONG64 PeakPrivateCommitUsage;
    ULONG64 TotalCommitUsage;
} APP_MEMORY_INFORMATION, *PAPP_MEMORY_INFORMATION;
# 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax
} PROCESS_MEMORY_EXHAUSTION_TYPE, *PPROCESS_MEMORY_EXHAUSTION_TYPE;




typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
    USHORT Version;
    USHORT Reserved;
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ULONG_PTR Value;
} PROCESS_MEMORY_EXHAUSTION_INFO, *PPROCESS_MEMORY_EXHAUSTION_INFO;







typedef struct _PROCESS_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} PROCESS_POWER_THROTTLING_STATE, *PPROCESS_POWER_THROTTLING_STATE;

typedef struct PROCESS_PROTECTION_LEVEL_INFORMATION {
    DWORD ProtectionLevel;
} PROCESS_PROTECTION_LEVEL_INFORMATION;
# 1351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserA(
             HANDLE hToken,
             LPCSTR lpApplicationName,
                LPSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCSTR lpCurrentDirectory,
         LPSTARTUPINFOA lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );






__declspec(dllimport)
BOOL
__stdcall
GetProcessShutdownParameters(
          LPDWORD lpdwLevel,
          LPDWORD lpdwFlags
    );





__declspec(dllimport)
HRESULT
__stdcall
SetThreadDescription(
         HANDLE hThread,
         PCWSTR lpThreadDescription
    );


__declspec(dllimport)
HRESULT
__stdcall
GetThreadDescription(
         HANDLE hThread,
                      PWSTR * ppszThreadDescription
    );
# 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processthreadsapi.h" 3
}
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 1 3
# 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
#pragma warning(disable: 4514)

#pragma warning(disable: 4103)



#pragma warning(push)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)
# 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
extern "C" {
# 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } ;
    } ;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;
# 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

__declspec(dllimport)
BOOL
__stdcall
GlobalMemoryStatusEx(
          LPMEMORYSTATUSEX lpBuffer
    );


__declspec(dllimport)
void
__stdcall
GetSystemInfo(
          LPSYSTEM_INFO lpSystemInfo
    );


__declspec(dllimport)
void
__stdcall
GetSystemTime(
          LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemTimeAsFileTime(
          LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
void
__stdcall
GetLocalTime(
          LPSYSTEMTIME lpSystemTime
    );
# 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(deprecated)
__declspec(dllimport)

DWORD
__stdcall
GetVersion(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetLocalTime(
         const SYSTEMTIME * lpSystemTime
    );
# 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetTickCount(
    void
    );





__declspec(dllimport)
ULONGLONG
__stdcall
GetTickCount64(
    void
    );
# 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
GetSystemTimeAdjustment(
          PDWORD lpTimeAdjustment,
          PDWORD lpTimeIncrement,
          PBOOL lpTimeAdjustmentDisabled
    );


__declspec(dllimport)

UINT
__stdcall
GetSystemDirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)

UINT
__stdcall
GetSystemDirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );







__declspec(dllimport)


UINT
__stdcall
GetWindowsDirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)


UINT
__stdcall
GetWindowsDirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );







__declspec(dllimport)

UINT
__stdcall
GetSystemWindowsDirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)

UINT
__stdcall
GetSystemWindowsDirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );
# 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
# 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameExA(
         COMPUTER_NAME_FORMAT NameType,
                                            LPSTR lpBuffer,
            LPDWORD nSize
    );

__declspec(dllimport)

BOOL
__stdcall
GetComputerNameExW(
         COMPUTER_NAME_FORMAT NameType,
                                            LPWSTR lpBuffer,
            LPDWORD nSize
    );
# 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExW(
         COMPUTER_NAME_FORMAT NameType,
         LPCWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
SetSystemTime(
         const SYSTEMTIME * lpSystemTime
    );
# 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(deprecated)
__declspec(dllimport)

BOOL
__stdcall
GetVersionExA(
            LPOSVERSIONINFOA lpVersionInformation
    );

__declspec(deprecated)
__declspec(dllimport)

BOOL
__stdcall
GetVersionExW(
            LPOSVERSIONINFOW lpVersionInformation
    );







__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformation(
                                                                PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
            PDWORD ReturnedLength
    );
# 495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)
void
__stdcall
GetNativeSystemInfo(
          LPSYSTEM_INFO lpSystemInfo
    );
# 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetProductInfo(
         DWORD dwOSMajorVersion,
         DWORD dwOSMinorVersion,
         DWORD dwSpMajorVersion,
         DWORD dwSpMinorVersion,
          PDWORD pdwReturnedProductType
    );







__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
         ULONGLONG ConditionMask,
         ULONG TypeMask,
         UCHAR Condition
    );
# 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)
UINT
__stdcall
EnumSystemFirmwareTables(
         DWORD FirmwareTableProviderSignature,
                                                  PVOID pFirmwareTableEnumBuffer,
         DWORD BufferSize
    );


__declspec(dllimport)
UINT
__stdcall
GetSystemFirmwareTable(
         DWORD FirmwareTableProviderSignature,
         DWORD FirmwareTableID,
                                                  PVOID pFirmwareTableBuffer,
         DWORD BufferSize
    );
# 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameExW(
         LPCWSTR Hostname,
                                            LPWSTR ComputerName,
            LPDWORD nSize
    );


__declspec(dllimport)

BOOL
__stdcall
GetPhysicallyInstalledSystemMemory(
          PULONGLONG TotalMemoryInKilobytes
    );




__declspec(dllimport)
BOOL
__stdcall
SetComputerNameEx2W(
         COMPUTER_NAME_FORMAT NameType,
         DWORD Flags,
         LPCWSTR lpBuffer
    );






__declspec(dllimport)

BOOL
__stdcall
SetSystemTimeAdjustment(
         DWORD dwTimeAdjustment,
         BOOL bTimeAdjustmentDisabled
    );


__declspec(dllimport)
BOOL
__stdcall
InstallELAMCertificateInfo(
         HANDLE ELAMFile
    );
# 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameA(
         LPCSTR lpComputerName
    );

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameW(
         LPCWSTR lpComputerName
    );







__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExA(
         COMPUTER_NAME_FORMAT NameType,
         LPCSTR lpBuffer
    );
# 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\sysinfoapi.h" 3
}






#pragma warning(pop)
# 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 1 3
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
extern "C" {




#pragma warning(push)
#pragma warning(disable: 4668)
# 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)

LPVOID
__stdcall
VirtualAlloc(
             LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flAllocationType,
         DWORD flProtect
    );


__declspec(dllimport)

BOOL
__stdcall
VirtualProtect(
         LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flNewProtect,
          PDWORD lpflOldProtect
    );
# 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
VirtualFree(
                                                                                                                           LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD dwFreeType
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQuery(
             LPCVOID lpAddress,
                                            PMEMORY_BASIC_INFORMATION lpBuffer,
         SIZE_T dwLength
    );
# 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)

LPVOID
__stdcall
VirtualAllocEx(
         HANDLE hProcess,
             LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flAllocationType,
         DWORD flProtect
    );
# 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
VirtualFreeEx(
         HANDLE hProcess,
                                                                                                                           LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD dwFreeType
    );


__declspec(dllimport)

BOOL
__stdcall
VirtualProtectEx(
         HANDLE hProcess,
         LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flNewProtect,
          PDWORD lpflOldProtect
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQueryEx(
         HANDLE hProcess,
             LPCVOID lpAddress,
                                            PMEMORY_BASIC_INFORMATION lpBuffer,
         SIZE_T dwLength
    );


__declspec(dllimport)

BOOL
__stdcall
ReadProcessMemory(
         HANDLE hProcess,
         LPCVOID lpBaseAddress,
                                                       LPVOID lpBuffer,
         SIZE_T nSize,
              SIZE_T * lpNumberOfBytesRead
    );


__declspec(dllimport)

BOOL
__stdcall
WriteProcessMemory(
         HANDLE hProcess,
         LPVOID lpBaseAddress,
                            LPCVOID lpBuffer,
         SIZE_T nSize,
              SIZE_T * lpNumberOfBytesWritten
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingW(
         HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
         DWORD flProtect,
         DWORD dwMaximumSizeHigh,
         DWORD dwMaximumSizeLow,
             LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
OpenFileMappingW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );






__declspec(dllimport)

LPVOID
__stdcall
MapViewOfFile(
         HANDLE hFileMappingObject,
         DWORD dwDesiredAccess,
         DWORD dwFileOffsetHigh,
         DWORD dwFileOffsetLow,
         SIZE_T dwNumberOfBytesToMap
    );


__declspec(dllimport)

LPVOID
__stdcall
MapViewOfFileEx(
         HANDLE hFileMappingObject,
         DWORD dwDesiredAccess,
         DWORD dwFileOffsetHigh,
         DWORD dwFileOffsetLow,
         SIZE_T dwNumberOfBytesToMap,
             LPVOID lpBaseAddress
    );
# 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FlushViewOfFile(
         LPCVOID lpBaseAddress,
         SIZE_T dwNumberOfBytesToFlush
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile(
         LPCVOID lpBaseAddress
    );
# 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)
SIZE_T
__stdcall
GetLargePageMinimum(
    void
    );


__declspec(dllimport)

BOOL
__stdcall
GetProcessWorkingSetSizeEx(
         HANDLE hProcess,
          PSIZE_T lpMinimumWorkingSetSize,
          PSIZE_T lpMaximumWorkingSetSize,
          PDWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSizeEx(
         HANDLE hProcess,
         SIZE_T dwMinimumWorkingSetSize,
         SIZE_T dwMaximumWorkingSetSize,
         DWORD Flags
    );
# 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
VirtualLock(
         LPVOID lpAddress,
         SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualUnlock(
         LPVOID lpAddress,
         SIZE_T dwSize
    );
# 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)

UINT
__stdcall
GetWriteWatch(
         DWORD dwFlags,
         PVOID lpBaseAddress,
         SIZE_T dwRegionSize,
                                                PVOID * lpAddresses,
                ULONG_PTR * lpdwCount,
              LPDWORD lpdwGranularity
    );


__declspec(dllimport)
UINT
__stdcall
ResetWriteWatch(
         LPVOID lpBaseAddress,
         SIZE_T dwRegionSize
    );
# 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;

__declspec(dllimport)

HANDLE
__stdcall
CreateMemoryResourceNotification(
         MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );


__declspec(dllimport)

BOOL
__stdcall
QueryMemoryResourceNotification(
         HANDLE ResourceNotificationHandle,
          PBOOL ResourceState
    );
# 477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
GetSystemFileCacheSize(
          PSIZE_T lpMinimumFileCacheSize,
          PSIZE_T lpMaximumFileCacheSize,
          PDWORD lpFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetSystemFileCacheSize(
         SIZE_T MinimumFileCacheSize,
         SIZE_T MaximumFileCacheSize,
         DWORD Flags
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingNumaW(
         HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
         DWORD flProtect,
         DWORD dwMaximumSizeHigh,
         DWORD dwMaximumSizeLow,
             LPCWSTR lpName,
         DWORD nndPreferred
    );
# 609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
AllocateUserPhysicalPages(
         HANDLE hProcess,
            PULONG_PTR NumberOfPages,
                                                    PULONG_PTR PageArray
    );


__declspec(dllimport)

BOOL
__stdcall
FreeUserPhysicalPages(
         HANDLE hProcess,
            PULONG_PTR NumberOfPages,
                               PULONG_PTR PageArray
    );


__declspec(dllimport)

BOOL
__stdcall
MapUserPhysicalPages(
         PVOID VirtualAddress,
         ULONG_PTR NumberOfPages,
                                  PULONG_PTR PageArray
    );







__declspec(dllimport)

BOOL
__stdcall
AllocateUserPhysicalPagesNuma(
         HANDLE hProcess,
            PULONG_PTR NumberOfPages,
                                                    PULONG_PTR PageArray,
         DWORD nndPreferred
    );


__declspec(dllimport)

LPVOID
__stdcall
VirtualAllocExNuma(
         HANDLE hProcess,
             LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flAllocationType,
         DWORD flProtect,
         DWORD nndPreferred
    );
# 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\memoryapi.h" 3
#pragma warning(pop)



}
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\enclaveapi.h" 1 3
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\enclaveapi.h" 3
extern "C" {
# 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\enclaveapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
IsEnclaveTypeSupported(
         DWORD flEnclaveType
    );


__declspec(dllimport)

LPVOID
__stdcall
CreateEnclave(
         HANDLE hProcess,
             LPVOID lpAddress,
         SIZE_T dwSize,
         SIZE_T dwInitialCommitment,
         DWORD flEnclaveType,
                                   LPCVOID lpEnclaveInformation,
         DWORD dwInfoLength,
              LPDWORD lpEnclaveError
    );


__declspec(dllimport)

BOOL
__stdcall
LoadEnclaveData(
         HANDLE hProcess,
         LPVOID lpAddress,
                            LPCVOID lpBuffer,
         SIZE_T nSize,
         DWORD flProtect,
                                   LPCVOID lpPageInformation,
         DWORD dwInfoLength,
          PSIZE_T lpNumberOfBytesWritten,
              LPDWORD lpEnclaveError
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeEnclave(
         HANDLE hProcess,
         LPVOID lpAddress,
                                   LPCVOID lpEnclaveInformation,
         DWORD dwInfoLength,
              LPDWORD lpEnclaveError
    );
# 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\enclaveapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
LoadEnclaveImageA(
         LPVOID lpEnclaveAddress,
         LPCSTR lpImageName
    );

__declspec(dllimport)

BOOL
__stdcall
LoadEnclaveImageW(
         LPVOID lpEnclaveAddress,
         LPCWSTR lpImageName
    );







__declspec(dllimport)

BOOL
__stdcall
CallEnclave(
         LPENCLAVE_ROUTINE lpRoutine,
         LPVOID lpParameter,
         BOOL fWaitForThread,
          LPVOID * lpReturnValue
    );


__declspec(dllimport)

BOOL
__stdcall
TerminateEnclave(
         LPVOID lpAddress,
         BOOL fWait
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteEnclave(
         LPVOID lpAddress
    );
# 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\enclaveapi.h" 3
}
# 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoollegacyapiset.h" 1 3
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoollegacyapiset.h" 3
extern "C" {
# 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoollegacyapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
QueueUserWorkItem(
         LPTHREAD_START_ROUTINE Function,
             PVOID Context,
         ULONG Flags
    );


__declspec(dllimport)

BOOL
__stdcall
UnregisterWaitEx(
         HANDLE WaitHandle,
             HANDLE CompletionEvent
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateTimerQueue(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
CreateTimerQueueTimer(
             PHANDLE phNewTimer,
             HANDLE TimerQueue,
         WAITORTIMERCALLBACK Callback,
             PVOID Parameter,
         DWORD DueTime,
         DWORD Period,
         ULONG Flags
    );


__declspec(dllimport)

BOOL
__stdcall
ChangeTimerQueueTimer(
             HANDLE TimerQueue,
            HANDLE Timer,
         ULONG DueTime,
         ULONG Period
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueTimer(
             HANDLE TimerQueue,
         HANDLE Timer,
             HANDLE CompletionEvent
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueEx(
         HANDLE TimerQueue,
             HANDLE CompletionEvent
    );






}
# 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoolapiset.h" 1 3
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoolapiset.h" 3
extern "C" {
# 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoolapiset.h" 3
typedef
void
(__stdcall *PTP_WIN32_IO_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PVOID Overlapped,
                ULONG IoResult,
                ULONG_PTR NumberOfBytesTransferred,
                PTP_IO Io
    );




__declspec(dllimport)

PTP_POOL
__stdcall
CreateThreadpool(
               PVOID reserved
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolThreadMaximum(
            PTP_POOL ptpp,
         DWORD cthrdMost
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolThreadMinimum(
            PTP_POOL ptpp,
         DWORD cthrdMic
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolStackInformation(
            PTP_POOL ptpp,
         PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
BOOL
__stdcall
QueryThreadpoolStackInformation(
         PTP_POOL ptpp,
          PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpool(
            PTP_POOL ptpp
    );


__declspec(dllimport)

PTP_CLEANUP_GROUP
__stdcall
CreateThreadpoolCleanupGroup(
    void
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroupMembers(
            PTP_CLEANUP_GROUP ptpcg,
         BOOL fCancelPendingCallbacks,
                PVOID pvCleanupContext
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroup(
            PTP_CLEANUP_GROUP ptpcg
    );


__declspec(dllimport)
void
__stdcall
SetEventWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HANDLE evt
    );


__declspec(dllimport)
void
__stdcall
ReleaseSemaphoreWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HANDLE sem,
         DWORD crel
    );


__declspec(dllimport)
void
__stdcall
ReleaseMutexWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HANDLE mut
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSectionWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
            PCRITICAL_SECTION pcs
    );


__declspec(dllimport)
void
__stdcall
FreeLibraryWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HMODULE mod
    );


__declspec(dllimport)
BOOL
__stdcall
CallbackMayRunLong(
            PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
void
__stdcall
DisassociateCurrentThreadFromCallback(
            PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)

BOOL
__stdcall
TrySubmitThreadpoolCallback(
         PTP_SIMPLE_CALLBACK pfns,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)

PTP_WORK
__stdcall
CreateThreadpoolWork(
         PTP_WORK_CALLBACK pfnwk,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SubmitThreadpoolWork(
            PTP_WORK pwk
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWorkCallbacks(
            PTP_WORK pwk,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWork(
            PTP_WORK pwk
    );


__declspec(dllimport)

PTP_TIMER
__stdcall
CreateThreadpoolTimer(
         PTP_TIMER_CALLBACK pfnti,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolTimer(
            PTP_TIMER pti,
             PFILETIME pftDueTime,
         DWORD msPeriod,
             DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
IsThreadpoolTimerSet(
            PTP_TIMER pti
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolTimerCallbacks(
            PTP_TIMER pti,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolTimer(
            PTP_TIMER pti
    );


__declspec(dllimport)

PTP_WAIT
__stdcall
CreateThreadpoolWait(
         PTP_WAIT_CALLBACK pfnwa,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolWait(
            PTP_WAIT pwa,
             HANDLE h,
             PFILETIME pftTimeout
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWaitCallbacks(
            PTP_WAIT pwa,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWait(
            PTP_WAIT pwa
    );


__declspec(dllimport)

PTP_IO
__stdcall
CreateThreadpoolIo(
         HANDLE fl,
         PTP_WIN32_IO_CALLBACK pfnio,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
StartThreadpoolIo(
            PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
CancelThreadpoolIo(
            PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolIoCallbacks(
            PTP_IO pio,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolIo(
            PTP_IO pio
    );





__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolTimerEx(
            PTP_TIMER pti,
             PFILETIME pftDueTime,
         DWORD msPeriod,
             DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolWaitEx(
            PTP_WAIT pwa,
             HANDLE h,
             PFILETIME pftTimeout,
               PVOID Reserved
    );
# 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\threadpoolapiset.h" 3
}
# 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi.h" 1 3
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi.h" 3
extern "C" {
# 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsProcessInJob(
         HANDLE ProcessHandle,
             HANDLE JobHandle,
          PBOOL Result
    );
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi.h" 3
}
# 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi2.h" 1 3
# 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi2.h" 3
extern "C" {







typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PCWSTR VolumeName;
    ULONG BaseIoSize;
    ULONG ControlFlags;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION;

__declspec(dllimport)
HANDLE
__stdcall
CreateJobObjectW(
             LPSECURITY_ATTRIBUTES lpJobAttributes,
             LPCWSTR lpName
    );




__declspec(dllimport)
void
__stdcall
FreeMemoryJobObject(
                     void * Buffer
    );



__declspec(dllimport)
HANDLE
__stdcall
OpenJobObjectW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );



__declspec(dllimport)
BOOL
__stdcall
AssignProcessToJobObject(
         HANDLE hJob,
         HANDLE hProcess
    );



__declspec(dllimport)
BOOL
__stdcall
TerminateJobObject(
         HANDLE hJob,
         UINT uExitCode
    );



__declspec(dllimport)
BOOL
__stdcall
SetInformationJobObject(
         HANDLE hJob,
         JOBOBJECTINFOCLASS JobObjectInformationClass,
                                                   LPVOID lpJobObjectInformation,
         DWORD cbJobObjectInformationLength
    );




__declspec(dllimport)
DWORD
__stdcall
SetIoRateControlInformationJobObject(
         HANDLE hJob,
         JOBOBJECT_IO_RATE_CONTROL_INFORMATION * IoRateControlInfo
    );



__declspec(dllimport)
BOOL
__stdcall
QueryInformationJobObject(
             HANDLE hJob,
         JOBOBJECTINFOCLASS JobObjectInformationClass,
                                                                         LPVOID lpJobObjectInformation,
         DWORD cbJobObjectInformationLength,
              LPDWORD lpReturnLength
    );




__declspec(dllimport)
DWORD
__stdcall
QueryIoRateControlInformationJobObject(
             HANDLE hJob,
             PCWSTR VolumeName,
                                            JOBOBJECT_IO_RATE_CONTROL_INFORMATION ** InfoBlocks,
          ULONG * InfoBlockCount
    );
# 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\jobapi2.h" 3
}
# 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wow64apiset.h" 1 3
# 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wow64apiset.h" 3
extern "C" {
# 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wow64apiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
Wow64DisableWow64FsRedirection(
          PVOID * OldValue
    );


__declspec(dllimport)
BOOL
__stdcall
Wow64RevertWow64FsRedirection(
         PVOID OlValue
    );
# 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wow64apiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsWow64Process(
         HANDLE hProcess,
          PBOOL Wow64Process
    );
# 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wow64apiset.h" 3
__declspec(dllimport)


UINT
__stdcall
GetSystemWow64DirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)


UINT
__stdcall
GetSystemWow64DirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );
# 217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wow64apiset.h" 3
}
# 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 1 3
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
extern "C" {
# 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
typedef struct tagENUMUILANG {
    ULONG NumOfEnumUILang;
    ULONG SizeOfEnumUIBuffer;
    LANGID *pEnumUIBuffer;
} ENUMUILANG, *PENUMUILANG;



typedef BOOL (__stdcall* ENUMRESLANGPROCA)(
             HMODULE hModule,
         LPCSTR lpType,
         LPCSTR lpName,
         WORD wLanguage,
         LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESLANGPROCW)(
             HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage,
         LONG_PTR lParam);






typedef BOOL (__stdcall* ENUMRESNAMEPROCA)(
             HMODULE hModule,
         LPCSTR lpType,
         LPSTR lpName,
         LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESNAMEPROCW)(
             HMODULE hModule,
         LPCWSTR lpType,
         LPWSTR lpName,
         LONG_PTR lParam);






typedef BOOL (__stdcall* ENUMRESTYPEPROCA)(
             HMODULE hModule,
         LPSTR lpType,
         LONG_PTR lParam
    );
typedef BOOL (__stdcall* ENUMRESTYPEPROCW)(
             HMODULE hModule,
         LPWSTR lpType,
         LONG_PTR lParam
    );
# 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
DisableThreadLibraryCalls(
         HMODULE hLibModule
    );
# 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)

HRSRC
__stdcall
FindResourceExW(
             HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage
    );
# 222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FreeLibrary(
         HMODULE hLibModule
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
FreeLibraryAndExitThread(
         HMODULE hLibModule,
         DWORD dwExitCode
    );
# 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
FreeResource(
         HGLOBAL hResData
    );
# 262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)


DWORD
__stdcall
GetModuleFileNameA(
             HMODULE hModule,
                                                                      LPSTR lpFilename,
         DWORD nSize
    );

__declspec(dllimport)


DWORD
__stdcall
GetModuleFileNameW(
             HMODULE hModule,
                                                                      LPWSTR lpFilename,
         DWORD nSize
    );
# 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleA(
             LPCSTR lpModuleName
    );

__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleW(
             LPCWSTR lpModuleName
    );
# 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXA)(
                DWORD dwFlags,
                LPCSTR lpModuleName,
             HMODULE* phModule
    );
typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXW)(
                DWORD dwFlags,
                LPCWSTR lpModuleName,
             HMODULE* phModule
    );






__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExA(
         DWORD dwFlags,
             LPCSTR lpModuleName,
          HMODULE * phModule
    );

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExW(
         DWORD dwFlags,
             LPCWSTR lpModuleName,
          HMODULE * phModule
    );
# 383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
FARPROC
__stdcall
GetProcAddress(
         HMODULE hModule,
         LPCSTR lpProcName
    );
# 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryExA(
         LPCSTR lpLibFileName,
               HANDLE hFile,
         DWORD dwFlags
    );

__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryExW(
         LPCWSTR lpLibFileName,
               HANDLE hFile,
         DWORD dwFlags
    );
# 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)

HGLOBAL
__stdcall
LoadResource(
             HMODULE hModule,
         HRSRC hResInfo
    );
# 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
int
__stdcall
LoadStringA(
             HINSTANCE hInstance,
         UINT uID,
                                              LPSTR lpBuffer,
         int cchBufferMax
    );

__declspec(dllimport)
int
__stdcall
LoadStringW(
             HINSTANCE hInstance,
         UINT uID,
                                              LPWSTR lpBuffer,
         int cchBufferMax
    );
# 518 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
LPVOID
__stdcall
LockResource(
         HGLOBAL hResData
    );


__declspec(dllimport)
DWORD
__stdcall
SizeofResource(
             HMODULE hModule,
         HRSRC hResInfo
    );
# 544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;

__declspec(dllimport)
DLL_DIRECTORY_COOKIE
__stdcall
AddDllDirectory(
         PCWSTR NewDirectory
    );


__declspec(dllimport)
BOOL
__stdcall
RemoveDllDirectory(
         DLL_DIRECTORY_COOKIE Cookie
    );


__declspec(dllimport)
BOOL
__stdcall
SetDefaultDllDirectories(
         DWORD DirectoryFlags
    );
# 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExA(
             HMODULE hModule,
         LPCSTR lpType,
         LPCSTR lpName,
         ENUMRESLANGPROCA lpEnumFunc,
             LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExW(
             HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         ENUMRESLANGPROCW lpEnumFunc,
             LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );







__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExA(
             HMODULE hModule,
         LPCSTR lpType,
         ENUMRESNAMEPROCA lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExW(
             HMODULE hModule,
         LPCWSTR lpType,
         ENUMRESNAMEPROCW lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );







__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExA(
             HMODULE hModule,
         ENUMRESTYPEPROCA lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExW(
             HMODULE hModule,
         ENUMRESTYPEPROCW lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
# 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)

HRSRC
__stdcall
FindResourceW(
             HMODULE hModule,
         LPCWSTR lpName,
         LPCWSTR lpType
    );






__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryA(
         LPCSTR lpLibFileName
    );

__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryW(
         LPCWSTR lpLibFileName
    );
# 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesW(
             HMODULE hModule,
         LPCWSTR lpType,
         ENUMRESNAMEPROCW lpEnumFunc,
         LONG_PTR lParam
    );
# 764 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\libloaderapi.h" 3
}
# 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 1 3
# 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
extern "C" {
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AccessCheck(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PGENERIC_MAPPING GenericMapping,
                                                                        PPRIVILEGE_SET PrivilegeSet,
            LPDWORD PrivilegeSetLength,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmW(
         LPCWSTR SubsystemName,
             LPVOID HandleId,
         LPWSTR ObjectTypeName,
             LPWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
         DWORD DesiredAccess,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByType(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID PrincipalSelfSid,
         HANDLE ClientToken,
         DWORD DesiredAccess,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
                                                                        PPRIVILEGE_SET PrivilegeSet,
            LPDWORD PrivilegeSetLength,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultList(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID PrincipalSelfSid,
         HANDLE ClientToken,
         DWORD DesiredAccess,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
                                                                        PPRIVILEGE_SET PrivilegeSet,
            LPDWORD PrivilegeSetLength,
                                       LPDWORD GrantedAccessList,
                                       LPDWORD AccessStatusList
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         LPCWSTR ObjectTypeName,
             LPCWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         LPCWSTR ObjectTypeName,
             LPCWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
                                       LPDWORD GrantedAccessList,
                                       LPDWORD AccessStatusList,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         LPCWSTR ObjectTypeName,
             LPCWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
                                       LPDWORD GrantedAccessList,
                                       LPDWORD AccessStatusList,
          LPBOOL pfGenerateOnClose
    );
# 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAceEx(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
         PSID pSid
    );
# 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedObjectAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
             GUID * ObjectTypeGuid,
             GUID * InheritedObjectTypeGuid,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAceEx(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedObjectAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
             GUID * ObjectTypeGuid,
             GUID * InheritedObjectTypeGuid,
         PSID pSid
    );
# 313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AddAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD dwStartingAceIndex,
                                     LPVOID pAceList,
         DWORD nAceListLength
    );
# 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD dwAccessMask,
         PSID pSid,
         BOOL bAuditSuccess,
         BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAceEx(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD dwAccessMask,
         PSID pSid,
         BOOL bAuditSuccess,
         BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessObjectAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
             GUID * ObjectTypeGuid,
             GUID * InheritedObjectTypeGuid,
         PSID pSid,
         BOOL bAuditSuccess,
         BOOL bAuditFailure
    );
# 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AddMandatoryAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD MandatoryPolicy,
         PSID pLabelSid
    );
# 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AdjustTokenGroups(
         HANDLE TokenHandle,
         BOOL ResetToDefault,
             PTOKEN_GROUPS NewState,
         DWORD BufferLength,
                                                           PTOKEN_GROUPS PreviousState,
              PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenPrivileges(
         HANDLE TokenHandle,
         BOOL DisableAllPrivileges,
             PTOKEN_PRIVILEGES NewState,
         DWORD BufferLength,
                                                           PTOKEN_PRIVILEGES PreviousState,
              PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateAndInitializeSid(
         PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
         BYTE nSubAuthorityCount,
         DWORD nSubAuthority0,
         DWORD nSubAuthority1,
         DWORD nSubAuthority2,
         DWORD nSubAuthority3,
         DWORD nSubAuthority4,
         DWORD nSubAuthority5,
         DWORD nSubAuthority6,
         DWORD nSubAuthority7,
             PSID * pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateLocallyUniqueId(
          PLUID Luid
    );
# 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
AreAllAccessesGranted(
         DWORD GrantedAccess,
         DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
AreAnyAccessesGranted(
         DWORD GrantedAccess,
         DWORD DesiredAccess
    );
# 532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembership(
             HANDLE TokenHandle,
         PSID SidToCheck,
          PBOOL IsMember
    );
# 604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
ConvertToAutoInheritPrivateObjectSecurity(
             PSECURITY_DESCRIPTOR ParentDescriptor,
         PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
             PSECURITY_DESCRIPTOR * NewSecurityDescriptor,
             GUID * ObjectType,
         BOOLEAN IsDirectoryObject,
         PGENERIC_MAPPING GenericMapping
    );
# 624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CopySid(
         DWORD nDestinationSidLength,
                                              PSID pDestinationSid,
         PSID pSourceSid
    );
# 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurity(
             PSECURITY_DESCRIPTOR ParentDescriptor,
             PSECURITY_DESCRIPTOR CreatorDescriptor,
             PSECURITY_DESCRIPTOR * NewDescriptor,
         BOOL IsDirectoryObject,
             HANDLE Token,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityEx(
             PSECURITY_DESCRIPTOR ParentDescriptor,
             PSECURITY_DESCRIPTOR CreatorDescriptor,
             PSECURITY_DESCRIPTOR * NewDescriptor,
             GUID * ObjectType,
         BOOL IsContainerObject,
         ULONG AutoInheritFlags,
             HANDLE Token,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityWithMultipleInheritance(
             PSECURITY_DESCRIPTOR ParentDescriptor,
             PSECURITY_DESCRIPTOR CreatorDescriptor,
             PSECURITY_DESCRIPTOR * NewDescriptor,
                              GUID ** ObjectTypes,
         ULONG GuidCount,
         BOOL IsContainerObject,
         ULONG AutoInheritFlags,
             HANDLE Token,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreateRestrictedToken(
         HANDLE ExistingTokenHandle,
         DWORD Flags,
         DWORD DisableSidCount,
                                    PSID_AND_ATTRIBUTES SidsToDisable,
         DWORD DeletePrivilegeCount,
                                         PLUID_AND_ATTRIBUTES PrivilegesToDelete,
         DWORD RestrictedSidCount,
                                       PSID_AND_ATTRIBUTES SidsToRestrict,
             PHANDLE NewTokenHandle
    );
# 711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
CreateWellKnownSid(
         WELL_KNOWN_SID_TYPE WellKnownSidType,
             PSID DomainSid,
                                              PSID pSid,
            DWORD * cbSid
    );


__declspec(dllimport)

BOOL
__stdcall
EqualDomainSid(
         PSID pSid1,
         PSID pSid2,
          BOOL * pfEqual
    );




__declspec(dllimport)
BOOL
__stdcall
DeleteAce(
            PACL pAcl,
         DWORD dwAceIndex
    );
# 752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
DestroyPrivateObjectSecurity(
                               PSECURITY_DESCRIPTOR * ObjectDescriptor
    );
# 767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
DuplicateToken(
         HANDLE ExistingTokenHandle,
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
             PHANDLE DuplicateTokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateTokenEx(
         HANDLE hExistingToken,
         DWORD dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpTokenAttributes,
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
         TOKEN_TYPE TokenType,
             PHANDLE phNewToken
    );
# 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
EqualPrefixSid(
         PSID pSid1,
         PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
EqualSid(
         PSID pSid1,
         PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
FindFirstFreeAce(
         PACL pAcl,
             LPVOID * pAce
    );
# 831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
PVOID
__stdcall
FreeSid(
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetAce(
         PACL pAcl,
         DWORD dwAceIndex,
             LPVOID * pAce
    );


__declspec(dllimport)
BOOL
__stdcall
GetAclInformation(
         PACL pAcl,
                                              LPVOID pAclInformation,
         DWORD nAclInformationLength,
         ACL_INFORMATION_CLASS dwAclInformationClass
    );
# 867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityW(
         LPCWSTR lpFileName,
         SECURITY_INFORMATION RequestedInformation,
                                                         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         DWORD nLength,
          LPDWORD lpnLengthNeeded
    );
# 890 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetKernelObjectSecurity(
         HANDLE Handle,
         SECURITY_INFORMATION RequestedInformation,
                                    PSECURITY_DESCRIPTOR pSecurityDescriptor,
         DWORD nLength,
          LPDWORD lpnLengthNeeded
    );


__declspec(dllimport)


DWORD
__stdcall
GetLengthSid(
                                           PSID pSid
    );
# 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)

BOOL
__stdcall
GetPrivateObjectSecurity(
         PSECURITY_DESCRIPTOR ObjectDescriptor,
         SECURITY_INFORMATION SecurityInformation,
                                                               PSECURITY_DESCRIPTOR ResultantDescriptor,
         DWORD DescriptorLength,
          PDWORD ReturnLength
    );
# 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorControl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          PSECURITY_DESCRIPTOR_CONTROL pControl,
          LPDWORD lpdwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorDacl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          LPBOOL lpbDaclPresent,
             PACL * pDacl,
          LPBOOL lpbDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorGroup(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID * pGroup,
          LPBOOL lpbGroupDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorLength(
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorOwner(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID * pOwner,
          LPBOOL lpbOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorRMControl(
         PSECURITY_DESCRIPTOR SecurityDescriptor,
          PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorSacl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          LPBOOL lpbSaclPresent,
             PACL * pSacl,
          LPBOOL lpbSaclDefaulted
    );


__declspec(dllimport)
PSID_IDENTIFIER_AUTHORITY
__stdcall
GetSidIdentifierAuthority(
         PSID pSid
    );


__declspec(dllimport)
DWORD
__stdcall
GetSidLengthRequired(
         UCHAR nSubAuthorityCount
    );


__declspec(dllimport)
PDWORD
__stdcall
GetSidSubAuthority(
         PSID pSid,
         DWORD nSubAuthority
    );


__declspec(dllimport)
PUCHAR
__stdcall
GetSidSubAuthorityCount(
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetTokenInformation(
         HANDLE TokenHandle,
         TOKEN_INFORMATION_CLASS TokenInformationClass,
                                                                     LPVOID TokenInformation,
         DWORD TokenInformationLength,
          PDWORD ReturnLength
    );





__declspec(dllimport)

BOOL
__stdcall
GetWindowsAccountDomainSid(
         PSID pSid,
                                                          PSID pDomainSid,
            DWORD * cbDomainSid
    );
# 1076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
ImpersonateAnonymousToken(
         HANDLE ThreadHandle
    );



__declspec(dllimport)
BOOL
__stdcall
ImpersonateLoggedOnUser(
         HANDLE hToken
    );



__declspec(dllimport)
BOOL
__stdcall
ImpersonateSelf(
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
# 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
InitializeAcl(
                                   PACL pAcl,
         DWORD nAclLength,
         DWORD dwAclRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSecurityDescriptor(
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
         DWORD dwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSid(
                                                                                  PSID Sid,
         PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
         BYTE nSubAuthorityCount
    );
# 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsTokenRestricted(
         HANDLE TokenHandle
    );
# 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsValidAcl(
         PACL pAcl
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSecurityDescriptor(
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSid(
         PSID pSid
    );





__declspec(dllimport)
BOOL
__stdcall
IsWellKnownSid(
         PSID pSid,
         WELL_KNOWN_SID_TYPE WellKnownSidType
    );




__declspec(dllimport)

BOOL
__stdcall
MakeAbsoluteSD(
         PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
                                                                                                        PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
            LPDWORD lpdwAbsoluteSecurityDescriptorSize,
                                                            PACL pDacl,
            LPDWORD lpdwDaclSize,
                                                            PACL pSacl,
            LPDWORD lpdwSaclSize,
                                                              PSID pOwner,
            LPDWORD lpdwOwnerSize,
                                                                            PSID pPrimaryGroup,
            LPDWORD lpdwPrimaryGroupSize
    );


__declspec(dllimport)

BOOL
__stdcall
MakeSelfRelativeSD(
         PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
                                                                    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
            LPDWORD lpdwBufferLength
    );
# 1235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
void
__stdcall
MapGenericMask(
            PDWORD AccessMask,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         LPWSTR ObjectTypeName,
             LPWSTR ObjectName,
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         DWORD GrantedAccess,
             PPRIVILEGE_SET Privileges,
         BOOL ObjectCreation,
         BOOL AccessGranted,
          LPBOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );






__declspec(dllimport)
BOOL
__stdcall
PrivilegeCheck(
         HANDLE ClientToken,
            PPRIVILEGE_SET RequiredPrivileges,
          LPBOOL pfResult
    );


__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmW(
         LPCWSTR SubsystemName,
         LPCWSTR ServiceName,
         HANDLE ClientToken,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );
# 1341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
void
__stdcall
QuerySecurityAccessMask(
         SECURITY_INFORMATION SecurityInformation,
          LPDWORD DesiredAccess
    );




__declspec(dllimport)
BOOL
__stdcall
RevertToSelf(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetAclInformation(
            PACL pAcl,
                                            LPVOID pAclInformation,
         DWORD nAclInformationLength,
         ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityW(
         LPCWSTR lpFileName,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
# 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetKernelObjectSecurity(
         HANDLE Handle,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR SecurityDescriptor
    );
# 1408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurity(
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR ModificationDescriptor,
            PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
         PGENERIC_MAPPING GenericMapping,
             HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurityEx(
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR ModificationDescriptor,
            PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
         ULONG AutoInheritFlags,
         PGENERIC_MAPPING GenericMapping,
             HANDLE Token
    );





__declspec(dllimport)
void
__stdcall
SetSecurityAccessMask(
         SECURITY_INFORMATION SecurityInformation,
          LPDWORD DesiredAccess
    );
# 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorControl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
         SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorDacl(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
         BOOL bDaclPresent,
             PACL pDacl,
         BOOL bDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorGroup(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID pGroup,
         BOOL bGroupDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorOwner(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID pOwner,
         BOOL bOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
SetSecurityDescriptorRMControl(
            PSECURITY_DESCRIPTOR SecurityDescriptor,
             PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorSacl(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
         BOOL bSaclPresent,
             PACL pSacl,
         BOOL bSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetTokenInformation(
         HANDLE TokenHandle,
         TOKEN_INFORMATION_CLASS TokenInformationClass,
                                             LPVOID TokenInformation,
         DWORD TokenInformationLength
    );
# 1615 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securitybaseapi.h" 3
}
# 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namespaceapi.h" 1 3
# 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namespaceapi.h" 3
extern "C" {
# 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\namespaceapi.h" 3
__declspec(dllimport)
HANDLE
__stdcall
CreatePrivateNamespaceW(
             LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
         LPVOID lpBoundaryDescriptor,
         LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenPrivateNamespaceW(
         LPVOID lpBoundaryDescriptor,
         LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
BOOLEAN
__stdcall
ClosePrivateNamespace(
         HANDLE Handle,
         ULONG Flags
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateBoundaryDescriptorW(
         LPCWSTR Name,
         ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
AddSIDToBoundaryDescriptor(
            HANDLE * BoundaryDescriptor,
         PSID RequiredSid
    );


__declspec(dllimport)
void
__stdcall
DeleteBoundaryDescriptor(
         HANDLE BoundaryDescriptor
    );






}
# 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\systemtopologyapi.h" 1 3
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\systemtopologyapi.h" 3
extern "C" {






__declspec(dllimport)
BOOL
__stdcall
GetNumaHighestNodeNumber(
          PULONG HighestNodeNumber
    );
# 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\systemtopologyapi.h" 3
}
# 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processtopologyapi.h" 1 3
# 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processtopologyapi.h" 3
extern "C" {
# 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\processtopologyapi.h" 3
}
# 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securityappcontainer.h" 1 3
# 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securityappcontainer.h" 3
extern "C" {
# 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\securityappcontainer.h" 3
}
# 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\realtimeapiset.h" 1 3
# 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\realtimeapiset.h" 3
extern "C" {
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\realtimeapiset.h" 3
__declspec(dllimport)
BOOL
__stdcall
QueryThreadCycleTime(
         HANDLE ThreadHandle,
          PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessCycleTime(
         HANDLE ProcessHandle,
          PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTime(
            PULONG BufferLength,
                                          PULONG64 ProcessorIdleCycleTime
    );
# 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\realtimeapiset.h" 3
__declspec(dllimport)
void
__stdcall
QueryInterruptTimePrecise(
          PULONGLONG lpInterruptTimePrecise
    );


__declspec(dllimport)
void
__stdcall
QueryUnbiasedInterruptTimePrecise(
          PULONGLONG lpUnbiasedInterruptTimePrecise
    );


__declspec(dllimport)
void
__stdcall
QueryInterruptTime(
          PULONGLONG lpInterruptTime
    );
# 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\realtimeapiset.h" 3
__declspec(dllimport)
HRESULT
__stdcall
QueryAuxiliaryCounterFrequency(
          PULONGLONG lpAuxiliaryCounterFrequency
    );


__declspec(dllimport)
HRESULT
__stdcall
ConvertAuxiliaryCounterToPerformanceCounter(
         ULONGLONG ullAuxiliaryCounterValue,
          PULONGLONG lpPerformanceCounterValue,
              PULONGLONG lpConversionError
    );


__declspec(dllimport)
HRESULT
__stdcall
ConvertPerformanceCounterToAuxiliaryCounter(
         ULONGLONG ullPerformanceCounterValue,
          PULONGLONG lpAuxiliaryCounterValue,
              PULONGLONG lpConversionError
    );
# 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\realtimeapiset.h" 3
}
# 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3



extern "C" {
# 290 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef void (__stdcall *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

typedef LPVOID (__stdcall *PFIBER_CALLOUT_ROUTINE)(
    LPVOID lpParameter
    );
# 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef LPVOID LPLDT_ENTRY;
# 413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;







typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
# 468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _DCB {
    DWORD DCBlength;
    DWORD BaudRate;
    DWORD fBinary: 1;
    DWORD fParity: 1;
    DWORD fOutxCtsFlow:1;
    DWORD fOutxDsrFlow:1;
    DWORD fDtrControl:2;
    DWORD fDsrSensitivity:1;
    DWORD fTXContinueOnXoff: 1;
    DWORD fOutX: 1;
    DWORD fInX: 1;
    DWORD fErrorChar: 1;
    DWORD fNull: 1;
    DWORD fRtsControl:2;
    DWORD fAbortOnError:1;
    DWORD fDummy2:17;
    WORD wReserved;
    WORD XonLim;
    WORD XoffLim;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    WORD wReserved1;
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;
    DWORD ReadTotalTimeoutMultiplier;
    DWORD ReadTotalTimeoutConstant;
    DWORD WriteTotalTimeoutMultiplier;
    DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;
    WORD wVersion;
    WORD wReserved;
    DCB dcb;
    DWORD dwProviderSubType;

    DWORD dwProviderOffset;

    DWORD dwProviderSize;
    WCHAR wcProviderData[1];
} COMMCONFIG,*LPCOMMCONFIG;
# 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;
# 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;


typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
# 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;
# 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
int




__stdcall




WinMain (
         HINSTANCE hInstance,
             HINSTANCE hPrevInstance,
         LPSTR lpCmdLine,
         int nShowCmd
    );

int



__stdcall

wWinMain(
         HINSTANCE hInstance,
             HINSTANCE hPrevInstance,
         LPWSTR lpCmdLine,
         int nShowCmd
    );







__declspec(dllimport)


__declspec(allocator)
HGLOBAL
__stdcall
GlobalAlloc(
         UINT uFlags,
         SIZE_T dwBytes
    );







__declspec(dllimport)

__declspec(allocator)
HGLOBAL
__stdcall
GlobalReAlloc (
                HGLOBAL hMem,
         SIZE_T dwBytes,
         UINT uFlags
    );







__declspec(dllimport)
SIZE_T
__stdcall
GlobalSize (
         HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnlock(
         HGLOBAL hMem
    );

__declspec(dllimport)

LPVOID
__stdcall
GlobalLock (
         HGLOBAL hMem
    );







__declspec(dllimport)
UINT
__stdcall
GlobalFlags (
         HGLOBAL hMem
    );

__declspec(dllimport)

HGLOBAL
__stdcall
GlobalHandle (
         LPCVOID pMem
    );







__declspec(dllimport)


HGLOBAL
__stdcall
GlobalFree(
                    HGLOBAL hMem
    );







__declspec(dllimport)
SIZE_T
__stdcall
GlobalCompact(
         DWORD dwMinFree
    );

__declspec(dllimport)
void
__stdcall
GlobalFix(
         HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalUnfix(
         HGLOBAL hMem
    );

__declspec(dllimport)
LPVOID
__stdcall
GlobalWire(
         HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnWire(
         HGLOBAL hMem
    );


__declspec(dllimport)
void
__stdcall
GlobalMemoryStatus(
          LPMEMORYSTATUS lpBuffer
    );







__declspec(dllimport)


__declspec(allocator)
HLOCAL
__stdcall
LocalAlloc(
         UINT uFlags,
         SIZE_T uBytes
    );

__declspec(dllimport)

__declspec(allocator)
HLOCAL
__stdcall
LocalReAlloc(
                    HLOCAL hMem,
         SIZE_T uBytes,
         UINT uFlags
    );







__declspec(dllimport)

LPVOID
__stdcall
LocalLock(
         HLOCAL hMem
    );







__declspec(dllimport)

HLOCAL
__stdcall
LocalHandle(
         LPCVOID pMem
    );







__declspec(dllimport)
BOOL
__stdcall
LocalUnlock(
         HLOCAL hMem
    );







__declspec(dllimport)
SIZE_T
__stdcall
LocalSize(
         HLOCAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
LocalFlags(
         HLOCAL hMem
    );







__declspec(dllimport)


HLOCAL
__stdcall
LocalFree(
                    HLOCAL hMem
    );







__declspec(dllimport)
SIZE_T
__stdcall
LocalShrink(
         HLOCAL hMem,
         UINT cbNewSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalCompact(
         UINT uMinFree
    );
# 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeA(
          LPCSTR lpApplicationName,
          LPDWORD lpBinaryType
    );
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeW(
          LPCWSTR lpApplicationName,
          LPDWORD lpBinaryType
    );






__declspec(dllimport)

DWORD
__stdcall
GetShortPathNameA(
         LPCSTR lpszLongPath,
                                               LPSTR lpszShortPath,
         DWORD cchBuffer
    );






__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameTransactedA(
             LPCSTR lpszShortPath,
                                               LPSTR lpszLongPath,
             DWORD cchBuffer,
             HANDLE hTransaction
    );
__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameTransactedW(
             LPCWSTR lpszShortPath,
                                               LPWSTR lpszLongPath,
             DWORD cchBuffer,
             HANDLE hTransaction
    );
# 1286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetProcessAffinityMask(
          HANDLE hProcess,
          PDWORD_PTR lpProcessAffinityMask,
          PDWORD_PTR lpSystemAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityMask(
         HANDLE hProcess,
         DWORD_PTR dwProcessAffinityMask
    );







__declspec(dllimport)
BOOL
__stdcall
GetProcessIoCounters(
          HANDLE hProcess,
          PIO_COUNTERS lpIoCounters
    );







__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSize(
          HANDLE hProcess,
          PSIZE_T lpMinimumWorkingSetSize,
          PSIZE_T lpMaximumWorkingSetSize
    );







__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSize(
         HANDLE hProcess,
         SIZE_T dwMinimumWorkingSetSize,
         SIZE_T dwMaximumWorkingSetSize
    );

__declspec(dllimport)

void
__stdcall
FatalExit(
         int ExitCode
    );







__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsA(
                                     LPCH NewEnvironment
    );
# 1385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
void
__stdcall
SwitchToFiber(
         LPVOID lpFiber
    );

__declspec(dllimport)
void
__stdcall
DeleteFiber(
         LPVOID lpFiber
    );



__declspec(dllimport)
BOOL
__stdcall
ConvertFiberToThread(
    void
    );



__declspec(dllimport)

LPVOID
__stdcall
CreateFiberEx(
             SIZE_T dwStackCommitSize,
             SIZE_T dwStackReserveSize,
             DWORD dwFlags,
             LPFIBER_START_ROUTINE lpStartAddress,
             LPVOID lpParameter
    );

__declspec(dllimport)

LPVOID
__stdcall
ConvertThreadToFiberEx(
             LPVOID lpParameter,
             DWORD dwFlags
    );







__declspec(dllimport)

LPVOID
__stdcall
CreateFiber(
             SIZE_T dwStackSize,
             LPFIBER_START_ROUTINE lpStartAddress,
             LPVOID lpParameter
    );

__declspec(dllimport)

LPVOID
__stdcall
ConvertThreadToFiber(
             LPVOID lpParameter
    );
# 1643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD_PTR
__stdcall
SetThreadAffinityMask(
         HANDLE hThread,
         DWORD_PTR dwThreadAffinityMask
    );
# 1662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetProcessDEPPolicy(
         DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessDEPPolicy(
         HANDLE hProcess,
          LPDWORD lpFlags,
          PBOOL lpPermanent
    );



__declspec(dllimport)
BOOL
__stdcall
RequestWakeupLatency(
         LATENCY_TIME latency
    );

__declspec(dllimport)
BOOL
__stdcall
IsSystemResumeAutomatic(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadSelectorEntry(
          HANDLE hThread,
          DWORD dwSelector,
          LPLDT_ENTRY lpSelectorEntry
    );

__declspec(dllimport)
EXECUTION_STATE
__stdcall
SetThreadExecutionState(
         EXECUTION_STATE esFlags
    );
# 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileCompletionNotificationModes(
         HANDLE FileHandle,
         UCHAR Flags
    );
# 1829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadContext(
            HANDLE hThread,
            PWOW64_CONTEXT lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
Wow64SetThreadContext(
         HANDLE hThread,
         const WOW64_CONTEXT *lpContext
    );
# 1864 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
Wow64SuspendThread(
         HANDLE hThread
    );



__declspec(dllimport)
BOOL
__stdcall
DebugSetProcessKillOnExit(
         BOOL KillOnExit
    );

__declspec(dllimport)
BOOL
__stdcall
DebugBreakProcess (
         HANDLE Process
    );
# 1903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
PulseEvent(
         HANDLE hEvent
    );

__declspec(dllimport)
ATOM
__stdcall
GlobalDeleteAtom(
         ATOM nAtom
    );

__declspec(dllimport)
BOOL
__stdcall
InitAtomTable(
         DWORD nSize
    );

__declspec(dllimport)
ATOM
__stdcall
DeleteAtom(
         ATOM nAtom
    );

__declspec(dllimport)
UINT
__stdcall
SetHandleCount(
         UINT uNumber
    );

__declspec(dllimport)
BOOL
__stdcall
RequestDeviceWakeup(
         HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
CancelDeviceWakeupRequest(
         HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
GetDevicePowerState(
          HANDLE hDevice,
          BOOL *pfOn
    );

__declspec(dllimport)
BOOL
__stdcall
SetMessageWaitingIndicator(
         HANDLE hMsgIndicator,
         ULONG ulMsgCount
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameA(
         HANDLE hFile,
         LPCSTR lpShortName
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameW(
         HANDLE hFile,
         LPCWSTR lpShortName
    );
# 1994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
LoadModule(
         LPCSTR lpModuleName,
         LPVOID lpParameterBlock
    );



__declspec(dllimport)
UINT
__stdcall
WinExec(
         LPCSTR lpCmdLine,
         UINT uCmdShow
    );
# 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
ClearCommBreak(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommError(
              HANDLE hFile,
              LPDWORD lpErrors,
              LPCOMSTAT lpStat
    );

__declspec(dllimport)
BOOL
__stdcall
SetupComm(
         HANDLE hFile,
         DWORD dwInQueue,
         DWORD dwOutQueue
    );

__declspec(dllimport)
BOOL
__stdcall
EscapeCommFunction(
         HANDLE hFile,
         DWORD dwFunc
    );

__declspec(dllimport)

BOOL
__stdcall
GetCommConfig(
              HANDLE hCommDev,
                                      LPCOMMCONFIG lpCC,
              LPDWORD lpdwSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommMask(
          HANDLE hFile,
          LPDWORD lpEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommProperties(
            HANDLE hFile,
            LPCOMMPROP lpCommProp
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommModemStatus(
          HANDLE hFile,
          LPDWORD lpModemStat
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommState(
          HANDLE hFile,
          LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommTimeouts(
          HANDLE hFile,
          LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
PurgeComm(
         HANDLE hFile,
         DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommBreak(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommConfig(
         HANDLE hCommDev,
                             LPCOMMCONFIG lpCC,
         DWORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommMask(
         HANDLE hFile,
         DWORD dwEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommState(
         HANDLE hFile,
         LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommTimeouts(
         HANDLE hFile,
         LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
TransmitCommChar(
         HANDLE hFile,
         char cChar
    );

__declspec(dllimport)
BOOL
__stdcall
WaitCommEvent(
                HANDLE hFile,
                LPDWORD lpEvtMask,
                LPOVERLAPPED lpOverlapped
    );
# 2187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
SetTapePosition(
         HANDLE hDevice,
         DWORD dwPositionMethod,
         DWORD dwPartition,
         DWORD dwOffsetLow,
         DWORD dwOffsetHigh,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapePosition(
          HANDLE hDevice,
          DWORD dwPositionType,
          LPDWORD lpdwPartition,
          LPDWORD lpdwOffsetLow,
          LPDWORD lpdwOffsetHigh
    );

__declspec(dllimport)
DWORD
__stdcall
PrepareTape(
         HANDLE hDevice,
         DWORD dwOperation,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
EraseTape(
         HANDLE hDevice,
         DWORD dwEraseType,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
CreateTapePartition(
         HANDLE hDevice,
         DWORD dwPartitionMethod,
         DWORD dwCount,
         DWORD dwSize
    );

__declspec(dllimport)
DWORD
__stdcall
WriteTapemark(
         HANDLE hDevice,
         DWORD dwTapemarkType,
         DWORD dwTapemarkCount,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeStatus(
         HANDLE hDevice
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeParameters(
            HANDLE hDevice,
            DWORD dwOperation,
            LPDWORD lpdwSize,
                                  LPVOID lpTapeInformation
    );




__declspec(dllimport)
DWORD
__stdcall
SetTapeParameters(
         HANDLE hDevice,
         DWORD dwOperation,
         LPVOID lpTapeInformation
    );
# 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
int
__stdcall
MulDiv(
         int nNumber,
         int nNumerator,
         int nDenominator
    );







typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;



__declspec(dllimport)
DEP_SYSTEM_POLICY_TYPE
__stdcall
GetSystemDEPPolicy(
    void
    );





__declspec(dllimport)
BOOL
__stdcall
GetSystemRegistryQuota(
              PDWORD pdwQuotaAllowed,
              PDWORD pdwQuotaUsed
    );







__declspec(dllimport)
BOOL
__stdcall
FileTimeToDosDateTime(
          const FILETIME *lpFileTime,
          LPWORD lpFatDate,
          LPWORD lpFatTime
    );

__declspec(dllimport)
BOOL
__stdcall
DosDateTimeToFileTime(
          WORD wFatDate,
          WORD wFatTime,
          LPFILETIME lpFileTime
    );
# 2367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

DWORD
__stdcall
FormatMessageA(
             DWORD dwFlags,
             LPCVOID lpSource,
             DWORD dwMessageId,
             DWORD dwLanguageId,


             LPSTR lpBuffer,
             DWORD nSize,
             va_list *Arguments
    );
__declspec(dllimport)

DWORD
__stdcall
FormatMessageW(
             DWORD dwFlags,
             LPCVOID lpSource,
             DWORD dwMessageId,
             DWORD dwLanguageId,


             LPWSTR lpBuffer,
             DWORD nSize,
             va_list *Arguments
    );
# 2448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotA(
             LPCSTR lpName,
             DWORD nMaxMessageSize,
             DWORD lReadTimeout,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotW(
             LPCWSTR lpName,
             DWORD nMaxMessageSize,
             DWORD lReadTimeout,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
GetMailslotInfo(
              HANDLE hMailslot,
              LPDWORD lpMaxMessageSize,
              LPDWORD lpNextSize,
              LPDWORD lpMessageCount,
              LPDWORD lpReadTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
SetMailslotInfo(
         HANDLE hMailslot,
         DWORD lReadTimeout
    );





__declspec(dllimport)
BOOL
__stdcall
EncryptFileA(
         LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
EncryptFileW(
         LPCWSTR lpFileName
    );






__declspec(dllimport)
BOOL
__stdcall
DecryptFileA(
               LPCSTR lpFileName,
               DWORD dwReserved
    );
__declspec(dllimport)
BOOL
__stdcall
DecryptFileW(
               LPCWSTR lpFileName,
               DWORD dwReserved
    );
# 2548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusA(
          LPCSTR lpFileName,
          LPDWORD lpStatus
    );
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusW(
          LPCWSTR lpFileName,
          LPDWORD lpStatus
    );
# 2574 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef
DWORD
(__stdcall *PFE_EXPORT_FUNC)(
                               PBYTE pbData,
             PVOID pvCallbackContext,
             ULONG ulLength
    );

typedef
DWORD
(__stdcall *PFE_IMPORT_FUNC)(
                                                PBYTE pbData,
             PVOID pvCallbackContext,
             PULONG ulLength
    );
# 2602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawA(
                LPCSTR lpFileName,
                ULONG ulFlags,
             PVOID *pvContext
    );
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawW(
                LPCWSTR lpFileName,
                ULONG ulFlags,
             PVOID *pvContext
    );






__declspec(dllimport)
DWORD
__stdcall
ReadEncryptedFileRaw(
             PFE_EXPORT_FUNC pfExportCallback,
             PVOID pvCallbackContext,
             PVOID pvContext
    );

__declspec(dllimport)
DWORD
__stdcall
WriteEncryptedFileRaw(
             PFE_IMPORT_FUNC pfImportCallback,
             PVOID pvCallbackContext,
             PVOID pvContext
    );

__declspec(dllimport)
void
__stdcall
CloseEncryptedFileRaw(
         PVOID pvContext
    );
# 2659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
int
__stdcall
lstrcmpA(
         LPCSTR lpString1,
         LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpW(
         LPCWSTR lpString1,
         LPCWSTR lpString2
    );






__declspec(dllimport)
int
__stdcall
lstrcmpiA(
         LPCSTR lpString1,
         LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpiW(
         LPCWSTR lpString1,
         LPCWSTR lpString2
    );







#pragma warning(push)
#pragma warning(disable: 4995)


__declspec(dllimport)




LPSTR
__stdcall
lstrcpynA(
                             LPSTR lpString1,
         LPCSTR lpString2,
         int iMaxLength
    );
__declspec(dllimport)




LPWSTR
__stdcall
lstrcpynW(
                             LPWSTR lpString1,
         LPCWSTR lpString2,
         int iMaxLength
    );






__declspec(dllimport)
LPSTR
__stdcall
lstrcpyA(
                                                 LPSTR lpString1,
          LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcpyW(
                                                 LPWSTR lpString1,
          LPCWSTR lpString2
    );






__declspec(dllimport)
LPSTR
__stdcall
lstrcatA(
                                                                                   LPSTR lpString1,
            LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcatW(
                                                                                   LPWSTR lpString1,
            LPCWSTR lpString2
    );







#pragma warning(pop)


__declspec(dllimport)
int
__stdcall
lstrlenA(
         LPCSTR lpString
    );
__declspec(dllimport)
int
__stdcall
lstrlenW(
         LPCWSTR lpString
    );
# 2802 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HFILE
__stdcall
OpenFile(
            LPCSTR lpFileName,
            LPOFSTRUCT lpReOpenBuff,
            UINT uStyle
    );

__declspec(dllimport)
HFILE
__stdcall
_lopen(
         LPCSTR lpPathName,
         int iReadWrite
    );

__declspec(dllimport)
HFILE
__stdcall
_lcreat(
         LPCSTR lpPathName,
         int iAttribute
    );

__declspec(dllimport)
UINT
__stdcall
_lread(
         HFILE hFile,
                                          LPVOID lpBuffer,
         UINT uBytes
    );

__declspec(dllimport)
UINT
__stdcall
_lwrite(
         HFILE hFile,
                             LPCCH lpBuffer,
         UINT uBytes
    );

__declspec(dllimport)
long
__stdcall
_hread(
         HFILE hFile,
                                          LPVOID lpBuffer,
         long lBytes
    );

__declspec(dllimport)
long
__stdcall
_hwrite(
         HFILE hFile,
                             LPCCH lpBuffer,
         long lBytes
    );

__declspec(dllimport)
HFILE
__stdcall
_lclose(
         HFILE hFile
    );

__declspec(dllimport)
LONG
__stdcall
_llseek(
         HFILE hFile,
         LONG lOffset,
         int iOrigin
    );

__declspec(dllimport)
BOOL
__stdcall
IsTextUnicode(
                            const void* lpv,
                int iSize,
                LPINT lpiResult
    );
# 2895 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
         HANDLE hObjectToSignal,
         HANDLE hObjectToWaitOn,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
# 2912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
BackupRead(
            HANDLE hFile,
                                                                      LPBYTE lpBuffer,
            DWORD nNumberOfBytesToRead,
            LPDWORD lpNumberOfBytesRead,
            BOOL bAbort,
            BOOL bProcessSecurity,
            LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupSeek(
            HANDLE hFile,
            DWORD dwLowBytesToSeek,
            DWORD dwHighBytesToSeek,
            LPDWORD lpdwLowByteSeeked,
            LPDWORD lpdwHighByteSeeked,
            LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupWrite(
            HANDLE hFile,
                                            LPBYTE lpBuffer,
            DWORD nNumberOfBytesToWrite,
            LPDWORD lpNumberOfBytesWritten,
            BOOL bAbort,
            BOOL bProcessSecurity,
            LPVOID *lpContext
    );




typedef struct _WIN32_STREAM_ID {
        DWORD dwStreamId ;
        DWORD dwStreamAttributes ;
        LARGE_INTEGER Size ;
        DWORD dwStreamNameSize ;
        WCHAR cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;
# 3017 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;




typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;
# 3043 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HANDLE
__stdcall
OpenMutexA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );




__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreA(
             LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
             LPCSTR lpName
    );
# 3076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HANDLE
__stdcall
OpenSemaphoreA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
# 3097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerA(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             BOOL bManualReset,
             LPCSTR lpTimerName
    );




__declspec(dllimport)

HANDLE
__stdcall
OpenWaitableTimerA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpTimerName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreExA(
                LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
                LONG lInitialCount,
                LONG lMaximumCount,
                LPCSTR lpName,
                DWORD dwFlags,
                DWORD dwDesiredAccess
    );




__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerExA(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             LPCSTR lpTimerName,
             DWORD dwFlags,
             DWORD dwDesiredAccess
    );
# 3166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingA(
             HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
             DWORD flProtect,
             DWORD dwMaximumSizeHigh,
             DWORD dwMaximumSizeLow,
             LPCSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingNumaA(
             HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
             DWORD flProtect,
             DWORD dwMaximumSizeHigh,
             DWORD dwMaximumSizeLow,
             LPCSTR lpName,
             DWORD nndPreferred
    );







__declspec(dllimport)
HANDLE
__stdcall
OpenFileMappingA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
# 3222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

DWORD
__stdcall
GetLogicalDriveStringsA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );
# 3302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameA(
         HANDLE hProcess,
         DWORD dwFlags,
                                          LPSTR lpExeName,
            PDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameW(
         HANDLE hProcess,
         DWORD dwFlags,
                                          LPWSTR lpExeName,
            PDWORD lpdwSize
    );
# 3341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
# 3354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
    ProcThreadAttributeProtectionLevel = 11,
# 3369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
} PROC_THREAD_ATTRIBUTE_NUM;
# 3684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
void
__stdcall
GetStartupInfoA(
          LPSTARTUPINFOA lpStartupInfo
    );
# 3754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableA(
         LPCSTR lpName,
         LPCSTR lpGuid,
                                             PVOID pBuffer,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
                                             PVOID pBuffer,
         DWORD nSize
    );
# 3808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableA(
         LPCSTR lpName,
         LPCSTR lpGuid,
                                PVOID pValue,
         DWORD nSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
                                PVOID pValue,
         DWORD nSize
    );
# 3887 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HRSRC
__stdcall
FindResourceA(
             HMODULE hModule,
             LPCSTR lpName,
             LPCSTR lpType
    );




__declspec(dllimport)

HRSRC
__stdcall
FindResourceExA(
             HMODULE hModule,
             LPCSTR lpType,
             LPCSTR lpName,
             WORD wLanguage
    );




__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesA(
             HMODULE hModule,
             ENUMRESTYPEPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesW(
             HMODULE hModule,
             ENUMRESTYPEPROCW lpEnumFunc,
             LONG_PTR lParam
    );






__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesA(
             HMODULE hModule,
             LPCSTR lpType,
             ENUMRESNAMEPROCA lpEnumFunc,
             LONG_PTR lParam
    );





__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesA(
             HMODULE hModule,
             LPCSTR lpType,
             LPCSTR lpName,
             ENUMRESLANGPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesW(
             HMODULE hModule,
             LPCWSTR lpType,
             LPCWSTR lpName,
             ENUMRESLANGPROCW lpEnumFunc,
             LONG_PTR lParam
    );






__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceA(
         LPCSTR pFileName,
         BOOL bDeleteExistingResources
    );
__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceW(
         LPCWSTR pFileName,
         BOOL bDeleteExistingResources
    );






__declspec(dllimport)
BOOL
__stdcall
UpdateResourceA(
         HANDLE hUpdate,
         LPCSTR lpType,
         LPCSTR lpName,
         WORD wLanguage,
                             LPVOID lpData,
         DWORD cb
    );
__declspec(dllimport)
BOOL
__stdcall
UpdateResourceW(
         HANDLE hUpdate,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage,
                             LPVOID lpData,
         DWORD cb
    );






__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceA(
         HANDLE hUpdate,
         BOOL fDiscard
    );
__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceW(
         HANDLE hUpdate,
         BOOL fDiscard
    );
# 4046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExA(
             LPCSTR lpString,
         DWORD Flags
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExW(
             LPCWSTR lpString,
         DWORD Flags
    );






__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameA(
         ATOM nAtom,
                                       LPSTR lpBuffer,
         int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameW(
         ATOM nAtom,
                                       LPWSTR lpBuffer,
         int nSize
    );






__declspec(dllimport)
ATOM
__stdcall
AddAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
AddAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
ATOM
__stdcall
FindAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
FindAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
UINT
__stdcall
GetAtomNameA(
         ATOM nAtom,
                                       LPSTR lpBuffer,
         int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GetAtomNameW(
         ATOM nAtom,
                                       LPWSTR lpBuffer,
         int nSize
    );
# 4188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
UINT
__stdcall
GetProfileIntA(
         LPCSTR lpAppName,
         LPCSTR lpKeyName,
         INT nDefault
    );
__declspec(dllimport)
UINT
__stdcall
GetProfileIntW(
         LPCWSTR lpAppName,
         LPCWSTR lpKeyName,
         INT nDefault
    );






__declspec(dllimport)
DWORD
__stdcall
GetProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpDefault,
                                           LPSTR lpReturnedString,
             DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpDefault,
                                           LPWSTR lpReturnedString,
             DWORD nSize
    );
# 4242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpString
    );
# 4270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionA(
         LPCSTR lpAppName,
                                           LPSTR lpReturnedString,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionW(
         LPCWSTR lpAppName,
                                           LPWSTR lpReturnedString,
         DWORD nSize
    );
# 4298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionA(
         LPCSTR lpAppName,
         LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionW(
         LPCWSTR lpAppName,
         LPCWSTR lpString
    );
# 4324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             INT nDefault,
             LPCSTR lpFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             INT nDefault,
             LPCWSTR lpFileName
    );
# 4372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpDefault,
                                           LPSTR lpReturnedString,
             DWORD nSize,
             LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpDefault,
                                           LPWSTR lpReturnedString,
             DWORD nSize,
             LPCWSTR lpFileName
    );
# 4428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpString,
             LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpString,
             LPCWSTR lpFileName
    );






__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionA(
             LPCSTR lpAppName,
                                           LPSTR lpReturnedString,
             DWORD nSize,
             LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionW(
             LPCWSTR lpAppName,
                                           LPWSTR lpReturnedString,
             DWORD nSize,
             LPCWSTR lpFileName
    );
# 4500 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionA(
             LPCSTR lpAppName,
             LPCSTR lpString,
             LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionW(
             LPCWSTR lpAppName,
             LPCWSTR lpString,
             LPCWSTR lpFileName
    );
# 4528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesA(
                                           LPSTR lpszReturnBuffer,
             DWORD nSize,
             LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesW(
                                           LPWSTR lpszReturnBuffer,
             DWORD nSize,
             LPCWSTR lpFileName
    );
# 4572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructA(
             LPCSTR lpszSection,
             LPCSTR lpszKey,
                                        LPVOID lpStruct,
             UINT uSizeStruct,
             LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructW(
             LPCWSTR lpszSection,
             LPCWSTR lpszKey,
                                        LPVOID lpStruct,
             UINT uSizeStruct,
             LPCWSTR szFile
    );
# 4624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructA(
             LPCSTR lpszSection,
             LPCSTR lpszKey,
                                      LPVOID lpStruct,
             UINT uSizeStruct,
             LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructW(
             LPCWSTR lpszSection,
             LPCWSTR lpszKey,
                                      LPVOID lpStruct,
             UINT uSizeStruct,
             LPCWSTR szFile
    );
# 4677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOLEAN
__stdcall
Wow64EnableWow64FsRedirection (
         BOOLEAN Wow64FsEnableRedirection
    );




typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_A)( LPSTR lpBuffer, UINT uSize);
typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_W)( LPWSTR lpBuffer, UINT uSize);
# 4755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryA(
             LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryW(
             LPCWSTR lpPathName
    );






__declspec(dllimport)

DWORD
__stdcall
GetDllDirectoryA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );
__declspec(dllimport)

DWORD
__stdcall
GetDllDirectoryW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );
# 4802 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetSearchPathMode (
         DWORD Flags
    );
# 4841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExA(
             LPCSTR lpTemplateDirectory,
             LPCSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExW(
             LPCWSTR lpTemplateDirectory,
             LPCWSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
# 4871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedA(
             LPCSTR lpTemplateDirectory,
             LPCSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedW(
             LPCWSTR lpTemplateDirectory,
             LPCWSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             HANDLE hTransaction
    );






__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedA(
         LPCSTR lpPathName,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedW(
         LPCWSTR lpPathName,
             HANDLE hTransaction
    );






__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameTransactedA(
                    LPCSTR lpFileName,
                    DWORD nBufferLength,
                                                   LPSTR lpBuffer,
                 LPSTR *lpFilePart,
                    HANDLE hTransaction
    );
__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameTransactedW(
                    LPCWSTR lpFileName,
                    DWORD nBufferLength,
                                                   LPWSTR lpBuffer,
                 LPWSTR *lpFilePart,
                    HANDLE hTransaction
    );
# 4957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceA(
             DWORD dwFlags,
             LPCSTR lpDeviceName,
             LPCSTR lpTargetPath
    );




__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceA(
             LPCSTR lpDeviceName,
                                         LPSTR lpTargetPath,
             DWORD ucchMax
    );
# 4991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedA(
               LPCSTR lpFileName,
               DWORD dwDesiredAccess,
               DWORD dwShareMode,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               DWORD dwCreationDisposition,
               DWORD dwFlagsAndAttributes,
               HANDLE hTemplateFile,
               HANDLE hTransaction,
               PUSHORT pusMiniVersion,
               PVOID lpExtendedParameter
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedW(
               LPCWSTR lpFileName,
               DWORD dwDesiredAccess,
               DWORD dwShareMode,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               DWORD dwCreationDisposition,
               DWORD dwFlagsAndAttributes,
               HANDLE hTemplateFile,
               HANDLE hTransaction,
               PUSHORT pusMiniVersion,
               PVOID lpExtendedParameter
    );
# 5037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
ReOpenFile(
         HANDLE hOriginalFile,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
         DWORD dwFlagsAndAttributes
    );
# 5058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedA(
             LPCSTR lpFileName,
             DWORD dwFileAttributes,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedW(
             LPCWSTR lpFileName,
             DWORD dwFileAttributes,
             HANDLE hTransaction
    );






__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedA(
          LPCSTR lpFileName,
          GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedW(
          LPCWSTR lpFileName,
          GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation,
             HANDLE hTransaction
    );






__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedA(
              LPCSTR lpFileName,
              LPDWORD lpFileSizeHigh,
              HANDLE hTransaction
    );
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedW(
              LPCWSTR lpFileName,
              LPDWORD lpFileSizeHigh,
              HANDLE hTransaction
    );






__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedA(
             LPCSTR lpFileName,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedW(
             LPCWSTR lpFileName,
             HANDLE hTransaction
    );
# 5180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3A(
              LPCSTR lpName,
                                  LPSTR lpOemName,
              DWORD OemNameSize,
              PBOOL pbNameContainsSpaces ,
              PBOOL pbNameLegal
    );
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3W(
              LPCWSTR lpName,
                                  LPSTR lpOemName,
              DWORD OemNameSize,
              PBOOL pbNameContainsSpaces ,
              PBOOL pbNameLegal
    );
# 5218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedA(
               LPCSTR lpFileName,
               FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
               FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
               DWORD dwAdditionalFlags,
               HANDLE hTransaction
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedW(
               LPCWSTR lpFileName,
               FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
               FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
               DWORD dwAdditionalFlags,
               HANDLE hTransaction
    );
# 5259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CopyFileA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName,
         BOOL bFailIfExists
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName,
         BOOL bFailIfExists
    );
# 5311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef
DWORD
(__stdcall *LPPROGRESS_ROUTINE)(
             LARGE_INTEGER TotalFileSize,
             LARGE_INTEGER TotalBytesTransferred,
             LARGE_INTEGER StreamSize,
             LARGE_INTEGER StreamBytesTransferred,
             DWORD dwStreamNumber,
             DWORD dwCallbackReason,
             HANDLE hSourceFile,
             HANDLE hDestinationFile,
             LPVOID lpData
    );

__declspec(dllimport)
BOOL
__stdcall
CopyFileExA(
                LPCSTR lpExistingFileName,
                LPCSTR lpNewFileName,
                LPPROGRESS_ROUTINE lpProgressRoutine,
                LPVOID lpData,

                LPBOOL pbCancel,
                DWORD dwCopyFlags
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileExW(
                LPCWSTR lpExistingFileName,
                LPCWSTR lpNewFileName,
                LPPROGRESS_ROUTINE lpProgressRoutine,
                LPVOID lpData,

                LPBOOL pbCancel,
                DWORD dwCopyFlags
    );
# 5363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             LPBOOL pbCancel,
             DWORD dwCopyFlags,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             LPBOOL pbCancel,
             DWORD dwCopyFlags,
             HANDLE hTransaction
    );
# 5544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
MoveFileA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName
    );
# 5590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
MoveFileExA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileExW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             DWORD dwFlags
    );
# 5619 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags
    );
# 5653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags,
             HANDLE hTransaction
    );
# 5712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileA(
               LPCSTR lpReplacedFileName,
               LPCSTR lpReplacementFileName,
               LPCSTR lpBackupFileName,
               DWORD dwReplaceFlags,
               LPVOID lpExclude,
               LPVOID lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileW(
               LPCWSTR lpReplacedFileName,
               LPCWSTR lpReplacementFileName,
               LPCWSTR lpBackupFileName,
               DWORD dwReplaceFlags,
               LPVOID lpExclude,
               LPVOID lpReserved
    );
# 5752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkA(
               LPCSTR lpFileName,
               LPCSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkW(
               LPCWSTR lpFileName,
               LPCWSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
# 5787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedA(
               LPCSTR lpFileName,
               LPCSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedW(
               LPCWSTR lpFileName,
               LPCWSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               HANDLE hTransaction
    );
# 5815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamTransactedW (
               LPCWSTR lpFileName,
               STREAM_INFO_LEVELS InfoLevel,
                                                       LPVOID lpFindStreamData,
               DWORD dwFlags,
               HANDLE hTransaction
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameTransactedW (
             LPCWSTR lpFileName,
             DWORD dwFlags,
             LPDWORD StringLength,
                                PWSTR LinkName,
             HANDLE hTransaction
    );
# 5845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeA(
             LPCSTR lpName,
             DWORD dwOpenMode,
             DWORD dwPipeMode,
             DWORD nMaxInstances,
             DWORD nOutBufferSize,
             DWORD nInBufferSize,
             DWORD nDefaultTimeOut,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
# 5868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateA(
              HANDLE hNamedPipe,
              LPDWORD lpState,
              LPDWORD lpCurInstances,
              LPDWORD lpMaxCollectionCount,
              LPDWORD lpCollectDataTimeout,
                                       LPSTR lpUserName,
              DWORD nMaxUserNameSize
    );




__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeA(
          LPCSTR lpNamedPipeName,
                                        LPVOID lpInBuffer,
          DWORD nInBufferSize,
                                                            LPVOID lpOutBuffer,
          DWORD nOutBufferSize,
          LPDWORD lpBytesRead,
          DWORD nTimeOut
    );





__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeA(
         LPCSTR lpNamedPipeName,
         DWORD nTimeOut
    );
# 5927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameA(
         HANDLE Pipe,
                                                  LPSTR ClientComputerName,
         ULONG ClientComputerNameLength
    );
# 5946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientProcessId(
         HANDLE Pipe,
          PULONG ClientProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientSessionId(
         HANDLE Pipe,
          PULONG ClientSessionId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerProcessId(
         HANDLE Pipe,
          PULONG ServerProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerSessionId(
         HANDLE Pipe,
          PULONG ServerSessionId
    );
# 5986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelA(
             LPCSTR lpRootPathName,
             LPCSTR lpVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelW(
             LPCWSTR lpRootPathName,
             LPCWSTR lpVolumeName
    );
# 6015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileBandwidthReservation(
          HANDLE hFile,
          DWORD nPeriodMilliseconds,
          DWORD nBytesPerPeriod,
          BOOL bDiscardable,
          LPDWORD lpTransferSize,
          LPDWORD lpNumOutstandingRequests
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileBandwidthReservation(
          HANDLE hFile,
          LPDWORD lpPeriodMilliseconds,
          LPDWORD lpBytesPerPeriod,
          LPBOOL pDiscardable,
          LPDWORD lpTransferSize,
          LPDWORD lpNumOutstandingRequests
    );







__declspec(dllimport)
BOOL
__stdcall
ClearEventLogA (
             HANDLE hEventLog,
             LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
ClearEventLogW (
             HANDLE hEventLog,
             LPCWSTR lpBackupFileName
    );






__declspec(dllimport)
BOOL
__stdcall
BackupEventLogA (
         HANDLE hEventLog,
         LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
BackupEventLogW (
         HANDLE hEventLog,
         LPCWSTR lpBackupFileName
    );






__declspec(dllimport)
BOOL
__stdcall
CloseEventLog (
         HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
DeregisterEventSource (
         HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyChangeEventLog(
         HANDLE hEventLog,
         HANDLE hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfEventLogRecords (
          HANDLE hEventLog,
          PDWORD NumberOfRecords
    );

__declspec(dllimport)
BOOL
__stdcall
GetOldestEventLogRecord (
          HANDLE hEventLog,
          PDWORD OldestRecord
    );

__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogA (
             LPCSTR lpUNCServerName,
             LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogW (
             LPCWSTR lpUNCServerName,
             LPCWSTR lpSourceName
    );






__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceA (
             LPCSTR lpUNCServerName,
             LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceW (
             LPCWSTR lpUNCServerName,
             LPCWSTR lpSourceName
    );






__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogA (
             LPCSTR lpUNCServerName,
             LPCSTR lpFileName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogW (
             LPCWSTR lpUNCServerName,
             LPCWSTR lpFileName
    );






__declspec(dllimport)
BOOL
__stdcall
ReadEventLogA (
          HANDLE hEventLog,
          DWORD dwReadFlags,
          DWORD dwRecordOffset,
                                                              LPVOID lpBuffer,
          DWORD nNumberOfBytesToRead,
          DWORD *pnBytesRead,
          DWORD *pnMinNumberOfBytesNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
ReadEventLogW (
          HANDLE hEventLog,
          DWORD dwReadFlags,
          DWORD dwRecordOffset,
                                                              LPVOID lpBuffer,
          DWORD nNumberOfBytesToRead,
          DWORD *pnBytesRead,
          DWORD *pnMinNumberOfBytesNeeded
    );






__declspec(dllimport)
BOOL
__stdcall
ReportEventA (
             HANDLE hEventLog,
             WORD wType,
             WORD wCategory,
             DWORD dwEventID,
             PSID lpUserSid,
             WORD wNumStrings,
             DWORD dwDataSize,
                                LPCSTR *lpStrings,
                                     LPVOID lpRawData
    );
__declspec(dllimport)
BOOL
__stdcall
ReportEventW (
             HANDLE hEventLog,
             WORD wType,
             WORD wCategory,
             DWORD dwEventID,
             PSID lpUserSid,
             WORD wNumStrings,
             DWORD dwDataSize,
                                LPCWSTR *lpStrings,
                                     LPVOID lpRawData
    );
# 6250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetEventLogInformation (
          HANDLE hEventLog,
          DWORD dwInfoLevel,
                                                      LPVOID lpBuffer,
          DWORD cbBufSize,
          LPDWORD pcbBytesNeeded
    );
# 6322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPSTR ObjectTypeName,
             LPSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             DWORD DesiredAccess,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
             LPDWORD GrantedAccess,
             LPBOOL AccessStatus,
             LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPCSTR ObjectTypeName,
             LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
             LPDWORD GrantedAccess,
             LPBOOL AccessStatus,
             LPBOOL pfGenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPCSTR ObjectTypeName,
             LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
                                             LPDWORD GrantedAccess,
                                             LPDWORD AccessStatusList,
             LPBOOL pfGenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             HANDLE ClientToken,
             LPCSTR ObjectTypeName,
             LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
                                             LPDWORD GrantedAccess,
                                             LPDWORD AccessStatusList,
             LPBOOL pfGenerateOnClose
    );





__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPSTR ObjectTypeName,
             LPSTR ObjectName,
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
             HANDLE ClientToken,
             DWORD DesiredAccess,
             DWORD GrantedAccess,
             PPRIVILEGE_SET Privileges,
             BOOL ObjectCreation,
             BOOL AccessGranted,
             LPBOOL GenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );




__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmA (
         LPCSTR SubsystemName,
         LPCSTR ServiceName,
         HANDLE ClientToken,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );
# 6517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityA (
         LPCSTR lpFileName,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );




__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityA (
          LPCSTR lpFileName,
          SECURITY_INFORMATION RequestedInformation,
                                                         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          DWORD nLength,
          LPDWORD lpnLengthNeeded
    );
# 6550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesW(
                HANDLE hDirectory,
                                                           LPVOID lpBuffer,
                DWORD nBufferLength,
                BOOL bWatchSubtree,
                DWORD dwNotifyFilter,
                LPDWORD lpBytesReturned,
                LPOVERLAPPED lpOverlapped,
                LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 6590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

LPVOID
__stdcall
MapViewOfFileExNuma(
             HANDLE hFileMappingObject,
             DWORD dwDesiredAccess,
             DWORD dwFileOffsetHigh,
             DWORD dwFileOffsetLow,
             SIZE_T dwNumberOfBytesToMap,
             LPVOID lpBaseAddress,
             DWORD nndPreferred
    );



__declspec(dllimport)
BOOL
__stdcall
IsBadReadPtr(
             const void *lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadWritePtr(
             LPVOID lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeReadPtr(
             const void *lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeWritePtr(
             LPVOID lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadCodePtr(
             FARPROC lpfn
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrA(
             LPCSTR lpsz,
             UINT_PTR ucchMax
    );
__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrW(
             LPCWSTR lpsz,
             UINT_PTR ucchMax
    );
# 6671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountSidA(
             LPCSTR lpSystemName,
         PSID Sid,
                                                LPSTR Name,
             LPDWORD cchName,
                                                                                LPSTR ReferencedDomainName,
            LPDWORD cchReferencedDomainName,
          PSID_NAME_USE peUse
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountSidW(
             LPCWSTR lpSystemName,
         PSID Sid,
                                                LPWSTR Name,
             LPDWORD cchName,
                                                                                LPWSTR ReferencedDomainName,
            LPDWORD cchReferencedDomainName,
          PSID_NAME_USE peUse
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountNameA(
             LPCSTR lpSystemName,
             LPCSTR lpAccountName,
                                              PSID Sid,
             LPDWORD cbSid,
                                                                                LPSTR ReferencedDomainName,
             LPDWORD cchReferencedDomainName,
             PSID_NAME_USE peUse
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountNameW(
             LPCWSTR lpSystemName,
             LPCWSTR lpAccountName,
                                              PSID Sid,
             LPDWORD cbSid,
                                                                                LPWSTR ReferencedDomainName,
             LPDWORD cchReferencedDomainName,
             PSID_NAME_USE peUse
    );
# 6825 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueA(
             LPCSTR lpSystemName,
             LPCSTR lpName,
             PLUID lpLuid
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueW(
             LPCWSTR lpSystemName,
             LPCWSTR lpName,
             PLUID lpLuid
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeNameA(
             LPCSTR lpSystemName,
             PLUID lpLuid,
                                                LPSTR lpName,
             LPDWORD cchName
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeNameW(
             LPCWSTR lpSystemName,
             PLUID lpLuid,
                                                LPWSTR lpName,
             LPDWORD cchName
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeDisplayNameA(
             LPCSTR lpSystemName,
             LPCSTR lpName,
                                                              LPSTR lpDisplayName,
             LPDWORD cchDisplayName,
             LPDWORD lpLanguageId
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeDisplayNameW(
             LPCWSTR lpSystemName,
             LPCWSTR lpName,
                                                              LPWSTR lpDisplayName,
             LPDWORD cchDisplayName,
             LPDWORD lpLanguageId
    );
# 6903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBA(
          LPCSTR lpDef,
          LPDCB lpDCB
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBW(
          LPCWSTR lpDef,
          LPDCB lpDCB
    );






__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsA(
          LPCSTR lpDef,
          LPDCB lpDCB,
          LPCOMMTIMEOUTS lpCommTimeouts
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsW(
          LPCWSTR lpDef,
          LPDCB lpDCB,
          LPCOMMTIMEOUTS lpCommTimeouts
    );






__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogA(
             LPCSTR lpszName,
             HWND hWnd,
             LPCOMMCONFIG lpCC
    );
__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogW(
             LPCWSTR lpszName,
             HWND hWnd,
             LPCOMMCONFIG lpCC
    );






__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigA(
            LPCSTR lpszName,
                                                LPCOMMCONFIG lpCC,
            LPDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigW(
            LPCWSTR lpszName,
                                                LPCOMMCONFIG lpCC,
            LPDWORD lpdwSize
    );






__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigA(
         LPCSTR lpszName,
                             LPCOMMCONFIG lpCC,
         DWORD dwSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigW(
         LPCWSTR lpszName,
                             LPCOMMCONFIG lpCC,
         DWORD dwSize
    );
# 7023 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameA (
                                            LPSTR lpBuffer,
            LPDWORD nSize
    );
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameW (
                                            LPWSTR lpBuffer,
            LPDWORD nSize
    );
# 7054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameA (
            LPCSTR Hostname,
                                            LPSTR ComputerName,
            LPDWORD nSize
    );
__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameW (
            LPCWSTR Hostname,
                                            LPWSTR ComputerName,
            LPDWORD nSize
    );
# 7080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetUserNameA (
                                                LPSTR lpBuffer,
            LPDWORD pcbBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
GetUserNameW (
                                                LPWSTR lpBuffer,
            LPDWORD pcbBuffer
    );
# 7128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
LogonUserA (
                LPCSTR lpszUsername,
                LPCSTR lpszDomain,
                LPCSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
             PHANDLE phToken
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserW (
                LPCWSTR lpszUsername,
                LPCWSTR lpszDomain,
                LPCWSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
             PHANDLE phToken
    );






__declspec(dllimport)
BOOL
__stdcall
LogonUserExA (
                    LPCSTR lpszUsername,
                    LPCSTR lpszDomain,
                    LPCSTR lpszPassword,
                    DWORD dwLogonType,
                    DWORD dwLogonProvider,
                 PHANDLE phToken,
                 PSID *ppLogonSid,
                                                          PVOID *ppProfileBuffer,
                    LPDWORD pdwProfileLength,
                    PQUOTA_LIMITS pQuotaLimits
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserExW (
                    LPCWSTR lpszUsername,
                    LPCWSTR lpszDomain,
                    LPCWSTR lpszPassword,
                    DWORD dwLogonType,
                    DWORD dwLogonProvider,
                 PHANDLE phToken,
                 PSID *ppLogonSid,
                                                          PVOID *ppProfileBuffer,
                    LPDWORD pdwProfileLength,
                    PQUOTA_LIMITS pQuotaLimits
    );
# 7212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
                      BOOL
__stdcall
CreateProcessWithLogonW(
                LPCWSTR lpUsername,
                LPCWSTR lpDomain,
                LPCWSTR lpPassword,
                DWORD dwLogonFlags,
                LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
                DWORD dwCreationFlags,
                LPVOID lpEnvironment,
                LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
                LPPROCESS_INFORMATION lpProcessInformation
      );

__declspec(dllimport)
                      BOOL
__stdcall
CreateProcessWithTokenW(
                HANDLE hToken,
                DWORD dwLogonFlags,
                LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
                DWORD dwCreationFlags,
                LPVOID lpEnvironment,
                LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
                LPPROCESS_INFORMATION lpProcessInformation
      );



__declspec(dllimport)
BOOL
__stdcall
IsTokenUntrusted(
         HANDLE TokenHandle
    );







__declspec(dllimport)
BOOL
__stdcall
RegisterWaitForSingleObject(
             PHANDLE phNewWaitObject,
                HANDLE hObject,
                WAITORTIMERCALLBACK Callback,
                PVOID Context,
                ULONG dwMilliseconds,
                ULONG dwFlags
    );

__declspec(dllimport)

BOOL
__stdcall
UnregisterWait(
         HANDLE WaitHandle
    );

__declspec(dllimport)
BOOL
__stdcall
BindIoCompletionCallback (
         HANDLE FileHandle,
         LPOVERLAPPED_COMPLETION_ROUTINE Function,
         ULONG Flags
    );

__declspec(dllimport)
HANDLE
__stdcall
SetTimerQueueTimer(
             HANDLE TimerQueue,
             WAITORTIMERCALLBACK Callback,
             PVOID Parameter,
             DWORD DueTime,
             DWORD Period,
             BOOL PreferIo
    );

__declspec(dllimport)

BOOL
__stdcall
CancelTimerQueueTimer(
             HANDLE TimerQueue,
             HANDLE Timer
    );

__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueue(
         HANDLE TimerQueue
    );
# 7329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__forceinline
void
InitializeThreadpoolEnvironment(
          PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

__forceinline
void
SetThreadpoolCallbackPool(
            PTP_CALLBACK_ENVIRON pcbe,
            PTP_POOL ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

__forceinline
void
SetThreadpoolCallbackCleanupGroup(
             PTP_CALLBACK_ENVIRON pcbe,
             PTP_CLEANUP_GROUP ptpcg,
             PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

__forceinline
void
SetThreadpoolCallbackRunsLong(
            PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

__forceinline
void
SetThreadpoolCallbackLibrary(
            PTP_CALLBACK_ENVIRON pcbe,
            PVOID mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}
# 7392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__forceinline
void
DestroyThreadpoolEnvironment(
            PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}
# 7416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__forceinline
void
SetThreadpoolCallbackPersistent(
            PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}
# 7437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreatePrivateNamespaceA(
             LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
             LPVOID lpBoundaryDescriptor,
             LPCSTR lpAliasPrefix
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenPrivateNamespaceA(
             LPVOID lpBoundaryDescriptor,
             LPCSTR lpAliasPrefix
    );
# 7473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)

HANDLE
__stdcall
CreateBoundaryDescriptorA(
         LPCSTR Name,
         ULONG Flags
    );
# 7494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
AddIntegrityLabelToBoundaryDescriptor(
            HANDLE * BoundaryDescriptor,
         PSID IntegrityLabel
    );
# 7524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct tagHW_PROFILE_INFOA {
    DWORD dwDockInfo;
    CHAR szHwProfileGuid[39];
    CHAR szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD dwDockInfo;
    WCHAR szHwProfileGuid[39];
    WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;




typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;



__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileA (
          LPHW_PROFILE_INFOA lpHwProfileInfo
    );
__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileW (
          LPHW_PROFILE_INFOW lpHwProfileInfo
    );







__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoA(
            LPOSVERSIONINFOEXA lpVersionInformation,
            DWORD dwTypeMask,
            DWORDLONG dwlConditionMask
    );
__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoW(
            LPOSVERSIONINFOEXW lpVersionInformation,
            DWORD dwTypeMask,
            DWORDLONG dwlConditionMask
    );
# 7592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winerror.h" 1 3
# 28298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\winerror.h" 3
constexpr

__forceinline HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}
# 7592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\timezoneapi.h" 1 3
# 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\timezoneapi.h" 3
extern "C" {
# 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\timezoneapi.h" 3
typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

__declspec(dllimport)

BOOL
__stdcall
SystemTimeToTzSpecificLocalTime(
             const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
         const SYSTEMTIME * lpUniversalTime,
          LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)

BOOL
__stdcall
TzSpecificLocalTimeToSystemTime(
             const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
         const SYSTEMTIME * lpLocalTime,
          LPSYSTEMTIME lpUniversalTime
    );


__declspec(dllimport)

BOOL
__stdcall
FileTimeToSystemTime(
         const FILETIME * lpFileTime,
          LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)

BOOL
__stdcall
SystemTimeToFileTime(
         const SYSTEMTIME * lpSystemTime,
          LPFILETIME lpFileTime
    );


__declspec(dllimport)

DWORD
__stdcall
GetTimeZoneInformation(
          LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );
# 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\timezoneapi.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetTimeZoneInformation(
         const TIME_ZONE_INFORMATION * lpTimeZoneInformation
    );





__declspec(dllimport)
BOOL
__stdcall
SetDynamicTimeZoneInformation(
         const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation
    );
# 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\timezoneapi.h" 3
__declspec(dllimport)

DWORD
__stdcall
GetDynamicTimeZoneInformation(
          PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );
# 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\timezoneapi.h" 3
}
# 7593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 2 3
# 7610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetSystemPowerState(
         BOOL fSuspend,
         BOOL fForce
    );
# 7649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE SystemStatusFlag;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

__declspec(dllimport)
BOOL
__stdcall
GetSystemPowerStatus(
          LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );
# 7678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
MapUserPhysicalPagesScatter(
                              PVOID *VirtualAddresses,
         ULONG_PTR NumberOfPages,
                                  PULONG_PTR PageArray
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateJobObjectA(
             LPSECURITY_ATTRIBUTES lpJobAttributes,
             LPCSTR lpName
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenJobObjectA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );
# 7730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CreateJobSet (
         ULONG NumJob,
                       PJOB_SET_ARRAY UserJobSet,
         ULONG Flags);







__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeA(
                                  LPSTR lpszVolumeName,
         DWORD cchBufferLength
    );




__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeA(
            HANDLE hFindVolume,
                                  LPSTR lpszVolumeName,
            DWORD cchBufferLength
    );
# 7773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointA(
         LPCSTR lpszRootPathName,
                                  LPSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointW(
         LPCWSTR lpszRootPathName,
                                  LPWSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointA(
         HANDLE hFindVolumeMountPoint,
                                  LPSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointW(
         HANDLE hFindVolumeMountPoint,
                                  LPWSTR lpszVolumeMountPoint,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindVolumeMountPointClose(
         HANDLE hFindVolumeMountPoint
    );

__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointA(
         LPCSTR lpszVolumeMountPoint,
         LPCSTR lpszVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint,
         LPCWSTR lpszVolumeName
    );
# 7850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointA(
         LPCSTR lpszVolumeMountPoint
    );
# 7870 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointA(
         LPCSTR lpszVolumeMountPoint,
                                  LPSTR lpszVolumeName,
         DWORD cchBufferLength
);

__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameA(
         LPCSTR lpszFileName,
                                  LPSTR lpszVolumePathName,
         DWORD cchBufferLength
    );
# 7901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameA(
          LPCSTR lpszVolumeName,
                                                                                          LPCH lpszVolumePathNames,
          DWORD cchBufferLength,
          PDWORD lpcchReturnLength
    );
# 7928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct tagACTCTXA {
    ULONG cbSize;
    DWORD dwFlags;
    LPCSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCSTR lpAssemblyDirectory;
    LPCSTR lpResourceName;
    LPCSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG cbSize;
    DWORD dwFlags;
    LPCWSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCWSTR lpAssemblyDirectory;
    LPCWSTR lpResourceName;
    LPCWSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXW, *PACTCTXW;




typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;


typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;



typedef PCACTCTXA PCACTCTX;




__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxA(
         PCACTCTXA pActCtx
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxW(
         PCACTCTXW pActCtx
    );






__declspec(dllimport)
void
__stdcall
AddRefActCtx(
            HANDLE hActCtx
    );


__declspec(dllimport)
void
__stdcall
ReleaseActCtx(
            HANDLE hActCtx
    );

__declspec(dllimport)
BOOL
__stdcall
ZombifyActCtx(
            HANDLE hActCtx
    );



__declspec(dllimport)
BOOL
__stdcall
ActivateActCtx(
                HANDLE hActCtx,
            ULONG_PTR *lpCookie
    );





__declspec(dllimport)
BOOL
__stdcall
DeactivateActCtx(
         DWORD dwFlags,
         ULONG_PTR ulCookie
    );

__declspec(dllimport)
BOOL
__stdcall
GetCurrentActCtx(
             HANDLE *lphActCtx);


typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;

    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;
# 8084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringA(
               DWORD dwFlags,
               const GUID *lpExtensionGuid,
               ULONG ulSectionId,
               LPCSTR lpStringToFind,
               PACTCTX_SECTION_KEYED_DATA ReturnedData
    );

__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringW(
               DWORD dwFlags,
               const GUID *lpExtensionGuid,
               ULONG ulSectionId,
               LPCWSTR lpStringToFind,
               PACTCTX_SECTION_KEYED_DATA ReturnedData
    );






__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionGuid(
               DWORD dwFlags,
               const GUID *lpExtensionGuid,
               ULONG ulSectionId,
               const GUID *lpGuidToFind,
               PACTCTX_SECTION_KEYED_DATA ReturnedData
    );





typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE hActCtx;
    DWORD dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;
# 8174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
QueryActCtxW(
              DWORD dwFlags,
              HANDLE hActCtx,
              PVOID pvSubInstance,
              ULONG ulInfoClass,
                                                               PVOID pvBuffer,
              SIZE_T cbBuffer,
              SIZE_T *pcbWrittenOrRequired
    );

typedef BOOL (__stdcall * PQUERYACTCTXW_FUNC)(
              DWORD dwFlags,
              HANDLE hActCtx,
              PVOID pvSubInstance,
              ULONG ulInfoClass,
                                                               PVOID pvBuffer,
              SIZE_T cbBuffer,
              SIZE_T *pcbWrittenOrRequired
    );
# 8208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD
__stdcall
WTSGetActiveConsoleSessionId(
    void
    );
# 8271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNode(
          UCHAR Processor,
          PUCHAR NodeNumber
    );
# 8303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMask(
          UCHAR Node,
          PULONGLONG ProcessorMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNode(
          UCHAR Node,
          PULONGLONG AvailableBytes
    );
# 8333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNode(
          ULONG ProximityId,
          PUCHAR NodeNumber
    );
# 8352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef DWORD (__stdcall *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);
# 8390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRecoveryCallback(
          APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
              PVOID pvParameter,
         DWORD dwPingInterval,
         DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRecoveryCallback(void);

__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRestart(
             PCWSTR pwzCommandline,
         DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRestart(void);
# 8428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRecoveryCallback(
          HANDLE hProcess,
          APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
                                  PVOID* ppvParameter,
              PDWORD pdwPingInterval,
              PDWORD pdwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRestartSettings(
         HANDLE hProcess,
                                PWSTR pwzCommandline,
            PDWORD pcchSize,
              PDWORD pdwFlags
    );
# 8459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
HRESULT
__stdcall
ApplicationRecoveryInProgress(
          PBOOL pbCancelled
    );

__declspec(dllimport)
void
__stdcall
ApplicationRecoveryFinished(
         BOOL bSuccess
    );
# 8483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;

typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;
# 8513 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _FILE_RENAME_INFO {

    union {
        BOOLEAN ReplaceIfExists;
        DWORD Flags;
    } ;



    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;

typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;

typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileA;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;
# 8568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _FILE_DISPOSITION_INFO_EX {
    DWORD Flags;
} FILE_DISPOSITION_INFO_EX, *PFILE_DISPOSITION_INFO_EX;


typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

typedef struct _FILE_FULL_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;

typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;
# 8718 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
typedef struct _FILE_REMOTE_PROTOCOL_INFO
{

    USHORT StructureVersion;
    USHORT StructureSize;

    ULONG Protocol;


    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;


    ULONG Flags;

    struct {
        ULONG Reserved[8];
    } GenericReserved;




    struct {
        ULONG Reserved[16];
    } ProtocolSpecificReserved;
# 8770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandleEx(
          HANDLE hFile,
          FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
                                     LPVOID lpFileInformation,
          DWORD dwBufferSize
);







typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      ExtendedFileIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;

typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize;
    FILE_ID_TYPE Type;
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;



    } ;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;

__declspec(dllimport)
HANDLE
__stdcall
OpenFileById (
             HANDLE hVolumeHint,
             LPFILE_ID_DESCRIPTOR lpFileId,
             DWORD dwDesiredAccess,
             DWORD dwShareMode,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             DWORD dwFlagsAndAttributes
    );
# 8848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkA (
         LPCSTR lpSymlinkFileName,
         LPCSTR lpTargetFileName,
         DWORD dwFlags
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkW (
         LPCWSTR lpSymlinkFileName,
         LPCWSTR lpTargetFileName,
         DWORD dwFlags
    );
# 8874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
QueryActCtxSettingsW(
                  DWORD dwFlags,
                  HANDLE hActCtx,
                  PCWSTR settingsNameSpace,
                  PCWSTR settingName,
                                                               PWSTR pvBuffer,
              SIZE_T dwBuffer,
              SIZE_T *pdwWrittenOrRequired
    );
# 8897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedA (
             LPCSTR lpSymlinkFileName,
             LPCSTR lpTargetFileName,
             DWORD dwFlags,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedW (
             LPCWSTR lpSymlinkFileName,
             LPCWSTR lpTargetFileName,
             DWORD dwFlags,
             HANDLE hTransaction
    );
# 8925 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
ReplacePartitionUnit (
         PWSTR TargetPartition,
         PWSTR SparePartition,
         ULONG Flags
    );






__declspec(dllimport)
BOOL
__stdcall
AddSecureMemoryCacheCallback(
                    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveSecureMemoryCacheCallback(
                    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );
# 8964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
CopyContext(
            PCONTEXT Destination,
         DWORD ContextFlags,
         PCONTEXT Source
    );
# 8980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
InitializeContext(
                                           PVOID Buffer,
         DWORD ContextFlags,
          PCONTEXT* Context,
            PDWORD ContextLength
    );
# 8997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
DWORD64
__stdcall
GetEnabledXStateFeatures(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
GetXStateFeaturesMask(
         PCONTEXT Context,
          PDWORD64 FeatureMask
    );


__declspec(dllimport)
PVOID
__stdcall
LocateXStateFeature(
         PCONTEXT Context,
         DWORD FeatureId,
              PDWORD Length
    );
# 9030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetXStateFeaturesMask(
            PCONTEXT Context,
         DWORD64 FeatureMask
    );
# 9098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
}




#pragma warning(pop)
# 9160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winbase.h" 3
extern "C++" {

__forceinline
unsigned
_InterlockedIncrement(
                                  unsigned volatile *Addend
    )
{
    return (unsigned) _InterlockedIncrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedIncrement(
                                  unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedIncrement((volatile long*) Addend);
}




__forceinline
unsigned __int64
_InterlockedIncrement(
                                  unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) (_InterlockedIncrement64)((volatile __int64*) Addend);
}



__forceinline
unsigned
_InterlockedDecrement(
                                  unsigned volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedDecrement(
                                  unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}




__forceinline
unsigned __int64
_InterlockedDecrement(
                                  unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) (_InterlockedDecrement64)((volatile __int64*) Addend);
}





__forceinline
unsigned
_InterlockedExchange(
                                  unsigned volatile *Target,
         unsigned Value
    )
{
    return (unsigned) _InterlockedExchange((volatile long*) Target, (long) Value);
}

__forceinline
unsigned long
_InterlockedExchange(
                                  unsigned long volatile *Target,
         unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchange(
                                  unsigned __int64 volatile *Target,
         unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchange64((volatile __int64*) Target, (__int64) Value);
}



__forceinline
unsigned
_InterlockedExchangeAdd(
                                  unsigned volatile *Addend,
         unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned
InterlockedExchangeSubtract(
                                  unsigned volatile *Addend,
         unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend, - (long) Value);
}

__forceinline
unsigned long
_InterlockedExchangeAdd(
                                  unsigned long volatile *Addend,
         unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned long
InterlockedExchangeSubtract(
                                  unsigned long volatile *Addend,
         unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend, - (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchangeAdd(
                                  unsigned __int64 volatile *Addend,
         unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64((volatile __int64*) Addend, (__int64) Value);
}

__forceinline
unsigned __int64
InterlockedExchangeSubtract(
                                  unsigned __int64 volatile *Addend,
         unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64((volatile __int64*) Addend, - (__int64) Value);
}



__forceinline
unsigned
_InterlockedCompareExchange(
                                  unsigned volatile *Destination,
         unsigned Exchange,
         unsigned Comperand
    )
{
    return (unsigned) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}

__forceinline
unsigned long
_InterlockedCompareExchange(
                                  unsigned long volatile *Destination,
         unsigned long Exchange,
         unsigned long Comperand
    )
{
    return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}



__forceinline
unsigned __int64
_InterlockedCompareExchange(
                                  unsigned __int64 volatile *Destination,
         unsigned __int64 Exchange,
         unsigned __int64 Comperand
    )
{
    return (unsigned __int64) _InterlockedCompareExchange64((volatile __int64*) Destination, (__int64) Exchange, (__int64) Comperand);
}

__forceinline
unsigned __int64
_InterlockedAnd(
                                  unsigned __int64 volatile *Destination,
         unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedAnd64((volatile __int64*) Destination, (__int64) Value);
}

__forceinline
unsigned __int64
_InterlockedOr(
                                  unsigned __int64 volatile *Destination,
         unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedOr64((volatile __int64*) Destination, (__int64) Value);
}

__forceinline
unsigned __int64
_InterlockedXor(
                                  unsigned __int64 volatile *Destination,
         unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedXor64((volatile __int64*) Destination, (__int64) Value);
}





}
# 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 1 3
# 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
#pragma warning(push)
#pragma warning(disable: 4201)



#pragma warning(disable: 4820)
# 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
extern "C" {
# 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _PSINJECTDATA {

    DWORD DataBytes;
    WORD InjectionPoint;
    WORD PageNumber;



} PSINJECTDATA, *PPSINJECTDATA;
# 513 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;





typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;
# 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagXFORM
  {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
  } XFORM, *PXFORM, *LPXFORM;


typedef struct tagBITMAP
  {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    LPVOID bmBits;
  } BITMAP, *PBITMAP, *NPBITMAP, *LPBITMAP;





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack1.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack1.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,1)
# 615 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3





typedef struct tagRGBTRIPLE {
        BYTE rgbtBlue;
        BYTE rgbtGreen;
        BYTE rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE, *NPRGBTRIPLE, *LPRGBTRIPLE;





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3





typedef struct tagRGBQUAD {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbReserved;
} RGBQUAD;







typedef RGBQUAD * LPRGBQUAD;
# 672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef LONG LCSCSTYPE;



typedef LONG LCSGAMUTMATCH;
# 704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef long FXPT16DOT16, *LPFXPT16DOT16;
typedef long FXPT2DOT30, *LPFXPT2DOT30;




typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;







typedef CIEXYZ *LPCIEXYZ;







typedef struct tagICEXYZTRIPLE
{
        CIEXYZ ciexyzRed;
        CIEXYZ ciexyzGreen;
        CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE;







typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE;
# 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;




typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
# 798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagBITMAPCOREHEADER {
        DWORD bcSize;
        WORD bcWidth;
        WORD bcHeight;
        WORD bcPlanes;
        WORD bcBitCount;
} BITMAPCOREHEADER, *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;







typedef struct tagBITMAPINFOHEADER{
        DWORD biSize;
        LONG biWidth;
        LONG biHeight;
        WORD biPlanes;
        WORD biBitCount;
        DWORD biCompression;
        DWORD biSizeImage;
        LONG biXPelsPerMeter;
        LONG biYPelsPerMeter;
        DWORD biClrUsed;
        DWORD biClrImportant;
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;
# 834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct {
        DWORD bV4Size;
        LONG bV4Width;
        LONG bV4Height;
        WORD bV4Planes;
        WORD bV4BitCount;
        DWORD bV4V4Compression;
        DWORD bV4SizeImage;
        LONG bV4XPelsPerMeter;
        LONG bV4YPelsPerMeter;
        DWORD bV4ClrUsed;
        DWORD bV4ClrImportant;
        DWORD bV4RedMask;
        DWORD bV4GreenMask;
        DWORD bV4BlueMask;
        DWORD bV4AlphaMask;
        DWORD bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD bV4GammaRed;
        DWORD bV4GammaGreen;
        DWORD bV4GammaBlue;
} BITMAPV4HEADER, *LPBITMAPV4HEADER, *PBITMAPV4HEADER;
# 865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct {
        DWORD bV5Size;
        LONG bV5Width;
        LONG bV5Height;
        WORD bV5Planes;
        WORD bV5BitCount;
        DWORD bV5Compression;
        DWORD bV5SizeImage;
        LONG bV5XPelsPerMeter;
        LONG bV5YPelsPerMeter;
        DWORD bV5ClrUsed;
        DWORD bV5ClrImportant;
        DWORD bV5RedMask;
        DWORD bV5GreenMask;
        DWORD bV5BlueMask;
        DWORD bV5AlphaMask;
        DWORD bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD bV5GammaRed;
        DWORD bV5GammaGreen;
        DWORD bV5GammaBlue;
        DWORD bV5Intent;
        DWORD bV5ProfileData;
        DWORD bV5ProfileSize;
        DWORD bV5Reserved;
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;
# 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1];
} BITMAPINFO, *LPBITMAPINFO, *PBITMAPINFO;







typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO, *LPBITMAPCOREINFO, *PBITMAPCOREINFO;





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack2.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack2.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,2)
# 932 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3





typedef struct tagBITMAPFILEHEADER {
        WORD bfType;
        DWORD bfSize;
        WORD bfReserved1;
        WORD bfReserved2;
        DWORD bfOffBits;
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;





# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3
# 958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;







typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, *NPCHARSETINFO, *LPCHARSETINFO;
# 990 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;
# 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
    typedef BYTE BCHAR;








# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,4)
# 1148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3





typedef struct tagTEXTMETRICA
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA, *NPTEXTMETRICA, *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW, *NPTEXTMETRICW, *LPTEXTMETRICW;






typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;






# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 1214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3
# 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack4.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,4)
# 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3





typedef struct tagNEWTEXTMETRICA
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, *NPNEWTEXTMETRICA, *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW, *NPNEWTEXTMETRICW, *LPNEWTEXTMETRICW;






typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;






# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 1305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 2 3







typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA ntmTm;
    FONTSIGNATURE ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW ntmTm;
    FONTSIGNATURE ntmFontSig;
}NEWTEXTMETRICEXW;



typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
# 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagPELARRAY
  {
    LONG paXCount;
    LONG paYCount;
    LONG paXExt;
    LONG paYExt;
    BYTE paRGBs;
  } PELARRAY, *PPELARRAY, *NPPELARRAY, *LPPELARRAY;
# 1355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagLOGBRUSH
  {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG_PTR lbHatch;
  } LOGBRUSH, *PLOGBRUSH, *NPLOGBRUSH, *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;







typedef LOGBRUSH PATTERN;
typedef PATTERN *PPATTERN;
typedef PATTERN *NPPATTERN;
typedef PATTERN *LPPATTERN;
# 1387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagLOGPEN
  {
    UINT lopnStyle;
    POINT lopnWidth;
    COLORREF lopnColor;
  } LOGPEN, *PLOGPEN, *NPLOGPEN, *LPLOGPEN;







typedef struct tagEXTLOGPEN {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG_PTR elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN, *NPEXTLOGPEN, *LPEXTLOGPEN;







typedef struct tagEXTLOGPEN32 {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32, *NPEXTLOGPEN32, *LPEXTLOGPEN32;



typedef struct tagPALETTEENTRY {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
} PALETTEENTRY, *PPALETTEENTRY, *LPPALETTEENTRY;





typedef struct tagLOGPALETTE {
    WORD palVersion;
    WORD palNumEntries;
                                    PALETTEENTRY palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, *NPLOGPALETTE, *LPLOGPALETTE;






typedef struct tagLOGFONTA
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[32];
} LOGFONTA, *PLOGFONTA, *NPLOGFONTA, *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[32];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;






typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
# 1505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;

typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;




typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;



typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    BYTE elfScript[32];
} ENUMLOGFONTEXA, *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    WCHAR elfScript[32];
} ENUMLOGFONTEXW, *LPENUMLOGFONTEXW;




typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
# 1683 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagPANOSE
{
    BYTE bFamilyType;
    BYTE bSerifStyle;
    BYTE bWeight;
    BYTE bProportion;
    BYTE bContrast;
    BYTE bStrokeVariation;
    BYTE bArmStyle;
    BYTE bLetterform;
    BYTE bMidline;
    BYTE bXHeight;
} PANOSE, * LPPANOSE;
# 1809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagEXTLOGFONTA {
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    DWORD elfVersion;
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture;
    PANOSE elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA, *NPEXTLOGFONTA, *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    DWORD elfVersion;
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture;
    PANOSE elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW, *NPEXTLOGFONTW, *LPEXTLOGFONTW;






typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
# 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _devicemodeA {
    BYTE dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {

      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      } ;

      struct {
        POINTL dmPosition;
        DWORD dmDisplayOrientation;
        DWORD dmDisplayFixedOutput;
      } ;
    } ;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    } ;
    DWORD dmDisplayFrequency;

    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;

    DWORD dmPanningWidth;
    DWORD dmPanningHeight;


} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {

      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      } ;

      struct {
        POINTL dmPosition;
        DWORD dmDisplayOrientation;
        DWORD dmDisplayFixedOutput;
      } ;
    } ;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    } ;
    DWORD dmDisplayFrequency;

    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;

    DWORD dmPanningWidth;
    DWORD dmPanningHeight;


} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;






typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
# 2730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _DISPLAY_DEVICEA {
    DWORD cb;
    CHAR DeviceName[32];
    CHAR DeviceString[128];
    DWORD StateFlags;
    CHAR DeviceID[128];
    CHAR DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD cb;
    WCHAR DeviceName[32];
    WCHAR DeviceString[128];
    DWORD StateFlags;
    WCHAR DeviceID[128];
    WCHAR DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;





typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
# 3233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _RGNDATAHEADER {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER rdh;
    char Buffer[1];
} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;
# 3257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _ABC {
    int abcA;
    UINT abcB;
    int abcC;
} ABC, *PABC, *NPABC, *LPABC;

typedef struct _ABCFLOAT {
    FLOAT abcfA;
    FLOAT abcfB;
    FLOAT abcfC;
} ABCFLOAT, *PABCFLOAT, *NPABCFLOAT, *LPABCFLOAT;
# 3281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _OUTLINETEXTMETRICA {
    UINT otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
     int otmsCharSlopeRise;
     int otmsCharSlopeRun;
     int otmItalicAngle;
    UINT otmEMSquare;
     int otmAscent;
     int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
     int otmMacAscent;
     int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
     int otmsStrikeoutPosition;
     int otmsUnderscoreSize;
     int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, *NPOUTLINETEXTMETRICA, *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
     int otmsCharSlopeRise;
     int otmsCharSlopeRun;
     int otmItalicAngle;
    UINT otmEMSquare;
     int otmAscent;
     int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
     int otmMacAscent;
     int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
     int otmsStrikeoutPosition;
     int otmsUnderscoreSize;
     int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, *NPOUTLINETEXTMETRICW, *LPOUTLINETEXTMETRICW;






typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
# 3373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagPOLYTEXTA
{
    int x;
    int y;
    UINT n;
    LPCSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int *pdx;
} POLYTEXTA, *PPOLYTEXTA, *NPPOLYTEXTA, *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int x;
    int y;
    UINT n;
    LPCWSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int *pdx;
} POLYTEXTW, *PPOLYTEXTW, *NPPOLYTEXTW, *LPPOLYTEXTW;






typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
# 3411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _FIXED {

    WORD fract;
    short value;




} FIXED;


typedef struct _MAT2 {
     FIXED eM11;
     FIXED eM12;
     FIXED eM21;
     FIXED eM22;
} MAT2, *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT gmBlackBoxX;
    UINT gmBlackBoxY;
    POINT gmptGlyphOrigin;
    short gmCellIncX;
    short gmCellIncY;
} GLYPHMETRICS, *LPGLYPHMETRICS;
# 3469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD wType;
    WORD cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD cb;
    DWORD dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;
# 3539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagGCP_RESULTSA
    {
    DWORD lStructSize;
    LPSTR lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD lStructSize;
    LPWSTR lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;




typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
# 3578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct _RASTERIZER_STATUS {
    short nSize;
    short wFlags;
    short nLanguageID;
} RASTERIZER_STATUS, *LPRASTERIZER_STATUS;
# 3595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerType;
    BYTE bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, *LPPIXELFORMATDESCRIPTOR;
# 3667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef int (__stdcall* OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (__stdcall* OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);
# 3684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef OLDFONTENUMPROCA FONTENUMPROCA;
typedef OLDFONTENUMPROCW FONTENUMPROCW;



typedef FONTENUMPROCA FONTENUMPROC;


typedef int (__stdcall* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (__stdcall* LINEDDAPROC)(int, int, LPARAM);
# 3715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) int __stdcall AddFontResourceA( LPCSTR);
__declspec(dllimport) int __stdcall AddFontResourceW( LPCWSTR);






 __declspec(dllimport) BOOL __stdcall AnimatePalette( HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY * ppe);
 __declspec(dllimport) BOOL __stdcall Arc( HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
 __declspec(dllimport) BOOL __stdcall BitBlt( HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
__declspec(dllimport) BOOL __stdcall CancelDC( HDC hdc);
 __declspec(dllimport) BOOL __stdcall Chord( HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
__declspec(dllimport) int __stdcall ChoosePixelFormat( HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) HMETAFILE __stdcall CloseMetaFile( HDC hdc);
__declspec(dllimport) int __stdcall CombineRgn( HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA( HMETAFILE, LPCSTR);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW( HMETAFILE, LPCWSTR);





 __declspec(dllimport) HBITMAP __stdcall CreateBitmap( int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits);
 __declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect( const BITMAP *pbm);
 __declspec(dllimport) HBRUSH __stdcall CreateBrushIndirect( const LOGBRUSH *plbrush);
__declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap( HDC hdc, int cx, int cy);
__declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap( HDC hdc, int cx, int cy);
__declspec(dllimport) HDC __stdcall CreateCompatibleDC( HDC hdc);
__declspec(dllimport) HDC __stdcall CreateDCA( LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA * pdm);
__declspec(dllimport) HDC __stdcall CreateDCW( LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW * pdm);





__declspec(dllimport) HBITMAP __stdcall CreateDIBitmap( HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage);
__declspec(dllimport) HBRUSH __stdcall CreateDIBPatternBrush( HGLOBAL h, UINT iUsage);
 __declspec(dllimport) HBRUSH __stdcall CreateDIBPatternBrushPt( const void *lpPackedDIB, UINT iUsage);
__declspec(dllimport) HRGN __stdcall CreateEllipticRgn( int x1, int y1, int x2, int y2);
__declspec(dllimport) HRGN __stdcall CreateEllipticRgnIndirect( const RECT *lprect);
 __declspec(dllimport) HFONT __stdcall CreateFontIndirectA( const LOGFONTA *lplf);
 __declspec(dllimport) HFONT __stdcall CreateFontIndirectW( const LOGFONTW *lplf);





__declspec(dllimport) HFONT __stdcall CreateFontA( int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
                                  DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
                                  DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
__declspec(dllimport) HFONT __stdcall CreateFontW( int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
                                  DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
                                  DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);






__declspec(dllimport) HBRUSH __stdcall CreateHatchBrush( int iHatch, COLORREF color);
__declspec(dllimport) HDC __stdcall CreateICA( LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA * pdm);
__declspec(dllimport) HDC __stdcall CreateICW( LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW * pdm);





__declspec(dllimport) HDC __stdcall CreateMetaFileA( LPCSTR pszFile);
__declspec(dllimport) HDC __stdcall CreateMetaFileW( LPCWSTR pszFile);





 __declspec(dllimport) HPALETTE __stdcall CreatePalette( const LOGPALETTE * plpal);
__declspec(dllimport) HPEN __stdcall CreatePen( int iStyle, int cWidth, COLORREF color);
 __declspec(dllimport) HPEN __stdcall CreatePenIndirect( const LOGPEN *plpen);
__declspec(dllimport) HRGN __stdcall CreatePolyPolygonRgn( const POINT *pptl,
                                                                  const INT *pc,
                                                     int cPoly,
                                                     int iMode);
 __declspec(dllimport) HBRUSH __stdcall CreatePatternBrush( HBITMAP hbm);
__declspec(dllimport) HRGN __stdcall CreateRectRgn( int x1, int y1, int x2, int y2);
__declspec(dllimport) HRGN __stdcall CreateRectRgnIndirect( const RECT *lprect);
__declspec(dllimport) HRGN __stdcall CreateRoundRectRgn( int x1, int y1, int x2, int y2, int w, int h);
__declspec(dllimport) BOOL __stdcall CreateScalableFontResourceA( DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath);
__declspec(dllimport) BOOL __stdcall CreateScalableFontResourceW( DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath);





__declspec(dllimport) HBRUSH __stdcall CreateSolidBrush( COLORREF color);

__declspec(dllimport) BOOL __stdcall DeleteDC( HDC hdc);
__declspec(dllimport) BOOL __stdcall DeleteMetaFile( HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall DeleteObject( HGDIOBJ ho);
__declspec(dllimport) int __stdcall DescribePixelFormat( HDC hdc,
                                                 int iPixelFormat,
                                                 UINT nBytes,
                                                                           LPPIXELFORMATDESCRIPTOR ppfd);





typedef UINT (__stdcall* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD (__stdcall* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);
# 3909 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesA(
                        LPCSTR pDevice,
                        LPCSTR pPort,
                        WORD fwCapability,
                                         LPSTR pOutput,
                        const DEVMODEA *pDevMode
    );
__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesW(
                        LPCWSTR pDevice,
                        LPCWSTR pPort,
                        WORD fwCapability,
                                         LPWSTR pOutput,
                        const DEVMODEW *pDevMode
    );






__declspec(dllimport) int __stdcall DrawEscape( HDC hdc,
                                         int iEscape,
                                         int cjIn,
                                                               LPCSTR lpIn);

 __declspec(dllimport) BOOL __stdcall Ellipse( HDC hdc, int left, int top, int right, int bottom);


__declspec(dllimport) int __stdcall EnumFontFamiliesExA( HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags);
__declspec(dllimport) int __stdcall EnumFontFamiliesExW( HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);







__declspec(dllimport) int __stdcall EnumFontFamiliesA( HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
__declspec(dllimport) int __stdcall EnumFontFamiliesW( HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);





__declspec(dllimport) int __stdcall EnumFontsA( HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
__declspec(dllimport) int __stdcall EnumFontsW( HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);







__declspec(dllimport) int __stdcall EnumObjects( HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam);





__declspec(dllimport) BOOL __stdcall EqualRgn( HRGN hrgn1, HRGN hrgn2);
 __declspec(dllimport) int __stdcall Escape( HDC hdc,
                                     int iEscape,
                                     int cjIn,
                                                           LPCSTR pvIn,
                                          LPVOID pvOut);
__declspec(dllimport) int __stdcall ExtEscape( HDC hdc,
                                         int iEscape,
                                         int cjInput,
                                                                  LPCSTR lpInData,
                                         int cjOutput,
                                                                     LPSTR lpOutData);
 __declspec(dllimport) int __stdcall ExcludeClipRect( HDC hdc, int left, int top, int right, int bottom);
 __declspec(dllimport) HRGN __stdcall ExtCreateRegion( const XFORM * lpx, DWORD nCount, const RGNDATA * lpData);
 __declspec(dllimport) BOOL __stdcall ExtFloodFill( HDC hdc, int x, int y, COLORREF color, UINT type);
 __declspec(dllimport) BOOL __stdcall FillRgn( HDC hdc, HRGN hrgn, HBRUSH hbr);
 __declspec(dllimport) BOOL __stdcall FloodFill( HDC hdc, int x, int y, COLORREF color);
 __declspec(dllimport) BOOL __stdcall FrameRgn( HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
__declspec(dllimport) int __stdcall GetROP2( HDC hdc);
__declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx( HDC hdc, LPSIZE lpsize);
__declspec(dllimport) COLORREF __stdcall GetBkColor( HDC hdc);


__declspec(dllimport) COLORREF __stdcall GetDCBrushColor( HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCPenColor( HDC hdc);


__declspec(dllimport)
int
__stdcall
GetBkMode(
         HDC hdc
    );

__declspec(dllimport)
LONG
__stdcall
GetBitmapBits(
         HBITMAP hbit,
         LONG cb,
                           LPVOID lpvBits
    );

__declspec(dllimport) BOOL __stdcall GetBitmapDimensionEx( HBITMAP hbit, LPSIZE lpsize);
__declspec(dllimport) UINT __stdcall GetBoundsRect( HDC hdc, LPRECT lprect, UINT flags);

__declspec(dllimport) BOOL __stdcall GetBrushOrgEx( HDC hdc, LPPOINT lppt);

__declspec(dllimport) BOOL __stdcall GetCharWidthA( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidthW( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);





__declspec(dllimport) BOOL __stdcall GetCharWidth32A( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidth32W( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);





__declspec(dllimport) BOOL __stdcall GetCharWidthFloatA( HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidthFloatW( HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);






__declspec(dllimport) BOOL __stdcall GetCharABCWidthsA( HDC hdc,
                                                 UINT wFirst,
                                                 UINT wLast,
                                                                             LPABC lpABC);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsW( HDC hdc,
                                                 UINT wFirst,
                                                 UINT wLast,
                                                                             LPABC lpABC);






__declspec(dllimport) BOOL __stdcall GetCharABCWidthsFloatA( HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsFloatW( HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);





__declspec(dllimport) int __stdcall GetClipBox( HDC hdc, LPRECT lprect);
__declspec(dllimport) int __stdcall GetClipRgn( HDC hdc, HRGN hrgn);
__declspec(dllimport) int __stdcall GetMetaRgn( HDC hdc, HRGN hrgn);
__declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject( HDC hdc, UINT type);
__declspec(dllimport) BOOL __stdcall GetCurrentPositionEx( HDC hdc, LPPOINT lppt);
__declspec(dllimport) int __stdcall GetDeviceCaps( HDC hdc, int index);
__declspec(dllimport) int __stdcall GetDIBits( HDC hdc, HBITMAP hbm, UINT start, UINT cLines,
              LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);


__declspec(dllimport) DWORD __stdcall GetFontData ( HDC hdc,
                                             DWORD dwTable,
                                             DWORD dwOffset,
                                                                                    PVOID pvBuffer,
                                             DWORD cjBuffer
                                        );

__declspec(dllimport) DWORD __stdcall GetGlyphOutlineA( HDC hdc,
                                                 UINT uChar,
                                                 UINT fuFormat,
                                                  LPGLYPHMETRICS lpgm,
                                                 DWORD cjBuffer,
                                                                             LPVOID pvBuffer,
                                                 const MAT2 *lpmat2
                                        );
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineW( HDC hdc,
                                                 UINT uChar,
                                                 UINT fuFormat,
                                                  LPGLYPHMETRICS lpgm,
                                                 DWORD cjBuffer,
                                                                             LPVOID pvBuffer,
                                                 const MAT2 *lpmat2
                                        );






__declspec(dllimport) int __stdcall GetGraphicsMode( HDC hdc);
__declspec(dllimport) int __stdcall GetMapMode( HDC hdc);
__declspec(dllimport) UINT __stdcall GetMetaFileBitsEx( HMETAFILE hMF, UINT cbBuffer, LPVOID lpData);
__declspec(dllimport) HMETAFILE __stdcall GetMetaFileA( LPCSTR lpName);
__declspec(dllimport) HMETAFILE __stdcall GetMetaFileW( LPCWSTR lpName);





__declspec(dllimport) COLORREF __stdcall GetNearestColor( HDC hdc, COLORREF color);
__declspec(dllimport) UINT __stdcall GetNearestPaletteIndex( HPALETTE h, COLORREF color);
__declspec(dllimport) DWORD __stdcall GetObjectType( HGDIOBJ h);



__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA( HDC hdc,
                                                     UINT cjCopy,
                                                                               LPOUTLINETEXTMETRICA potm);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW( HDC hdc,
                                                     UINT cjCopy,
                                                                               LPOUTLINETEXTMETRICW potm);
# 4135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) UINT __stdcall GetPaletteEntries( HPALETTE hpal,
                                                 UINT iStart,
                                                 UINT cEntries,
                                                                                 LPPALETTEENTRY pPalEntries);
__declspec(dllimport) COLORREF __stdcall GetPixel( HDC hdc, int x, int y);
__declspec(dllimport) int __stdcall GetPixelFormat( HDC hdc);
__declspec(dllimport) int __stdcall GetPolyFillMode( HDC hdc);
__declspec(dllimport) BOOL __stdcall GetRasterizerCaps( LPRASTERIZER_STATUS lpraststat,
                                                 UINT cjBytes);

__declspec(dllimport) int __stdcall GetRandomRgn ( HDC hdc, HRGN hrgn, INT i);
__declspec(dllimport) DWORD __stdcall GetRegionData( HRGN hrgn,
                                             DWORD nCount,
                                                                                  LPRGNDATA lpRgnData);
__declspec(dllimport) int __stdcall GetRgnBox( HRGN hrgn, LPRECT lprc);
__declspec(dllimport) HGDIOBJ __stdcall GetStockObject( int i);
__declspec(dllimport) int __stdcall GetStretchBltMode( HDC hdc);
__declspec(dllimport)
UINT
__stdcall
GetSystemPaletteEntries(
         HDC hdc,
         UINT iStart,
         UINT cEntries,
                               LPPALETTEENTRY pPalEntries
    );

__declspec(dllimport) UINT __stdcall GetSystemPaletteUse( HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharacterExtra( HDC hdc);
__declspec(dllimport) UINT __stdcall GetTextAlign( HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetTextColor( HDC hdc);

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointA(
         HDC hdc,
                  LPCSTR lpString,
         int c,
          LPSIZE lpsz
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointW(
         HDC hdc,
                  LPCWSTR lpString,
         int c,
          LPSIZE lpsz
    );






__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32A(
         HDC hdc,
                  LPCSTR lpString,
         int c,
          LPSIZE psizl
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32W(
         HDC hdc,
                  LPCWSTR lpString,
         int c,
          LPSIZE psizl
    );






__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointA(
         HDC hdc,
                          LPCSTR lpszString,
         int cchString,
         int nMaxExtent,
              LPINT lpnFit,
                                             LPINT lpnDx,
          LPSIZE lpSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointW(
         HDC hdc,
                          LPCWSTR lpszString,
         int cchString,
         int nMaxExtent,
              LPINT lpnFit,
                                             LPINT lpnDx,
          LPSIZE lpSize
    );







__declspec(dllimport) int __stdcall GetTextCharset( HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharsetInfo( HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
__declspec(dllimport) BOOL __stdcall TranslateCharsetInfo( DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetFontLanguageInfo( HDC hdc);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementA( HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementW( HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags);
# 4267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagWCRANGE
{
    WCHAR wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD cbThis;
    DWORD flAccel;
    DWORD cGlyphsSupported;
    DWORD cRanges;
    WCRANGE ranges[1];
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;
# 4291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges( HDC hdc, LPGLYPHSET lpgs);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesA( HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesW( HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl);





__declspec(dllimport) BOOL __stdcall GetTextExtentPointI( HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize);
__declspec(dllimport) BOOL __stdcall GetTextExtentExPointI ( HDC hdc,
                                                                       LPWORD lpwszString,
                                                     int cwchString,
                                                     int nMaxExtent,
                                                          LPINT lpnFit,
                                                                                         LPINT lpnDx,
                                                      LPSIZE lpSize
                                                );

__declspec(dllimport) BOOL __stdcall GetCharWidthI( HDC hdc,
                                             UINT giFirst,
                                             UINT cgi,
                                                            LPWORD pgi,
                                                          LPINT piWidths
                                        );

__declspec(dllimport) BOOL __stdcall GetCharABCWidthsI( HDC hdc,
                                                 UINT giFirst,
                                                 UINT cgi,
                                                                LPWORD pgi,
                                                              LPABC pabc
                                        );
# 4331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagDESIGNVECTOR
{
    DWORD dvReserved;
    DWORD dvNumAxes;
    LONG dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;

__declspec(dllimport) int __stdcall AddFontResourceExA( LPCSTR name, DWORD fl, PVOID res);
__declspec(dllimport) int __stdcall AddFontResourceExW( LPCWSTR name, DWORD fl, PVOID res);





__declspec(dllimport) BOOL __stdcall RemoveFontResourceExA( LPCSTR name, DWORD fl, PVOID pdv);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExW( LPCWSTR name, DWORD fl, PVOID pdv);





__declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx( PVOID pFileView,
                                                     DWORD cjSize,
                                                           PVOID pvResrved,
                                                     DWORD* pNumFonts);

__declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx( HANDLE h);
# 4367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagAXISINFOA
{
    LONG axMinValue;
    LONG axMaxValue;
    BYTE axAxisName[16];
} AXISINFOA, *PAXISINFOA, *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG axMinValue;
    LONG axMaxValue;
    WCHAR axAxisName[16];
} AXISINFOW, *PAXISINFOW, *LPAXISINFOW;





typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;


typedef struct tagAXESLISTA
{
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA, *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW, *LPAXESLISTW;





typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;






typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, *LPENUMLOGFONTEXDVW;





typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;


__declspec(dllimport) HFONT __stdcall CreateFontIndirectExA( const ENUMLOGFONTEXDVA *);
__declspec(dllimport) HFONT __stdcall CreateFontIndirectExW( const ENUMLOGFONTEXDVW *);







typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA, *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW, *LPENUMTEXTMETRICW;





typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
# 4473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) BOOL __stdcall GetViewportExtEx( HDC hdc, LPSIZE lpsize);
__declspec(dllimport) BOOL __stdcall GetViewportOrgEx( HDC hdc, LPPOINT lppoint);
__declspec(dllimport) BOOL __stdcall GetWindowExtEx( HDC hdc, LPSIZE lpsize);
__declspec(dllimport) BOOL __stdcall GetWindowOrgEx( HDC hdc, LPPOINT lppoint);

 __declspec(dllimport) int __stdcall IntersectClipRect( HDC hdc, int left, int top, int right, int bottom);
 __declspec(dllimport) BOOL __stdcall InvertRgn( HDC hdc, HRGN hrgn);
__declspec(dllimport) BOOL __stdcall LineDDA( int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data);
 __declspec(dllimport) BOOL __stdcall LineTo( HDC hdc, int x, int y);
__declspec(dllimport) BOOL __stdcall MaskBlt( HDC hdcDest, int xDest, int yDest, int width, int height,
                   HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop);
__declspec(dllimport) BOOL __stdcall PlgBlt( HDC hdcDest, const POINT * lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width,
                          int height, HBITMAP hbmMask, int xMask, int yMask);

 __declspec(dllimport) int __stdcall OffsetClipRgn( HDC hdc, int x, int y);
__declspec(dllimport) int __stdcall OffsetRgn( HRGN hrgn, int x, int y);
 __declspec(dllimport) BOOL __stdcall PatBlt( HDC hdc, int x, int y, int w, int h, DWORD rop);
 __declspec(dllimport) BOOL __stdcall Pie( HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
__declspec(dllimport) BOOL __stdcall PlayMetaFile( HDC hdc, HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall PaintRgn( HDC hdc, HRGN hrgn);
 __declspec(dllimport) BOOL __stdcall PolyPolygon( HDC hdc, const POINT *apt, const INT *asz, int csz);
__declspec(dllimport) BOOL __stdcall PtInRegion( HRGN hrgn, int x, int y);
__declspec(dllimport) BOOL __stdcall PtVisible( HDC hdc, int x, int y);
__declspec(dllimport) BOOL __stdcall RectInRegion( HRGN hrgn, const RECT * lprect);
__declspec(dllimport) BOOL __stdcall RectVisible( HDC hdc, const RECT * lprect);
 __declspec(dllimport) BOOL __stdcall Rectangle( HDC hdc, int left, int top, int right, int bottom);
 __declspec(dllimport) BOOL __stdcall RestoreDC( HDC hdc, int nSavedDC);
 __declspec(dllimport) HDC __stdcall ResetDCA( HDC hdc, const DEVMODEA * lpdm);
 __declspec(dllimport) HDC __stdcall ResetDCW( HDC hdc, const DEVMODEW * lpdm);





 __declspec(dllimport) UINT __stdcall RealizePalette( HDC hdc);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceA( LPCSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceW( LPCWSTR lpFileName);





 __declspec(dllimport) BOOL __stdcall RoundRect( HDC hdc, int left, int top, int right, int bottom, int width, int height);
 __declspec(dllimport) BOOL __stdcall ResizePalette( HPALETTE hpal, UINT n);

 __declspec(dllimport) int __stdcall SaveDC( HDC hdc);
 __declspec(dllimport) int __stdcall SelectClipRgn( HDC hdc, HRGN hrgn);
__declspec(dllimport) int __stdcall ExtSelectClipRgn( HDC hdc, HRGN hrgn, int mode);
__declspec(dllimport) int __stdcall SetMetaRgn( HDC hdc);
 __declspec(dllimport) HGDIOBJ __stdcall SelectObject( HDC hdc, HGDIOBJ h);
 __declspec(dllimport) HPALETTE __stdcall SelectPalette( HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
 __declspec(dllimport) COLORREF __stdcall SetBkColor( HDC hdc, COLORREF color);


__declspec(dllimport) COLORREF __stdcall SetDCBrushColor( HDC hdc, COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCPenColor( HDC hdc, COLORREF color);


 __declspec(dllimport) int __stdcall SetBkMode( HDC hdc, int mode);

__declspec(dllimport)
LONG __stdcall
SetBitmapBits(
         HBITMAP hbm,
         DWORD cb,
                         const void *pvBits);

__declspec(dllimport) UINT __stdcall SetBoundsRect( HDC hdc, const RECT * lprect, UINT flags);
__declspec(dllimport) int __stdcall SetDIBits( HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO * lpbmi, UINT ColorUse);
 __declspec(dllimport) int __stdcall SetDIBitsToDevice( HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc,
             int ySrc, UINT StartScan, UINT cLines, const void * lpvBits, const BITMAPINFO * lpbmi, UINT ColorUse);
 __declspec(dllimport) DWORD __stdcall SetMapperFlags( HDC hdc, DWORD flags);
__declspec(dllimport) int __stdcall SetGraphicsMode( HDC hdc, int iMode);
 __declspec(dllimport) int __stdcall SetMapMode( HDC hdc, int iMode);


 __declspec(dllimport) DWORD __stdcall SetLayout( HDC hdc, DWORD l);
__declspec(dllimport) DWORD __stdcall GetLayout( HDC hdc);


__declspec(dllimport) HMETAFILE __stdcall SetMetaFileBitsEx( UINT cbBuffer, const BYTE *lpData);
 __declspec(dllimport) UINT __stdcall SetPaletteEntries( HPALETTE hpal,
                                                 UINT iStart,
                                                 UINT cEntries,
                                                                 const PALETTEENTRY *pPalEntries);
 __declspec(dllimport) COLORREF __stdcall SetPixel( HDC hdc, int x, int y, COLORREF color);
__declspec(dllimport) BOOL __stdcall SetPixelV( HDC hdc, int x, int y, COLORREF color);
__declspec(dllimport) BOOL __stdcall SetPixelFormat( HDC hdc, int format, const PIXELFORMATDESCRIPTOR * ppfd);
 __declspec(dllimport) int __stdcall SetPolyFillMode( HDC hdc, int mode);
 __declspec(dllimport) BOOL __stdcall StretchBlt( HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
__declspec(dllimport) BOOL __stdcall SetRectRgn( HRGN hrgn, int left, int top, int right, int bottom);
 __declspec(dllimport) int __stdcall StretchDIBits( HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight,
                 const void * lpBits, const BITMAPINFO * lpbmi, UINT iUsage, DWORD rop);
 __declspec(dllimport) int __stdcall SetROP2( HDC hdc, int rop2);
 __declspec(dllimport) int __stdcall SetStretchBltMode( HDC hdc, int mode);
__declspec(dllimport) UINT __stdcall SetSystemPaletteUse( HDC hdc, UINT use);
 __declspec(dllimport) int __stdcall SetTextCharacterExtra( HDC hdc, int extra);
 __declspec(dllimport) COLORREF __stdcall SetTextColor( HDC hdc, COLORREF color);
 __declspec(dllimport) UINT __stdcall SetTextAlign( HDC hdc, UINT align);
 __declspec(dllimport) BOOL __stdcall SetTextJustification( HDC hdc, int extra, int count);
__declspec(dllimport) BOOL __stdcall UpdateColors( HDC hdc);
# 4624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG x;
    LONG y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;







typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;







typedef struct _BLENDFUNCTION
{
    BYTE BlendOp;
    BYTE BlendFlags;
    BYTE SourceConstantAlpha;
    BYTE AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;
# 4688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) BOOL __stdcall AlphaBlend(
         HDC hdcDest,
         int xoriginDest,
         int yoriginDest,
         int wDest,
         int hDest,
         HDC hdcSrc,
         int xoriginSrc,
         int yoriginSrc,
         int wSrc,
         int hSrc,
         BLENDFUNCTION ftn);

__declspec(dllimport) BOOL __stdcall TransparentBlt(
         HDC hdcDest,
         int xoriginDest,
         int yoriginDest,
         int wDest,
         int hDest,
         HDC hdcSrc,
         int xoriginSrc,
         int yoriginSrc,
         int wSrc,
         int hSrc,
         UINT crTransparent);
# 4724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport)
BOOL
__stdcall
GradientFill(
         HDC hdc,
                        PTRIVERTEX pVertex,
         ULONG nVertex,
         PVOID pMesh,
         ULONG nMesh,
         ULONG ulMode
    );
# 4747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) BOOL __stdcall GdiAlphaBlend( HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);

__declspec(dllimport) BOOL __stdcall GdiTransparentBlt( HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc,
                                                int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);

__declspec(dllimport) BOOL __stdcall GdiGradientFill( HDC hdc,
                                                            PTRIVERTEX pVertex,
                                             ULONG nVertex,
                                             PVOID pMesh,
                                             ULONG nCount,
                                             ULONG ulMode);
# 4850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) BOOL __stdcall GetTextMetricsA( HDC hdc, LPTEXTMETRICA lptm);
__declspec(dllimport) BOOL __stdcall GetTextMetricsW( HDC hdc, LPTEXTMETRICW lptm);
# 4882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagDIBSECTION {
    BITMAP dsBm;
    BITMAPINFOHEADER dsBmih;
    DWORD dsBitfields[3];
    HANDLE dshSection;
    DWORD dsOffset;
} DIBSECTION, *LPDIBSECTION, *PDIBSECTION;


__declspec(dllimport) BOOL __stdcall AngleArc( HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle);
__declspec(dllimport) BOOL __stdcall PolyPolyline( HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz);
__declspec(dllimport) BOOL __stdcall GetWorldTransform( HDC hdc, LPXFORM lpxf);
__declspec(dllimport) BOOL __stdcall SetWorldTransform( HDC hdc, const XFORM * lpxf);
__declspec(dllimport) BOOL __stdcall ModifyWorldTransform( HDC hdc, const XFORM * lpxf, DWORD mode);
__declspec(dllimport) BOOL __stdcall CombineTransform( LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2);






__declspec(dllimport) HBITMAP __stdcall CreateDIBSection(
                    HDC hdc,
                    const BITMAPINFO *pbmi,
                    UINT usage,


                    void **ppvBits,
                    HANDLE hSection,
                    DWORD offset);



__declspec(dllimport) UINT __stdcall GetDIBColorTable( HDC hdc,
                                             UINT iStart,
                                             UINT cEntries,
                                                                         RGBQUAD *prgbq);
__declspec(dllimport) UINT __stdcall SetDIBColorTable( HDC hdc,
                                             UINT iStart,
                                             UINT cEntries,
                                                             const RGBQUAD *prgbq);
# 4959 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagCOLORADJUSTMENT {
    WORD caSize;
    WORD caFlags;
    WORD caIlluminantIndex;
    WORD caRedGamma;
    WORD caGreenGamma;
    WORD caBlueGamma;
    WORD caReferenceBlack;
    WORD caReferenceWhite;
    SHORT caContrast;
    SHORT caBrightness;
    SHORT caColorfulness;
    SHORT caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, *LPCOLORADJUSTMENT;

__declspec(dllimport) BOOL __stdcall SetColorAdjustment( HDC hdc, const COLORADJUSTMENT *lpca);
__declspec(dllimport) BOOL __stdcall GetColorAdjustment( HDC hdc, LPCOLORADJUSTMENT lpca);
__declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette( HDC hdc);


typedef BOOL (__stdcall* ABORTPROC)( HDC, int);




typedef struct _DOCINFOA {
    int cbSize;
    LPCSTR lpszDocName;
    LPCSTR lpszOutput;

    LPCSTR lpszDatatype;
    DWORD fwType;

} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int cbSize;
    LPCWSTR lpszDocName;
    LPCWSTR lpszOutput;

    LPCWSTR lpszDatatype;
    DWORD fwType;

} DOCINFOW, *LPDOCINFOW;




typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;







 __declspec(dllimport) int __stdcall StartDocA( HDC hdc, const DOCINFOA *lpdi);
 __declspec(dllimport) int __stdcall StartDocW( HDC hdc, const DOCINFOW *lpdi);





 __declspec(dllimport) int __stdcall EndDoc( HDC hdc);
 __declspec(dllimport) int __stdcall StartPage( HDC hdc);
 __declspec(dllimport) int __stdcall EndPage( HDC hdc);
 __declspec(dllimport) int __stdcall AbortDoc( HDC hdc);
__declspec(dllimport) int __stdcall SetAbortProc( HDC hdc, ABORTPROC proc);

__declspec(dllimport) BOOL __stdcall AbortPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall ArcTo( HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
__declspec(dllimport) BOOL __stdcall BeginPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall CloseFigure( HDC hdc);
__declspec(dllimport) BOOL __stdcall EndPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall FillPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall FlattenPath( HDC hdc);
__declspec(dllimport) int __stdcall GetPath( HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
__declspec(dllimport) HRGN __stdcall PathToRegion( HDC hdc);
__declspec(dllimport) BOOL __stdcall PolyDraw( HDC hdc, const POINT * apt, const BYTE * aj, int cpt);
__declspec(dllimport) BOOL __stdcall SelectClipPath( HDC hdc, int mode);
__declspec(dllimport) int __stdcall SetArcDirection( HDC hdc, int dir);
__declspec(dllimport) BOOL __stdcall SetMiterLimit( HDC hdc, FLOAT limit, PFLOAT old);
__declspec(dllimport) BOOL __stdcall StrokeAndFillPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall StrokePath( HDC hdc);
__declspec(dllimport) BOOL __stdcall WidenPath( HDC hdc);
__declspec(dllimport) HPEN __stdcall ExtCreatePen( DWORD iPenStyle,
                                         DWORD cWidth,
                                         const LOGBRUSH *plbrush,
                                         DWORD cStyle,
                                                           const DWORD *pstyle);
__declspec(dllimport) BOOL __stdcall GetMiterLimit( HDC hdc, PFLOAT plimit);
__declspec(dllimport) int __stdcall GetArcDirection( HDC hdc);

__declspec(dllimport) int __stdcall GetObjectA( HANDLE h, int c, LPVOID pv);
__declspec(dllimport) int __stdcall GetObjectW( HANDLE h, int c, LPVOID pv);
# 5082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
 __declspec(dllimport) BOOL __stdcall MoveToEx( HDC hdc, int x, int y, LPPOINT lppt);
 __declspec(dllimport) BOOL __stdcall TextOutA( HDC hdc, int x, int y, LPCSTR lpString, int c);
 __declspec(dllimport) BOOL __stdcall TextOutW( HDC hdc, int x, int y, LPCWSTR lpString, int c);





 __declspec(dllimport) BOOL __stdcall ExtTextOutA( HDC hdc, int x, int y, UINT options, const RECT * lprect, LPCSTR lpString, UINT c, const INT * lpDx);
 __declspec(dllimport) BOOL __stdcall ExtTextOutW( HDC hdc, int x, int y, UINT options, const RECT * lprect, LPCWSTR lpString, UINT c, const INT * lpDx);





__declspec(dllimport) BOOL __stdcall PolyTextOutA( HDC hdc, const POLYTEXTA * ppt, int nstrings);
__declspec(dllimport) BOOL __stdcall PolyTextOutW( HDC hdc, const POLYTEXTW * ppt, int nstrings);






__declspec(dllimport) HRGN __stdcall CreatePolygonRgn( const POINT *pptl,
                                                 int cPoint,
                                                 int iMode);
__declspec(dllimport) BOOL __stdcall DPtoLP( HDC hdc, LPPOINT lppt, int c);
__declspec(dllimport) BOOL __stdcall LPtoDP( HDC hdc, LPPOINT lppt, int c);
 __declspec(dllimport) BOOL __stdcall Polygon( HDC hdc, const POINT *apt, int cpt);
 __declspec(dllimport) BOOL __stdcall Polyline( HDC hdc, const POINT *apt, int cpt);

__declspec(dllimport) BOOL __stdcall PolyBezier( HDC hdc, const POINT * apt, DWORD cpt);
__declspec(dllimport) BOOL __stdcall PolyBezierTo( HDC hdc, const POINT * apt, DWORD cpt);
__declspec(dllimport) BOOL __stdcall PolylineTo( HDC hdc, const POINT * apt, DWORD cpt);

 __declspec(dllimport) BOOL __stdcall SetViewportExtEx( HDC hdc, int x, int y, LPSIZE lpsz);
 __declspec(dllimport) BOOL __stdcall SetViewportOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 __declspec(dllimport) BOOL __stdcall SetWindowExtEx( HDC hdc, int x, int y, LPSIZE lpsz);
 __declspec(dllimport) BOOL __stdcall SetWindowOrgEx( HDC hdc, int x, int y, LPPOINT lppt);

 __declspec(dllimport) BOOL __stdcall OffsetViewportOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 __declspec(dllimport) BOOL __stdcall OffsetWindowOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 __declspec(dllimport) BOOL __stdcall ScaleViewportExtEx( HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz);
 __declspec(dllimport) BOOL __stdcall ScaleWindowExtEx( HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall SetBitmapDimensionEx( HBITMAP hbm, int w, int h, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall SetBrushOrgEx( HDC hdc, int x, int y, LPPOINT lppt);

__declspec(dllimport) int __stdcall GetTextFaceA( HDC hdc, int c, LPSTR lpName);
__declspec(dllimport) int __stdcall GetTextFaceW( HDC hdc, int c, LPWSTR lpName);
# 5139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

__declspec(dllimport) DWORD __stdcall GetKerningPairsA( HDC hdc,
                                                 DWORD nPairs,
                                                                                LPKERNINGPAIR lpKernPair);
__declspec(dllimport) DWORD __stdcall GetKerningPairsW( HDC hdc,
                                                 DWORD nPairs,
                                                                                LPKERNINGPAIR lpKernPair);







__declspec(dllimport) BOOL __stdcall GetDCOrgEx( HDC hdc, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall FixBrushOrgEx( HDC hdc, int x, int y, LPPOINT ptl);
__declspec(dllimport) BOOL __stdcall UnrealizeObject( HGDIOBJ h);

__declspec(dllimport) BOOL __stdcall GdiFlush(void);
__declspec(dllimport) DWORD __stdcall GdiSetBatchLimit( DWORD dw);
__declspec(dllimport) DWORD __stdcall GdiGetBatchLimit(void);
# 5173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
typedef int (__stdcall* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (__stdcall* ICMENUMPROCW)(LPWSTR, LPARAM);






__declspec(dllimport) int __stdcall SetICMMode( HDC hdc, int mode);
__declspec(dllimport) BOOL __stdcall CheckColorsInGamut( HDC hdc,
                                                                       LPRGBTRIPLE lpRGBTriple,
                                                                               LPVOID dlpBuffer,
                                                         DWORD nCount);

__declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace( HDC hdc);
__declspec(dllimport) BOOL __stdcall GetLogColorSpaceA( HCOLORSPACE hColorSpace,
                                                                          LPLOGCOLORSPACEA lpBuffer,
                                                     DWORD nSize);
__declspec(dllimport) BOOL __stdcall GetLogColorSpaceW( HCOLORSPACE hColorSpace,
                                                                          LPLOGCOLORSPACEW lpBuffer,
                                                     DWORD nSize);






__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA( LPLOGCOLORSPACEA lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW( LPLOGCOLORSPACEW lplcs);





__declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace( HDC hdc, HCOLORSPACE hcs);
__declspec(dllimport) BOOL __stdcall DeleteColorSpace( HCOLORSPACE hcs);
__declspec(dllimport) BOOL __stdcall GetICMProfileA( HDC hdc,
                                                        LPDWORD pBufSize,
                                                                            LPSTR pszFilename);
__declspec(dllimport) BOOL __stdcall GetICMProfileW( HDC hdc,
                                                        LPDWORD pBufSize,
                                                                            LPWSTR pszFilename);






__declspec(dllimport) BOOL __stdcall SetICMProfileA( HDC hdc, LPSTR lpFileName);
__declspec(dllimport) BOOL __stdcall SetICMProfileW( HDC hdc, LPWSTR lpFileName);





__declspec(dllimport) BOOL __stdcall GetDeviceGammaRamp( HDC hdc, LPVOID lpRamp);
__declspec(dllimport) BOOL __stdcall SetDeviceGammaRamp( HDC hdc, LPVOID lpRamp);
__declspec(dllimport) BOOL __stdcall ColorMatchToTarget( HDC hdc, HDC hdcTarget, DWORD action);
__declspec(dllimport) int __stdcall EnumICMProfilesA( HDC hdc, ICMENUMPROCA proc, LPARAM param);
__declspec(dllimport) int __stdcall EnumICMProfilesW( HDC hdc, ICMENUMPROCW proc, LPARAM param);






__declspec(dllimport) BOOL __stdcall UpdateICMRegKeyA( DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command);

__declspec(dllimport) BOOL __stdcall UpdateICMRegKeyW( DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command);







#pragma deprecated (UpdateICMRegKeyW)
#pragma deprecated (UpdateICMRegKeyA)





__declspec(dllimport) BOOL __stdcall ColorCorrectPalette( HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num);
# 6189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) BOOL __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
__declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
__declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
__declspec(dllimport) BOOL __stdcall wglDeleteContext(HGLRC);
__declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void);
__declspec(dllimport) HDC __stdcall wglGetCurrentDC(void);
__declspec(dllimport) PROC __stdcall wglGetProcAddress(LPCSTR);
__declspec(dllimport) BOOL __stdcall wglMakeCurrent(HDC, HGLRC);
__declspec(dllimport) BOOL __stdcall wglShareLists(HGLRC, HGLRC);
__declspec(dllimport) BOOL __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);





__declspec(dllimport) BOOL __stdcall SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT x;
    FLOAT y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT gmfBlackBoxX;
    FLOAT gmfBlackBoxY;
    POINTFLOAT gmfptGlyphOrigin;
    FLOAT gmfCellIncX;
    FLOAT gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, *LPGLYPHMETRICSFLOAT;



__declspec(dllimport) BOOL __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
__declspec(dllimport) BOOL __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);







typedef struct tagLAYERPLANEDESCRIPTOR {
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerPlane;
    BYTE bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR, *LPLAYERPLANEDESCRIPTOR;
# 6308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
__declspec(dllimport) BOOL __stdcall wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
__declspec(dllimport) int __stdcall wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
__declspec(dllimport) int __stdcall wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
__declspec(dllimport) BOOL __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
__declspec(dllimport) BOOL __stdcall wglSwapLayerBuffers(HDC, UINT);



typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;



__declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP *);
# 6344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\wingdi.h" 3
}



#pragma warning(pop)
# 173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\windows.h" 2 3

# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 1 3
# 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
extern "C" {


#pragma warning(push)



#pragma warning(disable: 4820)
# 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;



typedef MENUTEMPLATEA MENUTEMPLATE;

typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;



typedef LPMENUTEMPLATEA LPMENUTEMPLATE;


typedef LRESULT (__stdcall* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
# 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef INT_PTR (__stdcall* DLGPROC)(HWND, UINT, WPARAM, LPARAM);







typedef void (__stdcall* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (__stdcall* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (__stdcall* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (__stdcall* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (__stdcall* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (__stdcall* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (__stdcall* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (__stdcall* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (__stdcall* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (__stdcall* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (__stdcall* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);


typedef BOOL (__stdcall* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
# 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef PROPENUMPROCA PROPENUMPROC;
typedef PROPENUMPROCEXA PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA EDITWORDBREAKPROC;




typedef BOOL (__stdcall* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (__stdcall* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;
# 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef WINSTAENUMPROCA WINSTAENUMPROC;
typedef DESKTOPENUMPROCA DESKTOPENUMPROC;
# 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
#pragma warning(push)
#pragma warning(disable: 4995)


__declspec(dllimport)
int
__stdcall
wvsprintfA(
          LPSTR,
                                LPCSTR,
         va_list arglist);
__declspec(dllimport)
int
__stdcall
wvsprintfW(
          LPWSTR,
                                LPCWSTR,
         va_list arglist);






__declspec(dllimport)
int
__cdecl
wsprintfA(
          LPSTR,
                                LPCSTR,
    ...);
__declspec(dllimport)
int
__cdecl
wsprintfW(
          LPWSTR,
                                LPCWSTR,
    ...);







#pragma warning(pop)
# 836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;



typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;




typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;





typedef struct tagCBTACTIVATESTRUCT
{
    BOOL fMouse;
    HWND hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;
# 877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;

} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;
# 1031 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct
{
    HWND hwnd;
    RECT rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;




typedef struct tagEVENTMSG {
    UINT message;
    UINT paramL;
    UINT paramH;
    DWORD time;
    HWND hwnd;
} EVENTMSG, *PEVENTMSGMSG, *NPEVENTMSGMSG, *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG, *NPEVENTMSG, *LPEVENTMSG;




typedef struct tagCWPSTRUCT {
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT;





typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, *NPCWPRETSTRUCT, *LPCWPRETSTRUCT;
# 1098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD vkCode;
    DWORD scanCode;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;




typedef struct tagMSLLHOOKSTRUCT {
    POINT pt;
    DWORD mouseData;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
# 1128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagDEBUGHOOKINFO
{
    DWORD idThread;
    DWORD idThreadInstaller;
    LPARAM lParam;
    WPARAM wParam;
    int code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, *NPDEBUGHOOKINFO, * LPDEBUGHOOKINFO;




typedef struct tagMOUSEHOOKSTRUCT {
    POINT pt;
    HWND hwnd;
    UINT wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;



typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    DWORD mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
# 1166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
# 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutA(
         LPCSTR pwszKLID,
         UINT Flags);
__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutW(
         LPCWSTR pwszKLID,
         UINT Flags);
# 1237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HKL
__stdcall
ActivateKeyboardLayout(
         HKL hkl,
         UINT Flags);
# 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
ToUnicodeEx(
         UINT wVirtKey,
         UINT wScanCode,
                          const BYTE *lpKeyState,
                          LPWSTR pwszBuff,
         int cchBuff,
         UINT wFlags,
             HKL dwhkl);


__declspec(dllimport)
BOOL
__stdcall
UnloadKeyboardLayout(
         HKL hkl);

__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameA(
                                LPSTR pwszKLID);
__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameW(
                                LPWSTR pwszKLID);







__declspec(dllimport)
int
__stdcall
GetKeyboardLayoutList(
         int nBuff,
                                       HKL *lpList);

__declspec(dllimport)
HKL
__stdcall
GetKeyboardLayout(
         DWORD idThread);
# 1313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagMOUSEMOVEPOINT {
    int x;
    int y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, * LPMOUSEMOVEPOINT;
# 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
GetMouseMovePointsEx(
         UINT cbSize,
         LPMOUSEMOVEPOINT lppt,
                             LPMOUSEMOVEPOINT lpptBuf,
         int nBufPoints,
         DWORD resolution);
# 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopA(
         LPCSTR lpszDesktop,
               LPCSTR lpszDevice,
               DEVMODEA* pDevmode,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopW(
         LPCWSTR lpszDesktop,
               LPCWSTR lpszDevice,
               DEVMODEW* pDevmode,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpsa);






__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExA(
         LPCSTR lpszDesktop,
               LPCSTR lpszDevice,
               DEVMODEA* pDevmode,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpsa,
         ULONG ulHeapSize,
               PVOID pvoid);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExW(
         LPCWSTR lpszDesktop,
               LPCWSTR lpszDevice,
               DEVMODEW* pDevmode,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpsa,
         ULONG ulHeapSize,
               PVOID pvoid);
# 1437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HDESK
__stdcall
OpenDesktopA(
         LPCSTR lpszDesktop,
         DWORD dwFlags,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HDESK
__stdcall
OpenDesktopW(
         LPCWSTR lpszDesktop,
         DWORD dwFlags,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);






__declspec(dllimport)
HDESK
__stdcall
OpenInputDesktop(
         DWORD dwFlags,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);


__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsA(
             HWINSTA hwinsta,
         DESKTOPENUMPROCA lpEnumFunc,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsW(
             HWINSTA hwinsta,
         DESKTOPENUMPROCW lpEnumFunc,
         LPARAM lParam);






__declspec(dllimport)
BOOL
__stdcall
EnumDesktopWindows(
             HDESK hDesktop,
         WNDENUMPROC lpfn,
         LPARAM lParam);


__declspec(dllimport)
BOOL
__stdcall
SwitchDesktop(
         HDESK hDesktop);


__declspec(dllimport)
BOOL
__stdcall
SetThreadDesktop(
          HDESK hDesktop);

__declspec(dllimport)
BOOL
__stdcall
CloseDesktop(
         HDESK hDesktop);

__declspec(dllimport)
HDESK
__stdcall
GetThreadDesktop(
         DWORD dwThreadId);
# 1558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationA(
             LPCSTR lpwinsta,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationW(
             LPCWSTR lpwinsta,
         DWORD dwFlags,
         ACCESS_MASK dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpsa);






__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationA(
         LPCSTR lpszWinSta,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationW(
         LPCWSTR lpszWinSta,
         BOOL fInherit,
         ACCESS_MASK dwDesiredAccess);






__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsA(
         WINSTAENUMPROCA lpEnumFunc,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsW(
         WINSTAENUMPROCW lpEnumFunc,
         LPARAM lParam);






__declspec(dllimport)
BOOL
__stdcall
CloseWindowStation(
         HWINSTA hWinSta);

__declspec(dllimport)
BOOL
__stdcall
SetProcessWindowStation(
         HWINSTA hWinSta);

__declspec(dllimport)
HWINSTA
__stdcall
GetProcessWindowStation(
    void);
# 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetUserObjectSecurity(
         HANDLE hObj,
         PSECURITY_INFORMATION pSIRequested,
         PSECURITY_DESCRIPTOR pSID);

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectSecurity(
         HANDLE hObj,
         PSECURITY_INFORMATION pSIRequested,
                                    PSECURITY_DESCRIPTOR pSID,
         DWORD nLength,
          LPDWORD lpnLengthNeeded);
# 1680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationA(
         HANDLE hObj,
         int nIndex,
                                    PVOID pvInfo,
         DWORD nLength,
              LPDWORD lpnLengthNeeded);
__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationW(
         HANDLE hObj,
         int nIndex,
                                    PVOID pvInfo,
         DWORD nLength,
              LPDWORD lpnLengthNeeded);






__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationA(
         HANDLE hObj,
         int nIndex,
                              PVOID pvInfo,
         DWORD nLength);
__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationW(
         HANDLE hObj,
         int nIndex,
                              PVOID pvInfo,
         DWORD nLength);
# 1741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagWNDCLASSEXA {
    UINT cbSize;

    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;

    HICON hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, *NPWNDCLASSEXA, *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT cbSize;

    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;

    HICON hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW;






typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;



typedef struct tagWNDCLASSA {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;






typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;


__declspec(dllimport)
BOOL
__stdcall
IsHungAppWindow(
         HWND hwnd);



__declspec(dllimport)
void
__stdcall
DisableProcessWindowsGhosting(
    void);
# 1849 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagMSG {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;



} MSG, *PMSG, *NPMSG, *LPMSG;
# 2007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;
# 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
                               PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;


typedef struct tagMDINEXTMENU
{
    HMENU hmenuIn;
    HMENU hmenuNext;
    HWND hwndNext;
} MDINEXTMENU, * PMDINEXTMENU, * LPMDINEXTMENU;
# 2325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;
# 2610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageA(
         LPCSTR lpString);
__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageW(
         LPCWSTR lpString);
# 2655 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagWINDOWPOS {
    HWND hwnd;
    HWND hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    UINT flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;




typedef struct tagNCCALCSIZE_PARAMS {
    RECT rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
# 2728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

__declspec(dllimport)
BOOL
__stdcall
TrackMouseEvent(
            LPTRACKMOUSEEVENT lpEventTrack);
# 2946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
DrawEdge(
         HDC hdc,
            LPRECT qrc,
         UINT edge,
         UINT grfFlags);
# 3009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
DrawFrameControl(
         HDC,
            LPRECT,
         UINT,
         UINT);
# 3039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
DrawCaption(
         HWND hwnd,
         HDC hdc,
         const RECT * lprect,
         UINT flags);
# 3058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
DrawAnimatedRects(
             HWND hwnd,
         int idAni,
         const RECT *lprcFrom,
         const RECT *lprcTo);
# 3141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagACCEL {

    BYTE fVirt;
    WORD key;
    WORD cmd;





} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCSTR lpszName;
    LPCSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCWSTR lpszName;
    LPCWSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;




typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;


typedef struct tagWINDOWPLACEMENT {
    UINT length;
    UINT flags;
    UINT showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;



} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
# 3225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagNMHDR
{
    HWND hwndFrom;
    UINT_PTR idFrom;
    UINT code;
} NMHDR;







typedef NMHDR * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD styleOld;
    DWORD styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;
# 3296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagMEASUREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemWidth;
    UINT itemHeight;
    ULONG_PTR itemData;
} MEASUREITEMSTRUCT, *PMEASUREITEMSTRUCT, *LPMEASUREITEMSTRUCT;




typedef struct tagDRAWITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemAction;
    UINT itemState;
    HWND hwndItem;
    HDC hDC;
    RECT rcItem;
    ULONG_PTR itemData;
} DRAWITEMSTRUCT, *PDRAWITEMSTRUCT, *LPDRAWITEMSTRUCT;




typedef struct tagDELETEITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    HWND hwndItem;
    ULONG_PTR itemData;
} DELETEITEMSTRUCT, *PDELETEITEMSTRUCT, *LPDELETEITEMSTRUCT;




typedef struct tagCOMPAREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    HWND hwndItem;
    UINT itemID1;
    ULONG_PTR itemData1;
    UINT itemID2;
    ULONG_PTR itemData2;
    DWORD dwLocaleId;
} COMPAREITEMSTRUCT, *PCOMPAREITEMSTRUCT, *LPCOMPAREITEMSTRUCT;
# 3357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetMessageA(
          LPMSG lpMsg,
             HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax);
__declspec(dllimport)
BOOL
__stdcall
GetMessageW(
          LPMSG lpMsg,
             HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax);
# 3404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
TranslateMessage(
         const MSG *lpMsg);

__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageA(
         const MSG *lpMsg);
__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageW(
         const MSG *lpMsg);
# 3444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetMessageQueue(
         int cMessagesMax);

__declspec(dllimport)
BOOL
__stdcall
PeekMessageA(
          LPMSG lpMsg,
             HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax,
         UINT wRemoveMsg);
__declspec(dllimport)
BOOL
__stdcall
PeekMessageW(
          LPMSG lpMsg,
             HWND hWnd,
         UINT wMsgFilterMin,
         UINT wMsgFilterMax,
         UINT wRemoveMsg);
# 3496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
RegisterHotKey(
             HWND hWnd,
         int id,
         UINT fsModifiers,
         UINT vk);

__declspec(dllimport)
BOOL
__stdcall
UnregisterHotKey(
             HWND hWnd,
         int id);
# 3572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
ExitWindowsEx(
         UINT uFlags,
         DWORD dwReason);

__declspec(dllimport)
BOOL
__stdcall
SwapMouseButton(
         BOOL fSwap);

__declspec(dllimport)
DWORD
__stdcall
GetMessagePos(
    void);

__declspec(dllimport)
LONG
__stdcall
GetMessageTime(
    void);

__declspec(dllimport)
LPARAM
__stdcall
GetMessageExtraInfo(
    void);
# 3612 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsWow64Message(
    void);



__declspec(dllimport)
LPARAM
__stdcall
SetMessageExtraInfo(
         LPARAM lParam);


__declspec(dllimport)
LRESULT
__stdcall
SendMessageA(
         HWND hWnd,
         UINT Msg,
                                 WPARAM wParam,
                                 LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageW(
         HWND hWnd,
         UINT Msg,
                                 WPARAM wParam,
                                 LPARAM lParam);
# 3675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         UINT fuFlags,
         UINT uTimeout,
              PDWORD_PTR lpdwResult);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         UINT fuFlags,
         UINT uTimeout,
              PDWORD_PTR lpdwResult);






__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);






__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         SENDASYNCPROC lpResultCallBack,
         ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
         SENDASYNCPROC lpResultCallBack,
         ULONG_PTR dwData);







typedef struct {
    UINT cbSize;
    HDESK hdesk;
    HWND hwnd;
    LUID luid;
} BSMINFO, *PBSMINFO;

__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExA(
         DWORD flags,
                LPDWORD lpInfo,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
              PBSMINFO pbsmInfo);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExW(
         DWORD flags,
                LPDWORD lpInfo,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam,
              PBSMINFO pbsmInfo);
# 3795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageA(
         DWORD flags,
                LPDWORD lpInfo,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageW(
         DWORD flags,
                LPDWORD lpInfo,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
# 3869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef PVOID HDEVNOTIFY;
typedef HDEVNOTIFY *PHDEVNOTIFY;







__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationA(
         HANDLE hRecipient,
         LPVOID NotificationFilter,
         DWORD Flags);
__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationW(
         HANDLE hRecipient,
         LPVOID NotificationFilter,
         DWORD Flags);






__declspec(dllimport)
BOOL
__stdcall
UnregisterDeviceNotification(
         HDEVNOTIFY Handle
    );







typedef PVOID HPOWERNOTIFY;
typedef HPOWERNOTIFY *PHPOWERNOTIFY;



__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterPowerSettingNotification(
       HANDLE hRecipient,
       LPCGUID PowerSettingGuid,
       DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterPowerSettingNotification(
       HPOWERNOTIFY Handle
    );

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterSuspendResumeNotification (
       HANDLE hRecipient,
       DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterSuspendResumeNotification (
       HPOWERNOTIFY Handle
    );
# 3957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
PostMessageA(
             HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostMessageW(
             HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);






__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageA(
         DWORD idThread,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageW(
         DWORD idThread,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
# 4026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
AttachThreadInput(
         DWORD idAttach,
         DWORD idAttachTo,
         BOOL fAttach);


__declspec(dllimport)
BOOL
__stdcall
ReplyMessage(
         LRESULT lResult);

__declspec(dllimport)
BOOL
__stdcall
WaitMessage(
    void);





__declspec(dllimport)
DWORD
__stdcall
WaitForInputIdle(
         HANDLE hProcess,
         DWORD dwMilliseconds);

__declspec(dllimport)

LRESULT
__stdcall




DefWindowProcA(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall




DefWindowProcW(
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);






__declspec(dllimport)
void
__stdcall
PostQuitMessage(
         int nExitCode);



__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcA(
         WNDPROC lpPrevWndFunc,
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcW(
         WNDPROC lpPrevWndFunc,
         HWND hWnd,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
# 4150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
InSendMessage(
    void);
# 4164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
DWORD
__stdcall
InSendMessageEx(
               LPVOID lpReserved);
# 4187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
UINT
__stdcall
GetDoubleClickTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetDoubleClickTime(
         UINT);

__declspec(dllimport)
ATOM
__stdcall
RegisterClassA(
         const WNDCLASSA *lpWndClass);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassW(
         const WNDCLASSW *lpWndClass);






__declspec(dllimport)
BOOL
__stdcall
UnregisterClassA(
         LPCSTR lpClassName,
             HINSTANCE hInstance);
__declspec(dllimport)
BOOL
__stdcall
UnregisterClassW(
         LPCWSTR lpClassName,
             HINSTANCE hInstance);







__declspec(dllimport)
BOOL
__stdcall
GetClassInfoA(
             HINSTANCE hInstance,
         LPCSTR lpClassName,
          LPWNDCLASSA lpWndClass);

__declspec(dllimport)
BOOL
__stdcall
GetClassInfoW(
             HINSTANCE hInstance,
         LPCWSTR lpClassName,
          LPWNDCLASSW lpWndClass);







__declspec(dllimport)
ATOM
__stdcall
RegisterClassExA(
         const WNDCLASSEXA *);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassExW(
         const WNDCLASSEXW *);







__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExA(
             HINSTANCE hInstance,
         LPCSTR lpszClass,
          LPWNDCLASSEXA lpwcx);

__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExW(
             HINSTANCE hInstance,
         LPCWSTR lpszClass,
          LPWNDCLASSEXW lpwcx);
# 4310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef BOOLEAN (__stdcall * PREGISTERCLASSNAMEW)(LPCWSTR);


__declspec(dllimport)
HWND
__stdcall
CreateWindowExA(
         DWORD dwExStyle,
             LPCSTR lpClassName,
             LPCSTR lpWindowName,
         DWORD dwStyle,
         int X,
         int Y,
         int nWidth,
         int nHeight,
             HWND hWndParent,
             HMENU hMenu,
             HINSTANCE hInstance,
             LPVOID lpParam);
__declspec(dllimport)
HWND
__stdcall
CreateWindowExW(
         DWORD dwExStyle,
             LPCWSTR lpClassName,
             LPCWSTR lpWindowName,
         DWORD dwStyle,
         int X,
         int Y,
         int nWidth,
         int nHeight,
             HWND hWndParent,
             HMENU hMenu,
             HINSTANCE hInstance,
             LPVOID lpParam);
# 4372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsWindow(
             HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
IsMenu(
         HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
IsChild(
         HWND hWndParent,
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
DestroyWindow(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowWindow(
         HWND hWnd,
         int nCmdShow);


__declspec(dllimport)
BOOL
__stdcall
AnimateWindow(
         HWND hWnd,
         DWORD dwTime,
         DWORD dwFlags);
# 4424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindow(
         HWND hWnd,
             HDC hdcDst,
             POINT* pptDst,
             SIZE* psize,
             HDC hdcSrc,
             POINT* pptSrc,
         COLORREF crKey,
             BLENDFUNCTION* pblend,
         DWORD dwFlags);




typedef struct tagUPDATELAYEREDWINDOWINFO
{
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;





__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindowIndirect(
         HWND hWnd,
         const UPDATELAYEREDWINDOWINFO* pULWInfo);
# 4476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetLayeredWindowAttributes(
         HWND hwnd,
              COLORREF* pcrKey,
              BYTE* pbAlpha,
              DWORD* pdwFlags);
# 4492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
PrintWindow(
         HWND hwnd,
         HDC hdcBlt,
         UINT nFlags);
# 4508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
SetLayeredWindowAttributes(
         HWND hwnd,
         COLORREF crKey,
         BYTE bAlpha,
         DWORD dwFlags);
# 4538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
ShowWindowAsync(
          HWND hWnd,
          int nCmdShow);


__declspec(dllimport)
BOOL
__stdcall
FlashWindow(
          HWND hWnd,
          BOOL bInvert);


typedef struct {
    UINT cbSize;
    HWND hwnd;
    DWORD dwFlags;
    UINT uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

__declspec(dllimport)
BOOL
__stdcall
FlashWindowEx(
         PFLASHWINFO pfwi);
# 4577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
ShowOwnedPopups(
          HWND hWnd,
          BOOL fShow);

__declspec(dllimport)
BOOL
__stdcall
OpenIcon(
          HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
CloseWindow(
          HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
MoveWindow(
         HWND hWnd,
         int X,
         int Y,
         int nWidth,
         int nHeight,
         BOOL bRepaint);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPos(
         HWND hWnd,
             HWND hWndInsertAfter,
         int X,
         int Y,
         int cx,
         int cy,
         UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
GetWindowPlacement(
         HWND hWnd,
            WINDOWPLACEMENT *lpwndpl);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPlacement(
         HWND hWnd,
         const WINDOWPLACEMENT *lpwndpl);
# 4662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HDWP
__stdcall
BeginDeferWindowPos(
         int nNumWindows);

__declspec(dllimport)
HDWP
__stdcall
DeferWindowPos(
         HDWP hWinPosInfo,
         HWND hWnd,
             HWND hWndInsertAfter,
         int x,
         int y,
         int cx,
         int cy,
         UINT uFlags);


__declspec(dllimport)
BOOL
__stdcall
EndDeferWindowPos(
         HDWP hWinPosInfo);
# 4696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsWindowVisible(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsIconic(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
AnyPopup(
    void);

__declspec(dllimport)
BOOL
__stdcall
BringWindowToTop(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsZoomed(
         HWND hWnd);
# 4765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack2.h" 1 3
# 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\pshpack2.h" 3
#pragma warning(disable: 4103)

#pragma pack(push,2)
# 4765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 2 3








typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;







typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;



typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
# 4803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;



typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
# 4821 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;



typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;

typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;



typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;







# 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 1 3
# 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\shared\\poppack.h" 3
#pragma warning(disable: 4103)

#pragma pack(pop)
# 4849 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 2 3





__declspec(dllimport)
HWND
__stdcall
CreateDialogParamA(
             HINSTANCE hInstance,
         LPCSTR lpTemplateName,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogParamW(
             HINSTANCE hInstance,
         LPCWSTR lpTemplateName,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);






__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamA(
             HINSTANCE hInstance,
         LPCDLGTEMPLATEA lpTemplate,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamW(
             HINSTANCE hInstance,
         LPCDLGTEMPLATEW lpTemplate,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
# 4922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamA(
             HINSTANCE hInstance,
         LPCSTR lpTemplateName,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamW(
             HINSTANCE hInstance,
         LPCWSTR lpTemplateName,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);






__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamA(
             HINSTANCE hInstance,
         LPCDLGTEMPLATEA hDialogTemplate,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamW(
             HINSTANCE hInstance,
         LPCDLGTEMPLATEW hDialogTemplate,
             HWND hWndParent,
             DLGPROC lpDialogFunc,
         LPARAM dwInitParam);
# 4990 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
EndDialog(
         HWND hDlg,
         INT_PTR nResult);

__declspec(dllimport)
HWND
__stdcall
GetDlgItem(
             HWND hDlg,
         int nIDDlgItem);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemInt(
         HWND hDlg,
         int nIDDlgItem,
         UINT uValue,
         BOOL bSigned);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemInt(
         HWND hDlg,
         int nIDDlgItem,
              BOOL *lpTranslated,
         BOOL bSigned);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextA(
         HWND hDlg,
         int nIDDlgItem,
         LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextW(
         HWND hDlg,
         int nIDDlgItem,
         LPCWSTR lpString);







__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextA(
         HWND hDlg,
         int nIDDlgItem,
                         LPSTR lpString,
         int cchMax);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextW(
         HWND hDlg,
         int nIDDlgItem,
                         LPWSTR lpString,
         int cchMax);






__declspec(dllimport)
BOOL
__stdcall
CheckDlgButton(
         HWND hDlg,
         int nIDButton,
         UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
CheckRadioButton(
         HWND hDlg,
         int nIDFirstButton,
         int nIDLastButton,
         int nIDCheckButton);

__declspec(dllimport)
UINT
__stdcall
IsDlgButtonChecked(
         HWND hDlg,
         int nIDButton);

__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageA(
         HWND hDlg,
         int nIDDlgItem,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageW(
         HWND hDlg,
         int nIDDlgItem,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);






__declspec(dllimport)
HWND
__stdcall
GetNextDlgGroupItem(
         HWND hDlg,
             HWND hCtl,
         BOOL bPrevious);

__declspec(dllimport)
HWND
__stdcall
GetNextDlgTabItem(
         HWND hDlg,
             HWND hCtl,
         BOOL bPrevious);

__declspec(dllimport)
int
__stdcall
GetDlgCtrlID(
         HWND hWnd);

__declspec(dllimport)
long
__stdcall
GetDialogBaseUnits(void);


__declspec(dllimport)

LRESULT
__stdcall




DefDlgProcA(
         HWND hDlg,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall




DefDlgProcW(
         HWND hDlg,
         UINT Msg,
         WPARAM wParam,
         LPARAM lParam);







typedef enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
     DCDC_DEFAULT = 0x0000,
     DCDC_DISABLE_FONT_UPDATE = 0x0001,
     DCDC_DISABLE_RELAYOUT = 0x0002,
} DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;


extern "C++" { inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator | (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator |= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator & (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator &= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator ~ (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator ^ (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator ^= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } };


BOOL
__stdcall
SetDialogControlDpiChangeBehavior(
         HWND hWnd,
         DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask,
         DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);

DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
__stdcall
GetDialogControlDpiChangeBehavior(
         HWND hWnd);

typedef enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT = 0x0000,
    DDC_DISABLE_ALL = 0x0001,
    DDC_DISABLE_RESIZE = 0x0002,
    DDC_DISABLE_CONTROL_RELAYOUT = 0x0004,
} DIALOG_DPI_CHANGE_BEHAVIORS;


extern "C++" { inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator | (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator |= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator & (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator &= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator ~ (DIALOG_DPI_CHANGE_BEHAVIORS a) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator ^ (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator ^= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } };


BOOL
__stdcall
SetDialogDpiChangeBehavior(
         HWND hDlg,
         DIALOG_DPI_CHANGE_BEHAVIORS mask,
         DIALOG_DPI_CHANGE_BEHAVIORS values);

DIALOG_DPI_CHANGE_BEHAVIORS
__stdcall
GetDialogDpiChangeBehavior(
         HWND hDlg);
# 5239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterA(
         LPMSG lpMsg,
         int nCode);
__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterW(
         LPMSG lpMsg,
         int nCode);
# 5265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
OpenClipboard(
             HWND hWndNewOwner);

__declspec(dllimport)
BOOL
__stdcall
CloseClipboard(
    void);




__declspec(dllimport)
DWORD
__stdcall
GetClipboardSequenceNumber(
    void);



__declspec(dllimport)
HWND
__stdcall
GetClipboardOwner(
    void);

__declspec(dllimport)
HWND
__stdcall
SetClipboardViewer(
         HWND hWndNewViewer);

__declspec(dllimport)
HWND
__stdcall
GetClipboardViewer(
    void);

__declspec(dllimport)
BOOL
__stdcall
ChangeClipboardChain(
         HWND hWndRemove,
         HWND hWndNewNext);

__declspec(dllimport)
HANDLE
__stdcall
SetClipboardData(
         UINT uFormat,
             HANDLE hMem);

__declspec(dllimport)
HANDLE
__stdcall
GetClipboardData(
         UINT uFormat);

__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatA(
         LPCSTR lpszFormat);
__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatW(
         LPCWSTR lpszFormat);






__declspec(dllimport)
int
__stdcall
CountClipboardFormats(
    void);

__declspec(dllimport)
UINT
__stdcall
EnumClipboardFormats(
         UINT format);

__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameA(
         UINT format,
                              LPSTR lpszFormatName,
         int cchMaxCount);
__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameW(
         UINT format,
                              LPWSTR lpszFormatName,
         int cchMaxCount);






__declspec(dllimport)
BOOL
__stdcall
EmptyClipboard(
    void);

__declspec(dllimport)
BOOL
__stdcall
IsClipboardFormatAvailable(
         UINT format);

__declspec(dllimport)
int
__stdcall
GetPriorityClipboardFormat(
                         UINT *paFormatPriorityList,
         int cFormats);

__declspec(dllimport)
HWND
__stdcall
GetOpenClipboardWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
AddClipboardFormatListener(
         HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
RemoveClipboardFormatListener(
         HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
GetUpdatedClipboardFormats(
                           PUINT lpuiFormats,
         UINT cFormats,
          PUINT pcFormatsOut);
# 5427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
CharToOemA(
         LPCSTR pSrc,
                                                    LPSTR pDst);
__declspec(dllimport)
BOOL
__stdcall
CharToOemW(
         LPCWSTR pSrc,
                                                    LPSTR pDst);







__declspec(dllimport)
BOOL
__stdcall
OemToCharA(
         LPCSTR pSrc,
                                                    LPSTR pDst);

__declspec(dllimport)
BOOL
__stdcall
OemToCharW(
         LPCSTR pSrc,
                                                    LPWSTR pDst);






__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffA(
         LPCSTR lpszSrc,
                               LPSTR lpszDst,
         DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffW(
         LPCWSTR lpszSrc,
                               LPSTR lpszDst,
         DWORD cchDstLength);






__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffA(
         LPCSTR lpszSrc,
                               LPSTR lpszDst,
         DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffW(
         LPCSTR lpszSrc,
                               LPWSTR lpszDst,
         DWORD cchDstLength);
# 5511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
LPSTR
__stdcall
CharUpperA(
            LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharUpperW(
            LPWSTR lpsz);






__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffA(
                               LPSTR lpsz,
         DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffW(
                               LPWSTR lpsz,
         DWORD cchLength);






__declspec(dllimport)
LPSTR
__stdcall
CharLowerA(
            LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharLowerW(
            LPWSTR lpsz);






__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffA(
                               LPSTR lpsz,
         DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffW(
                               LPWSTR lpsz,
         DWORD cchLength);






__declspec(dllimport)
LPSTR
__stdcall
CharNextA(
         LPCSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharNextW(
         LPCWSTR lpsz);






__declspec(dllimport)
LPSTR
__stdcall
CharPrevA(
         LPCSTR lpszStart,
         LPCSTR lpszCurrent);
__declspec(dllimport)
LPWSTR
__stdcall
CharPrevW(
         LPCWSTR lpszStart,
         LPCWSTR lpszCurrent);







__declspec(dllimport)
LPSTR
__stdcall
CharNextExA(
          WORD CodePage,
          LPCSTR lpCurrentChar,
          DWORD dwFlags);

__declspec(dllimport)
LPSTR
__stdcall
CharPrevExA(
          WORD CodePage,
          LPCSTR lpStart,
          LPCSTR lpCurrentChar,
          DWORD dwFlags);
# 5657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaW(
         WCHAR ch);






__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericW(
         WCHAR ch);






__declspec(dllimport)
BOOL
__stdcall
IsCharUpperA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharUpperW(
         WCHAR ch);






__declspec(dllimport)
BOOL
__stdcall
IsCharLowerA(
         CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharLowerW(
         WCHAR ch);
# 5729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HWND
__stdcall
SetFocus(
             HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
GetActiveWindow(
    void);

__declspec(dllimport)
HWND
__stdcall
GetFocus(
    void);

__declspec(dllimport)
UINT
__stdcall
GetKBCodePage(
    void);

__declspec(dllimport)
SHORT
__stdcall
GetKeyState(
         int nVirtKey);

__declspec(dllimport)
SHORT
__stdcall
GetAsyncKeyState(
         int vKey);

__declspec(dllimport)

BOOL
__stdcall
GetKeyboardState(
                      PBYTE lpKeyState);

__declspec(dllimport)
BOOL
__stdcall
SetKeyboardState(
                    LPBYTE lpKeyState);
# 5785 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
GetKeyNameTextA(
         LONG lParam,
                          LPSTR lpString,
         int cchSize);
__declspec(dllimport)
int
__stdcall
GetKeyNameTextW(
         LONG lParam,
                          LPWSTR lpString,
         int cchSize);
# 5812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
GetKeyboardType(
         int nTypeFlag);

__declspec(dllimport)
int
__stdcall
ToAscii(
         UINT uVirtKey,
         UINT uScanCode,
                        const BYTE *lpKeyState,
          LPWORD lpChar,
         UINT uFlags);


__declspec(dllimport)
int
__stdcall
ToAsciiEx(
         UINT uVirtKey,
         UINT uScanCode,
                        const BYTE *lpKeyState,
          LPWORD lpChar,
         UINT uFlags,
             HKL dwhkl);


__declspec(dllimport)
int
__stdcall
ToUnicode(
         UINT wVirtKey,
         UINT wScanCode,
                              const BYTE *lpKeyState,
                          LPWSTR pwszBuff,
         int cchBuff,
         UINT wFlags);

__declspec(dllimport)
DWORD
__stdcall
OemKeyScan(
         WORD wOemChar);

__declspec(dllimport)
SHORT
__stdcall
VkKeyScanA(
         CHAR ch);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanW(
         WCHAR ch);







__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExA(
         CHAR ch,
         HKL dwhkl);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExW(
         WCHAR ch,
         HKL dwhkl);
# 5900 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
void
__stdcall
keybd_event(
         BYTE bVk,
         BYTE bScan,
         DWORD dwFlags,
         ULONG_PTR dwExtraInfo);
# 5934 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
void
__stdcall
mouse_event(
         DWORD dwFlags,
         DWORD dx,
         DWORD dy,
         DWORD dwData,
         ULONG_PTR dwExtraInfo);






typedef struct tagMOUSEINPUT {
    LONG dx;
    LONG dy;
    DWORD mouseData;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD wVk;
    WORD wScan;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, * LPKEYBDINPUT;




typedef struct tagHARDWAREINPUT {
    DWORD uMsg;
    WORD wParamL;
    WORD wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, * LPHARDWAREINPUT;





typedef struct tagINPUT {
    DWORD type;

    union
    {
        MOUSEINPUT mi;
        KEYBDINPUT ki;
        HARDWAREINPUT hi;
    } ;
} INPUT, *PINPUT, * LPINPUT;

__declspec(dllimport)
UINT
__stdcall
SendInput(
         UINT cInputs,
                        LPINPUT pInputs,
         int cbSize);
# 6660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

__declspec(dllimport)
BOOL
__stdcall
GetLastInputInfo(
          PLASTINPUTINFO plii);
# 6678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyA(
         UINT uCode,
         UINT uMapType);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyW(
         UINT uCode,
         UINT uMapType);







__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExA(
         UINT uCode,
         UINT uMapType,
             HKL dwhkl);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExW(
         UINT uCode,
         UINT uMapType,
             HKL dwhkl);
# 6732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
GetInputState(
    void);

__declspec(dllimport)
DWORD
__stdcall
GetQueueStatus(
         UINT flags);


__declspec(dllimport)
HWND
__stdcall
GetCapture(
    void);

__declspec(dllimport)
HWND
__stdcall
SetCapture(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ReleaseCapture(
    void);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjects(
         DWORD nCount,
                           const HANDLE *pHandles,
         BOOL fWaitAll,
         DWORD dwMilliseconds,
         DWORD dwWakeMask);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjectsEx(
         DWORD nCount,
                           const HANDLE *pHandles,
         DWORD dwMilliseconds,
         DWORD dwWakeMask,
         DWORD dwFlags);
# 6860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
UINT_PTR
__stdcall
SetTimer(
             HWND hWnd,
         UINT_PTR nIDEvent,
         UINT uElapse,
             TIMERPROC lpTimerFunc);
# 6889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
KillTimer(
             HWND hWnd,
         UINT_PTR uIDEvent);

__declspec(dllimport)
BOOL
__stdcall
IsWindowUnicode(
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
EnableWindow(
         HWND hWnd,
         BOOL bEnable);

__declspec(dllimport)
BOOL
__stdcall
IsWindowEnabled(
         HWND hWnd);

__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsA(
             HINSTANCE hInstance,
         LPCSTR lpTableName);
__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsW(
             HINSTANCE hInstance,
         LPCWSTR lpTableName);






__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableA(
                       LPACCEL paccel,
         int cAccel);
__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableW(
                       LPACCEL paccel,
         int cAccel);






__declspec(dllimport)
BOOL
__stdcall
DestroyAcceleratorTable(
         HACCEL hAccel);

__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableA(
         HACCEL hAccelSrc,
                                               LPACCEL lpAccelDst,
         int cAccelEntries);
__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableW(
         HACCEL hAccelSrc,
                                               LPACCEL lpAccelDst,
         int cAccelEntries);
# 6979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
TranslateAcceleratorA(
         HWND hWnd,
         HACCEL hAccTable,
         LPMSG lpMsg);
__declspec(dllimport)
int
__stdcall
TranslateAcceleratorW(
         HWND hWnd,
         HACCEL hAccTable,
         LPMSG lpMsg);
# 7169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
GetSystemMetrics(
         int nIndex);
# 7843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
typedef struct tagDROPSTRUCT
{
    HWND hwndSource;
    HWND hwndSink;
    DWORD wFmt;
    ULONG_PTR dwData;
    POINT ptDrop;
    DWORD dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;
# 7869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
DWORD
__stdcall
DragObject(
         HWND hwndParent,
         HWND hwndFrom,
         UINT fmt,
         ULONG_PTR data,
             HCURSOR hcur);

__declspec(dllimport)
BOOL
__stdcall
DragDetect(
         HWND hwnd,
         POINT pt);
# 7894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
DrawIcon(
         HDC hDC,
         int X,
         int Y,
         HICON hIcon);
# 8072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
GrayStringA(
         HDC hDC,
             HBRUSH hBrush,
             GRAYSTRINGPROC lpOutputFunc,
         LPARAM lpData,
         int nCount,
         int X,
         int Y,
         int nWidth,
         int nHeight);
__declspec(dllimport)
BOOL
__stdcall
GrayStringW(
         HDC hDC,
             HBRUSH hBrush,
             GRAYSTRINGPROC lpOutputFunc,
         LPARAM lpData,
         int nCount,
         int X,
         int Y,
         int nWidth,
         int nHeight);
# 8130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
DrawStateA(
         HDC hdc,
             HBRUSH hbrFore,
             DRAWSTATEPROC qfnCallBack,
         LPARAM lData,
         WPARAM wData,
         int x,
         int y,
         int cx,
         int cy,
         UINT uFlags);
__declspec(dllimport)
BOOL
__stdcall
DrawStateW(
         HDC hdc,
             HBRUSH hbrFore,
             DRAWSTATEPROC qfnCallBack,
         LPARAM lData,
         WPARAM wData,
         int x,
         int y,
         int cx,
         int cy,
         UINT uFlags);
# 8172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
LONG
__stdcall
TabbedTextOutA(
         HDC hdc,
         int x,
         int y,
                        LPCSTR lpString,
         int chCount,
         int nTabPositions,
                                  const INT *lpnTabStopPositions,
         int nTabOrigin);
__declspec(dllimport)
LONG
__stdcall
TabbedTextOutW(
         HDC hdc,
         int x,
         int y,
                        LPCWSTR lpString,
         int chCount,
         int nTabPositions,
                                  const INT *lpnTabStopPositions,
         int nTabOrigin);






__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentA(
         HDC hdc,
                        LPCSTR lpString,
         int chCount,
         int nTabPositions,
                                  const INT *lpnTabStopPositions);
__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentW(
         HDC hdc,
                        LPCWSTR lpString,
         int chCount,
         int nTabPositions,
                                  const INT *lpnTabStopPositions);






__declspec(dllimport)
BOOL
__stdcall
UpdateWindow(
         HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetActiveWindow(
         HWND hWnd);


__declspec(dllimport)
HWND
__stdcall
GetForegroundWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
PaintDesktop(
         HDC hdc);

__declspec(dllimport)
void
__stdcall
SwitchToThisWindow(
         HWND hwnd,
         BOOL fUnknown);



__declspec(dllimport)
BOOL
__stdcall
SetForegroundWindow(
         HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
AllowSetForegroundWindow(
         DWORD dwProcessId);



__declspec(dllimport)
BOOL
__stdcall
LockSetForegroundWindow(
         UINT uLockCode);






__declspec(dllimport)
HWND
__stdcall
WindowFromDC(
         HDC hDC);

__declspec(dllimport)
HDC
__stdcall
GetDC(
             HWND hWnd);

__declspec(dllimport)
HDC
__stdcall
GetDCEx(
             HWND hWnd,
             HRGN hrgnClip,
         DWORD flags);
# 8330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
HDC
__stdcall
GetWindowDC(
             HWND hWnd);

__declspec(dllimport)
int
__stdcall
ReleaseDC(
             HWND hWnd,
         HDC hDC);

__declspec(dllimport)
HDC
__stdcall
BeginPaint(
         HWND hWnd,
          LPPAINTSTRUCT lpPaint);

__declspec(dllimport)
BOOL
__stdcall
EndPaint(
         HWND hWnd,
         const PAINTSTRUCT *lpPaint);

__declspec(dllimport)
BOOL
__stdcall
GetUpdateRect(
         HWND hWnd,
              LPRECT lpRect,
         BOOL bErase);

__declspec(dllimport)
int
__stdcall
GetUpdateRgn(
         HWND hWnd,
         HRGN hRgn,
         BOOL bErase);

__declspec(dllimport)
int
__stdcall
SetWindowRgn(
         HWND hWnd,
             HRGN hRgn,
         BOOL bRedraw);
# 8388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
GetWindowRgn(
         HWND hWnd,
         HRGN hRgn);



__declspec(dllimport)
int
__stdcall
GetWindowRgnBox(
         HWND hWnd,
          LPRECT lprc);



__declspec(dllimport)
int
__stdcall
ExcludeUpdateRgn(
         HDC hDC,
         HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRect(
             HWND hWnd,
             const RECT *lpRect,
         BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRect(
             HWND hWnd,
             const RECT *lpRect);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRgn(
         HWND hWnd,
             HRGN hRgn,
         BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRgn(
         HWND hWnd,
             HRGN hRgn);


__declspec(dllimport)
BOOL
__stdcall
RedrawWindow(
             HWND hWnd,
             const RECT *lprcUpdate,
             HRGN hrgnUpdate,
         UINT flags);
# 8484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
BOOL
__stdcall
LockWindowUpdate(
             HWND hWndLock);

__declspec(dllimport)
BOOL
__stdcall
ScrollWindow(
         HWND hWnd,
         int XAmount,
         int YAmount,
             const RECT *lpRect,
             const RECT *lpClipRect);

__declspec(dllimport)
BOOL
__stdcall
ScrollDC(
         HDC hDC,
         int dx,
         int dy,
             const RECT *lprcScroll,
             const RECT *lprcClip,
             HRGN hrgnUpdate,
              LPRECT lprcUpdate);

__declspec(dllimport)
int
__stdcall
ScrollWindowEx(
         HWND hWnd,
         int dx,
         int dy,
             const RECT *prcScroll,
             const RECT *prcClip,
             HRGN hrgnUpdate,
              LPRECT prcUpdate,
         UINT flags);
# 8540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\um\\winuser.h" 3
__declspec(dllimport)
int
__stdcall
SetScrollPos(
         HWND hWnd,
         int nBar,
         int nPos,
         BOOL bRedraw);

__declspec(dllimport)
int
__stdcall
GetScrollPos(
         HWND hWnd,
         int nBar);

__declspec(dllimport)
BOOL
__stdcall
SetScrollRange(
         HWND hWnd,
         int nBar,
         int nMinPos,
         int nMaxPos,
         BOOL bRedraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollRange(
         HWND hWnd,
         int nBar,
          LPINT lpMinPos,
          LPINT lpMaxPos);

__declspec(dllimport)
BOOL
__stdcall
ShowScrollBar(
      